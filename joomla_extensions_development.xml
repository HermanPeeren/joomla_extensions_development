<?xml version="1.0" encoding="UTF-8"?>
<book version="5.1" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xila="http://www.w3.org/2001/XInclude/local-attributes"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:trans="http://docbook.org/ns/transclusion"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Joomla Extensions Development</title>

    <author>
      <personname><firstname>Nicholas</firstname><othername>K.</othername><surname>Dionysopoulos</surname></personname>

      <affiliation>
        <orgname>Akeeba Ltd</orgname>
      </affiliation>
    </author>

    <pubdate>August 2022</pubdate>

    <copyright>
      <year>2022</year>

      <holder>Nicholas K. Dionysopoulos</holder>
    </copyright>

    <legalnotice>
      <para>Permission is granted to copy, distribute and/or modify this
      document under the terms of the GNU Free Documentation License, Version
      1.3 or any later version published by the Free Software Foundation; with
      no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
      copy of the license is included in the section entitled "GNU Free
      Documentation License".</para>
    </legalnotice>
  </info>

  <chapter xml:id="intro">
    <title>Introduction</title>

    <section xml:id="intro-about">
      <title>About this book</title>

      <para>I started writing this book in August 2022 as a quick reference
      for myself and other third party developers writing Joomla 4 extensions,
      or migrating our extensions to Joomla 4's native MVC.</para>

      <para>While Joomla 4 has an amazing, rich and powerful architecture and
      API it does not have any real developer-facing documentation. The
      documentation you will find is outdated, chaotic and leaves you running
      for your life.</para>

      <para>I am making every effort to make this book approachable to all
      levels of developers, from the novice who's barely hacked together their
      first plugin to the seasoned expert with dozens of extensions under
      their belt. However, to keep things relatively simple and because I am
      doing this unpaid, on my limited free time, I decided to take a few
      shortcuts here and there. I do not explain every concept in great
      detail, I try to explain it in practical detail.</para>

      <para>If you want to see what a real world Joomla extension looks like I
      urge you to take a look at and dissect the Joomla 4 extensions my
      company, Akeeba Ltd, has published free of charge. The simplest
      component to start with is Akeeba ContactUs. The most complete
      combination of a component, plugins and several modules we have
      published is Akeeba Ticket System — even the free of charge version uses
      most of the features I am describing in this book.</para>

      <para>Hopefully, you will find my approach pragmatic and result–driven
      instead of a dry, technical document. If you have suggestions for
      improvement or would like to sponsor this work feel free to contact me
      through the Contact Us page on <link
      xlink:href="https://www.akeeba.com">akeeba.com</link> or the Contact Me
      page on <link
      xlink:href="https://www.dionysopoulos.me">dionysopoulos.me</link>.</para>
    </section>

    <section xml:id="about-me">
      <title>About the author</title>

      <para>Hi, I am Nicholas. I am a Mechanical Engineer turned Software
      Engineer. I am from and still live in Greece with my wife, daughter and
      our two naughty cats.</para>

      <para>I've been into computers since I was 11 years olds, at the dawn of
      the 1990s. Back then dinosaurs were still walking among us, haircuts
      were <emphasis>weird</emphasis>, personal computers were the size of a
      small backpack and had <emphasis>far less</emphasis> computing power
      than your average smart lightbulb. Only one of the previous statements
      is false. I immediately took to programming for, as I said to my parents
      at the time, “I want to learn how to make this machine do things for me
      so I don't have to do them”. LIttle did I know what I was getting myself
      into…</para>

      <para>I've been using Joomla as a site integrator and extensions
      developer since it was called Mambo, back in 2004. I wrote my first
      mass–distributed extension called JoomlaPack in October 2006 while
      taking a two week break from my day job at the time as a business
      consultant. One thing led to another, JoomlaPack became Akeeba Backup
      and I gave up on business consultancy and mechanical engineering to
      become a full time software engineer.</para>

      <para>I've been actively participating in the Joomla community since
      2009. I am a regular Joomla contributor and not just writting code. I've
      been involved in community outreach efforts and instigated the events
      leading to the beginning of the Joomla 4 effort. I still contribute to
      Joomla and, if I want to be honest with myself, I will continue doing
      that until Joomla or myself is no more, whichever comes first.</para>

      <para>I am neurodivergent (ADHD) and have a particular sense of humour.
      I firmly believe that life's too short to take it seriously. You'll see
      that a lot in this book. I don't care about writing a dry, boring book,
      especially on a subject as dry and boring as writing software.</para>
    </section>

    <section xml:id="intro-j4-features">
      <title>New Joomla 4 features at a glance</title>

      <para>Joomla 4 is a smorgasbord of new features, improvements and much
      needed changes. Unfortunately, a year into its release you'd be hard
      pressed to find any kind of documentation of what these are and how they
      can impact your software development practices. I will try to give you
      the 30,000–feet overview of what <emphasis>I</emphasis> found to be the
      most important changes.</para>

      <para><link linkend="concepts-namespaces"><emphasis
      role="bold">Namespaces</emphasis></link>. As you may remember, ever
      since Joomla 3.3 the legacy class names (e.g. <code>JUri</code>) changed
      to a namespaced equivalent (e.g. <code>Joomla\CMS\Uri\Uri</code>). In
      Joomla 4 a lot of the legacy classes stopped working. You can find out
      these changes neatly codified along with tools to mass convert your
      extensions in my <link
      xlink:href="http://github.com/nikosdion/joomlatypehints">Joomla Type
      Hints</link> repository. In Joomla 4 the namespacing work went even
      deeper, having all classes in components, modules, plugins and templates
      also support namespaces — if you use the new, Joomla 4 API for
      developing extensions. This is a game-changer concept! Namespaced
      classes follow the <link
      xlink:href="https://www.php-fig.org/psr/psr-4/">PSR-4</link>
      specification. Joomla caches and registers the PSR-4 mappings between
      namespace prefixes and directories on your site which means that
      <emphasis>you can safely use any class of any extension anywhere without
      having to use <code>include</code> or <code>require</code> ever
      again</emphasis>. This greatly reduces the possibility for bugs and
      massively improves the performance of Joomla and its extensions.</para>

      <para><emphasis role="bold"><link
      linkend="concepts-container">Dependency Injection Container / Service
      Locator</link></emphasis>. Joomla 1.x to 3.x inclusive had this annoying
      <link xlink:href="https://en.wikipedia.org/wiki/God_object">God
      Object</link> called the Joomla Factory (<code>JFactory</code> or
      <code>\Joomla\CMS\Factory</code>). It had a very opinionated approach on
      instantiating all sorts of globally used services, from the application
      itself, to the database, to the user objects, to the mailer object. If
      you wanted to write Unit Tests for your extension — or Joomla itself —
      it was the bane of your existence. In Joomla 4 we instead have a
      Container. It is not a real <link
      xlink:href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency
      Injection Container</link> as much as it is a <link
      xlink:href="https://en.wikipedia.org/wiki/Service_locator_pattern">Service
      Locator</link>, meaning that it won't magically instantiate an object
      based on the type definitions in its class' constructor but it will let
      you retrieve the services you need to inject to your objects. Each
      extension — component, module, plugin and template — gets its own
      service locator and its own extension object which uses it. This makes
      it far easier to write unit tests for your code, especially your Models
      (which is where most of your business logic, therefore your code that
      needs testing, should already be).</para>

      <para><link linkend="concepts-webassetmanager"><emphasis role="bold">Web
      Asset Manager</emphasis></link>. In the past, whenever we wanted to load
      a JavaScript or CSS file we'd have to load its dependencies and finally
      our file. For example we might want to load jQuery, then load some
      Bootstrap core JavaScript files, then our JavaScript file. Each
      extension would do that and it lead to several chicken and egg problems.
      What if file A from extension X depends on files B and C and file B from
      extension Y depends on files C and D but D must be loaded before C?
      Bummer. The Web Asset Manager codifies the dependencies in a way which
      lets Joomla resolve them. It also lets you define alternative
      dependencies,e.g. a different JavaScript file to load depending on
      whether the user's browser supports <link
      xlink:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript
      modules</link> or not, and asset groups, e.g. a collection of CSS and
      JavaScript which are meant to be loaded together. This lets you split
      your CSS and JavaScript into smaller files which load in the correct
      order and improve the performance of your user's site.</para>

      <para><emphasis role="bold"><link linkend="com-j3-vs-j4-mvc">A new
      MVC</link></emphasis>. The MVC in Joomla 1.5 to 3.10 inclusive had
      changed very little. Previous attempts to modernise it failed
      ignominiously because they simultaneously failed to go far enough and
      maintain <acronym>b/c</acronym> (backwards compatibility). Joomla 4 has
      a new MVC model which is based on Dependency Injection and namespaces,
      it is more prescriptive, more flexible and more powerful than its
      predecessors. You can very easily extend a frontend model from a backend
      model instead of writing the same code twice or doing a contortionist
      act with PHP Traits. You can easily create custom HTML helpers without
      calling static functions, use categories without writing precarious
      database code, create object-oriented URL routers and much more which we
      will explore in this book.</para>

      <para><emphasis role="bold">Hide-able inline help</emphasis>. Remember
      how Joomla 3 XML Forms looked like a word vomit with all the inline help
      text (field descriptions) being always visible? This was a bad interface
      for experienced users. At the same time, Joomla 4.0 removing all inline
      help text made the interface inapproachable for newcomers and end
      clients meant to use the site. With Joomla 4.1 it is now possible to
      have hide-able inline help text in your forms and your component
      configuration. The field descriptions are hidden by default and the user
      can show them by clicking on the <guibutton>Show Inline Help</guibutton>
      button in the interface. Now your extensions' interface can be
      simultaneously approachable for both new and experienced users.</para>

      <para><emphasis role="bold">Prepared statements</emphasis>. SQL
      injection vulnerabilities have been almost <emphasis>de
      rigueur</emphasis> for any web software, Joomla extensions being no
      exception to that. Sure, Joomla does have some very nifty tools to get
      filtered input and escape it when placed inside database queries but not
      all input can be escaped sufficiently if you do not know its
      <emphasis>type</emphasis> (integer, string, array of one or the other).
      Moreover, despite best intentions, accidents can and do happen, e.g.
      forgetting to escape one piece of input you assumed it's an integer but
      it came through a path which never did check the input type nor did it
      try to typecast it to an integer! Joomla 4 introduced <link
      xlink:href="https://en.wikipedia.org/wiki/Prepared_statement">prepared
      statements</link> which make these oversights and corner cases a thing
      of the past. You tell the query builder where you expect potentially
      user-originating data in your query, which data to use in there and what
      type this data is. You are guaranteed safe execution without worrying
      about SQL injection <emphasis>unless you try really hard</emphasis> to
      NOT let Joomla use a prepared statement. On the flip side, there are a
      few types of SQL queries which cannot execute in the context of prepared
      statements and required some code contortion to execute.</para>

      <para><link linkend="com-mailtemplates"><emphasis role="bold">Mail
      templates</emphasis></link>. In the past there were two ways to handle
      email for your extension. You could send plain text only email using
      language strings OR you would have to invent your own email template
      management. The former led to ugly email messages. The latter required
      reinventing a very complex device on each and every of your components.
      If you did not have a component, tough luck. Darn! Joomla 4's mail
      templates feature allows your users to use the Joomla WYSIWYG editor to
      create rich email templates with placeholders to be replaced by data
      provided by your extension. This feature looks half-finished in Joomla 4
      as it has no obvious way to register or update email templates. Don't
      worry, though, we do have a way to work around its shortcomings,
      complete with example code.</para>

      <para><link linkend="com-scheduled-tasks"><emphasis
      role="bold">Scheduled Tasks</emphasis></link>. Many extensions need to
      periodically execute some kind of code. For example, sending email
      newsletters, updating the prices of thousands of SKUs in an online shop
      from an Excel or XML file, running backups, you name it! In the past we
      had to reinvent the wheel on each extension we built. For example, we
      created ‘special’ URLs in our components or through com_ajax to be
      accessed with wget, cURL or a service like WebCRON.org periodically; or
      we created CLI scripts to be used with CRON jobs. We almost always
      offered more than one way to do things which led to a certain degree of
      code duplication. In all cases, the user was responsible for setting up
      CRON jobs or the equivalent on a third party service for every single
      task they needed to be executed periodically. This was a tall ask!
      Joomla 4.1 and later offers a new Scheduled Tasks feature which allows
      users to select which tasks they want to be executed, when to execute
      them and even configure their execution parameters — all within the
      familiar Joomla user interface. It even lets the task scheduler to be
      executed three ways: with a command line CRON job, a URL–based CRON job
      or automatically based on visitor traffic (lazy scheduling). The end
      user has to set up just the one CRON job or, if they are using lazy
      scheduling, just flip a switch.</para>

      <para><link linkend="com-cli"><emphasis role="bold">CLI
      Application</emphasis></link>. In the past we had to create bespoke CLI
      scripts for every task each of our extensions needed to allow to be
      executed from a command line context, be it a CRON job or a manually
      executed CLI helper tool. This required creating a new application and
      contend with the two facts that a) the base class changed at least twice
      in the last ten years and b) it lacked a lot of methods several core and
      third party classes were expecting to be present. This led to a lot of
      reinventing the wheel. The Joomla CLI Application is like a built-in
      version of WordPress' WP-CLI or Drupal's Drush in that it's based on the
      Symfony Console Components and can be easily extended using plugins
      which register command classes. Used wisely, it can enhance your
      extensions and help your advanced users who can use the CLI to automate
      things around their site.</para>

      <para><link linkend="com-api"><emphasis role="bold">API
      Application</emphasis></link>. Joomla has historically been an HTML–only
      application. Yes, sure, you can have JSON, XML, Feed and Raw views but
      they feel bolted onto the HTML application; they are not a real API to
      your component. Joomla 4 introduced a brand-new application, the
      ApiApplication which lives in the <filename>api</filename> directory of
      your site. For now it's only accessible to Super Users but it provides a
      real RESTful JSON-based API to components which integrate with it.
      Integrating your component with the API application is as easy as
      creating a Web Services plugin and adding a few easy to create
      controllers and views in the API part of your component. That is to say,
      your component now has a backend, a frontend and an API side. You don't
      <emphasis>have</emphasis> to integrate with the API application but if
      you have something which could benefit from automation it is strongly
      encouraged to do so.</para>

      <para><emphasis role="bold">Dashboards</emphasis>. Between Joomla 1.0
      and 3.10 inclusive Joomla only ever offered one dashboard, the main
      Control Panel page which loaded when you logged into your site's
      backend. In Joomla 1.0 to 1.6 it was hard–coded and inflexible. I added
      the ability to use plugins to render custom action buttons in Joomla
      1.7, based on my experience with my software. Starting with Joomla 3.0
      you could now publish <emphasis>modules</emphasis> to add information
      panes to the Control Panel dashboard. If you wanted the same experience
      in your extension… tough luck. You would have to reinvent the wheel.
      Joomla 4.0 and later allow you to set up <emphasis>one or more dashboard
      pages for your own component</emphasis> which appear in the Joomla menu
      structure, under your component's menu item, and where you and your end
      users can publish any number of modules.</para>

      <para><emphasis role="bold">Layouts everywhere</emphasis>. A lot of the
      HTML generated by Joomla, even throughout version 3, was statically
      coded in the PHP files implementing the business logic, making any kind
      of customisation impossible (or, at the very least, requiring a very
      judicious application of in-memory code editing, buffer stream wrappers
      and Reflection). Let's just say that if you disagreed with how a certain
      form field or HTML helper rendered its HTML you were out of luck.
      Layouts were introduced in Joomla 3.4 and later versions did make better
      use of them in various places but you still had to contend with several
      of the same issues. Not anymore! Joomla 4 uses layouts for every kind of
      HTML output. If you want to override how some core code renders in your
      component or your template you can easily do that by overriding the
      layout. Likewise, you are encouraged to use Layouts everywhere you have
      reusable HTML output in your extensions to make it easier for end users
      to override them in their template.</para>

      <para><emphasis role="bold">Media options per component</emphasis>.
      Joomla 3.4 introduced an upload checker for all uploaded files based on
      the work I had done in Admin Tools. This was a massive leap in security
      as we codified the basic upload checks and encapsulated them in a way
      that made them run automatically whenever you were handling uploads.
      However, this was controlled by the Media component's
      (<code>com_media</code>) settings. This was great if your extension only
      ever needed static media files to be uploaded. If you wanted to allow
      your users to upload non–media files, or files otherwise not acceptable
      anywhere else <code>com_media</code> was exposed, such as ZIP, 7Z, and
      RAR files in a helpdesk component, you had to modify the Media options,
      allowing these files <emphasis>everywhere</emphasis>. The unfortunate
      solution to that was that third party component developers chose to
      <emphasis>disable</emphasis> the upload checks, undoing the security
      improvements we added in Joomla 3.4. This is no longer the case! Joomla
      4 allows each component to have its own, private copy of Media settings
      for its own uploads. Any upload being handled by your component (not
      <code>com_media</code>!) will have these private settings applied. It's
      a bit of a chore BUT it lets you provide a much safer option for
      uploading files through your extension.</para>

      <para>There are many more improvements which I will not cover in this
      book. If you found out something cool and you'd like me to write a
      section for it, please do let me know. I can't promise it will
      definitely make it into the book but I will at least promise to give it
      a good thought and most likely a good try.</para>
    </section>
  </chapter>

  <chapter xml:id="concepts">
    <title>Basic concepts</title>

    <para>As mentioned in the <link linkend="intro-j4-features">previous
    chapter</link>, Joomla 4 introduced a lot of new features. Some of these
    features introduce new fundamental concepts or refine existing ones.
    Before delving deeper into Joomla extension development let's take a look
    at these basic concepts to make sure we are all on the same page.</para>

    <section xml:id="concepts-namespaces">
      <title>Namespaces</title>

      <para>The single most defining change in Joomla 4 is that Joomla
      embraces <link
      xlink:href="https://www.php.net/manual/en/language.namespaces.php">PHP
      namespaces</link> everywhere: core, core extensions, third party
      extensions and everything in between.</para>

      <bridgehead>The core</bridgehead>

      <para>The work on namespacing core Joomla API classes had started since
      Joomla 3.3. If you have not updated your code the last few years you may
      have found that it no longer works on Joomla 4. Do not despair! The vast
      majority of issues comes from your using outdated, non-namespaced
      versions of core classes in your code. Replacing them with their
      namespaced versions will let most Joomla 3–only extensions to run well
      enough in Joomla 4 for a migration to be practical.</para>

      <para>I have collected the old, non-namespaced core classes and the new,
      namespaced names of them along with the Joomla version the namespaced
      versions appeared and the Joomla version the non-namespaced versions are
      or will be removed in <link
      xlink:href="https://github.com/nikosdion/joomlatypehints/blob/main/JoomlaObsoleteClasses.md">my
      Joomla Type Hints</link> repository. The repository also includes <link
      xlink:href="https://getrector.org">Rector</link> configurations which
      allow you to do most of the heavy lifting using an automated tool. For
      everything else you need some good old search and replace across your
      source trees.</para>

      <bridgehead>The extensions</bridgehead>

      <para>The story of Joomla 4 began on the last day of May 2015 in Prague,
      Czech Republic at a round table discussion about the future of Joomla. A
      dozen or so leadership members, core contributors and third party
      developers sat down to figure out why Joomla “sucks” and how to improve
      it.</para>

      <para>Beyond the user-facing issues, we found out that the core MVC and
      architecture were extremely dated. The core MVC started being developed
      in 2005 and made its first appearance in 2007, with Joomla 1.5. It had
      not changed much, despite some moderate improvements in Joomla 1.6 which
      was released in 2010 (e.g. XML Forms) and a few disparate things added
      here and there (e.g. Tags in 3.2, Layouts in 3.4 and so on). You could
      not reference frontend code from the backend or vice-versa. For third
      party extensions this was an annoyance which led to duplicated code and
      bugs. For using core code, like creating articles <emphasis>the right
      way</emphasis> using <code>com_content</code>'s Article model, it was
      nearly impossible: if you tried doing that on a page which had already
      loaded the front-end ContentModelArticle class you could no longer load
      the same–named but entirely differently operating backend class.</para>

      <para>The way to solve that would be to <emphasis>namespace</emphasis>
      the extensions' code. A com_example extension could have the namespace
      prefix \MyCompany\Example\Administrator for its backend classes and
      \MyCompany\Example\Site for its frontend classes. This way you could
      have something like:</para>

      <programlisting>namespace \MyCompany\Example\Site\Model;

class ItemModel extends \MyCompany\Example\Administrator\Model\ItemModel
{
   // ...
}</programlisting>

      <para>By being able to extend classes across application sides you would
      finally be able to get rid of duplicate code and obliterate bugs coming
      from that bad practice.</para>

      <para>By following the <link
      xlink:href="https://www.php-fig.org/psr/psr-4/">PSR-4</link> standard we
      could also have a very efficient autoloader which allows us to load any
      extension's classes from anywhere, without having to know where on the
      filesystem the class file lives and without having to use the ugly
      static methods of the core MVC classes (which, by the way, would NOT
      work predictably across extensions because of their dependence on the
      <code>JPATH_COMPONENT_ADMINISTRATOR</code> and
      <code>JPATH_COMPONENT</code> constants which cannot, of course, be
      redefined).</para>

      <para>Each extension's namespace is declared in the XML manifest of the
      extension using a new XML element under the
      <code>&lt;extension&gt;</code> root element:</para>

      <programlisting>&lt;namespace path="src"&gt;My\Namespace\Prefix&lt;/namespace&gt;</programlisting>

      <para>The <code>path</code> attribute tells Joomla which subdirectory of
      your extension holds the PSR-4 of your extension's PHP files. It is best
      practice to name it <filename>src</filename> but <emphasis>you don't
      have to</emphasis>. In the rest of this section I assume you are using
      <filename>src</filename>.</para>

      <para>The text inside the XML element, <code>My\Namespace\Prefix</code>
      in our example, is the namespace prefix you will be using.</para>

      <para>Here is how namespace prefixes work across different types of
      extensions:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Component, frontend</emphasis>. Each
          component can register its own namespace prefix without any
          restrictions. It is <emphasis>recommended</emphasis> to use the
          convention <code>\Company\Something</code> where
          <code>Company</code> is your company name (or a shortened version
          thereof) and <code>Something</code> corresponds to the
          <code>com_something</code> extension name of your component. For
          example, the component <code>com_example</code> by Acme, Inc could
          have a namespace prefix of <code>\Acme\Example</code> set up in its
          XML manifest. In this case its frontend classes MUST be under the
          namespace <code>\Acme\Example\Site</code>. The folder
          <filename>components/com_example/src</filename> is the root of the
          <code>\Acme\Example\Site</code> namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Component, backend</emphasis>. Let's say
          we have the component <code>com_example</code> by Acme, Inc which
          has a namespace prefix of <code>\Acme\Example</code>. In this case
          its backend classes MUST be under the namespace
          <code>\Acme\Example\Administrator</code>. The folder
          <filename>administrator/components/com_example/src</filename> is the
          root of the <code>\Acme\Example\Administrator</code>
          namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Component, API application</emphasis>.
          The API application is the third Joomla application (the other two
          being Site the frontend, and Administrator the backend). We'll talk
          about it <link linkend="com-api">later in this book</link>. Let's
          say we have the component <code>com_example</code> by Acme, Inc
          which has a namespace prefix of <code>\Acme\Example</code>. In this
          case its API application classes MUST be under the namespace
          <code>\Acme\Example\Api</code>. The folder
          <filename>api/components/com_example/src</filename> is the root of
          the <code>\Acme\Example\Api</code> namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Module, frontend</emphasis>. A frontend
          module mod_example MUST have its classes under the namespace
          <code>Joomla\Module\Example\Site</code>. The namespace you MUST
          declare in the XML manifest is <code>Joomla\Module\Example</code>.
          Even though you are severely restricted in the namespace prefix you
          can use, you MUST provide it in your XML manifest or your module
          won't work! The folder <filename>modules/mod_example/src</filename>
          is the root of the <code>Joomla\Module\Example\Site</code>
          namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Module, backend</emphasis>. A backend
          module mod_example MUST have its classes under the namespace
          <code>Joomla\Module\Example\Administrator</code>. The namespace you
          MUST declare in the XML manifest is
          <code>Joomla\Module\Example</code>. Even though you are severely
          restricted in the namespace prefix you can use, you MUST provide it
          in your XML manifest or your module won't work! The folder
          <filename>administrator/modules/mod_example/src</filename> is the
          root of the <code>Joomla\Module\Example\Administrator</code>
          namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Plugin</emphasis>. The plugin
          <code>plg_system_example</code> MUST have its classes under the
          namespace <code>Joomla\Plugin\System\Example</code>. The namespace
          you MUST declare in the XML manifest is
          <code>Joomla\Plugin\System\Example</code>. Even though you are
          severely restricted in the namespace prefix you can use, you MUST
          provide it in your XML manifest or your plugin won't work! The
          folder <filename>plugins/system/example/src</filename> is the root
          of the <code>Joomla\Plugin\System\Example</code> namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Template</emphasis>. Well, Joomla does
          NOT register a namespace for templates. You are encouraged to use
          namespaces for any template–specific code (you certainly have some
          helpers, don't you?) BUT Joomla won't facilitate you with any
          autoloading. You will have to register your template's namespace
          directly with the <code>JLoader::registerPrefix</code> method. It is
          a good practice putting your namespaced PHP files in the
          <filename>src</filename> directory and use the namespace
          <code>\Joomla\Template\Site\Something</code> for frontend templates
          and <code>\Joomla\Template\Administrator\Something</code> for
          backend templates. Please note that there is no real guidance for
          the template names BUT we can infer what any future change adding
          namespace support to templates will most likely be based on how
          modules are namespaced and Joomla trying to have a modicum of
          consistency.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="concepts-container">
      <title>Dependency Injection Container / Service Locator</title>

      <para>Joomla had historically been quite a mess, architecturally
      speaking. Its saving grace was that it was a far smaller mess than
      WordPress and much more approachable to non–expert coders than Drupal.
      This let it carve a niche for itself: people who wanted a very powerful
      site without having to first acquire a PhD in Computer Science and/or
      have a team of dozens of developers under them. In short, Joomla's
      bad–but–not–too–bad architecture let it be used by small web design
      firms, freelance site integrators and small but serious software
      development firms.</para>

      <para>That said, Joomla 1.x to 3.x inclusive had a <link
      xlink:href="https://en.wikipedia.org/wiki/God_object">God Object</link>
      called the Joomla Factory (<code>JFactory</code> or
      <code>\Joomla\CMS\Factory</code>) with a very opinionated approach on
      instantiating all sorts of globally used services, from the application
      itself, to the database, to the user objects, to the mailer
      object.</para>

      <para>While this is a better approach to using global variables (like
      WordPress' infamous <code>$wpdb</code> for accessing the database), this
      architecture caused a lot of pain when you wanted to write Unit Tests
      for your code. Your code gets user instances? You need to create a mock
      for the entire Factory object returning mock user objects. Your code
      uses the database? You need to create a mock database object and inject
      it to an uninitialised Factory instance using static class variables.
      Your code sends email? Not only you need a mock mailer object, you need
      to mock the Factory too. Want to write tests which mock different things
      in different tests? You can either forget about running your tests as a
      suite OR you need to create an extremely over-reaching and hard to
      configure mock Factory. Your tests must run in a different order? Good
      luck figuring out the bugs in your Factory mock object and why running
      tests in one order works but fails when run in a different order, or on
      their lonesome. Been there, done that, still paying for therapy…</para>

      <para>In Joomla 4 we no longer have a God Object. Well, to be fair, the
      Factory is still there but it is no longer a God Object; it is an
      interface to a <link
      xlink:href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency
      Injection Container</link> (<acronym>DIC</acronym> for short, pronounced
      like Dee Eye See, not the nickname for a Richard, thank you very much).
      So, Factory is still a God Object but with lesser powers. A minor deity
      object, perhaps? In any case, the Container is initialised before
      Factory is used and it can also be replaced. Therefore you only need to
      get a copy of the DIC and replace one or more of its services with a
      mock object when writing Unit Tests. Much easier, much more robust, no
      more therapy necessary after writing Unit Tests.</para>

      <para>The Container is now the preferred way to get access to several
      services previously available only through the Factory (they are still
      available through the Factory in Joomla 4 but will very likely disappear
      in Joomla 5). Let's see a few practical examples:</para>

      <programlisting>use \Joomla\CMS\Factory;

// Instead of Factory::getDbo();
$db = Factory::getContainer()-&gt;get('DatabaseDriver');

// Instead of Factory::getLanguage(); WARNING! STILL DOES NOT WORK EXACTLY AS INTENDED!
$language = Factory::getContainer()-&gt;get(LanguageFactoryInterface::class)-&gt;createLanguage(
  Factory::getApplication()-&gt;get('language'),
  Factory::getApplication()-&gt;get('debug_lang'),
);

// Instead of Factory::getUser($id)
$user = Factory::getContainer()-&gt;get(UserFactoryInterface::class)-&gt;loadUserById($id);

// Instead of Factory::getUser() with no arguments; note that this does NOT go through the DIC!
$currentUser = Factory::getApplication()-&gt;getIdentity();</programlisting>

      <para>That said, Joomla's DIC is not a real DIC; it is in fact a <link
      xlink:href="https://en.wikipedia.org/wiki/Service_locator_pattern">Service
      Locator</link>. That is to say, you don't ask the DIC to construct an
      object and expect it to inject the appropriate dependencies based on the
      class type hints of the constructor's arguments. In theory it can (kind
      of), but in practice this is NOT how the Joomla core API classes are
      written. If you came here expecting a DIC like what you find in Laravel,
      sorry, I have to disappoint you.</para>

      <para>Now, you are thinking, does this not make the DIC kinda useless?
      No, not really. You see, being a Service Locator you get a
      <emphasis>copy</emphasis> of it when your extension is initialised. In
      fact, each native Joomla 4 extension needs to have a Service Provider
      which takes the DIC copy as input and registers services to it. At the
      very least you will be registering your extension service which is used
      by Joomla to instantiate your extension's object and run its code. You
      can also register any number of services you might need, even custom
      ones only to be used by your extension.</para>

      <para>At some point in the future Joomla will MAYBE remove the Factory,
      if not altogether then at least insofar it can only return the main
      application's DIC. In such a future Joomla will VERY PROBABLY make it
      much easier for an extension's internal classes to have access to its
      own DIC / Service Locator instead of only ever making it available to
      the Extension class. In this potential future Joomla extensions will be
      self-contained and perfectly testable. Even better, they can be sure
      that whatever happens in an extension stays in the extension, without
      leaking to the global application scope (and poison other
      extensions).</para>
    </section>

    <section xml:id="concepts-webassetmanager">
      <title>Web Asset Management</title>

      <para>A large part of our work as Joomla extension developers is to load
      static assets, CSS and JavaScript files, in the user-facing HTML output
      of our extensions.</para>

      <para>In older Joomla versions we did that through the HTML document and
      using HTMLHelper static methods to load dependencies. For
      example:</para>

      <programlisting>$doc = \Joomla\CMS\Factory::getApplication()-&gt;getDocument();
Joomla\CMS\HTML\HTMLHelper::_('bootstrap.tooltip', '.hasTooltip');
Joomla\CMS\HTML\HTMLHelper::_('script', 'com_example/something.js', [
	'version'       =&gt; 'auto',
	'relative'      =&gt; true,
	'detectDebug'   =&gt; false,
	'framework'     =&gt; false,
	'pathOnly'      =&gt; false,
	'detectBrowser' =&gt; false,
], [
	'defer' =&gt; true,
	'async' =&gt; false,
]);
</programlisting>

      <para>This has a few shortcomings, as we have all discovered to our
      despair.</para>

      <para>First of all, we need to remember to load all dependencies in the
      correct order before our own CSS or JavaScript file. In the above
      example, the something.js file depends on Bootstrap's Tooltip helper. If
      we forget the first call to HTMLHelper our JavaScript file will be
      broken.</para>

      <para>However, our extension is not the only thing running on the page,
      right? Now, see the second parameter in that first HTMLHelper call? It
      tells Joomla's Bootstrap HTML helper to initialise the Tooltip helper so
      that anything with the class hasTooltip will have a Bootstrap tooltip.
      Since this is a component we are confident that this will always be the
      case. Oh, really? If a plugin ran before us and it also loaded its own
      JavaScript which also depends on Bootstrap's tooltip BUT had no second
      argument (or a different second argument) do you care to guess what our
      code above will do? If you guessed “sod all” you'd be right and a Joomla
      extensions development veteran! So, yup, a third party extension having
      a JavaScript file with the same dependency as ours running before us
      breaks our perfectly working JavaScript. This could even happen within
      the same extension if the aforementioned code appeared in a layout and
      your page just happens to load two layout which both call
      <code>Joomla\CMS\HTML\HTMLHelper::_('bootstrap.tooltip')</code> with a
      different second parameter. Great!</para>

      <para>Beyond that, what happens if our something.js gains another
      dependency and we are loading this file in six different places… but
      missed updating one of them? Why, yes, that sixth page will be broken!
      Even worse, we might only update our code with the additional dependency
      in one place (let's say a layout), another four places not updated work
      because they are loading that changed layout and the sixth and final
      place does not work because it was neither updated nor trying to load
      something else which loads the dependency for us.</para>

      <para>Let's put it this way. If you do manual dependency management you
      will be in a world of pain, sooner rather than later.</para>

      <para>Joomla 4 addresses this problem by introducing the Web Asset
      Manager (WAM). The WAM is responsible for loading our CSS and JavaScript
      files <emphasis>and their dependencies</emphasis>. It can figure out
      simple dependency chains even across multiple extensions and make sure
      that things are loaded in an order that makes sense and will do what we
      wanted it to do.</para>

      <para>For that to work we need two things:</para>

      <orderedlist>
        <listitem>
          <para>Using Joomla's media directory the way it was intended ever
          since its introduction in Joomla 1.5.0, back in 2007.</para>
        </listitem>

        <listitem>
          <para>A <filename>joomla.assets.json</filename> file which describes
          our static assets and their dependencies.</para>
        </listitem>
      </orderedlist>

      <para>On the first point please let me remind you how the media folder
      works. If you have any static assets which must be web accessible they
      <emphasis role="bold">MUST</emphasis> be placed in a subdirectory of the
      <filename>media</filename> folder named after your extension (as Joomla
      names it internally). Don't put them in your extension's directory,
      don't put them in <filename>cache</filename> or <filename>tmp</filename>
      (they are NOT web accessible, they CAN be moved around even outside the
      web root AND their contents can and will be removed anytime).</para>

      <para>You have a component named <code>com_foobar</code>? Put your
      static assets in <filename>media/com_foobar</filename>. You have a
      module named <code>mod_example</code>? Put your static assets in
      <filename>media/mod_example</filename>. You have a plugin named
      <code>example</code> in the <filename>folder</filename> system? Put your
      static assets in <filename>media/plg_system_example</filename>. You have
      a template named <code>beauty</code>? Put your static assets in
      <filename>media/tpl_beauty</filename>. Its subdirectories are
      <filename>css</filename> for CSS files and <filename>js</filename> for
      JavaScript files. It's simple, it's efficient, it's how Joomla is meant
      to work.</para>

      <para>The second point, the <filename>joomla.assets.json</filename>
      file, tells Joomla where to find what, what depends on what else and how
      it all fits together. This file is placed in the extension's media
      subdirectory.</para>

      <para>For example, a component <code>com_example</code> could have a
      <filename>media/com_example/joomla.asset.json</filename> file which
      looks like this:</para>

      <programlisting>{
  "$schema": "https://developer.joomla.org/schemas/json-schema/web_assets.json",
  "name": "com_example",
  "version": "1.0.0",
  "description": "This file contains details of the assets used by the Example component by Acme, Inc.",
  "license": "GPL-2.0-or-later",
  "assets": [
    {
      "name": "com_example.backend",
      "description": "Backend styling.",
      "type": "style",
      "uri": "backend.min.css",
      "dependencies": [
        "com_example.typography"
      ]
    },
    {
      "name": "com_example.typography",
      "description": "Fancy typography.",
      "type": "style",
      "uri": "typography.min.css",
      "dependencies": [
        "fontawesome"
      ]
    },
    {
      "name": "com_example.backend.items",
      "description": "JavaScript for the backend Items page.",
      "type": "script",
      "uri": "backend_items.js",
      "attributes" : {
        "defer": true
      },
      "dependencies": [
        "core"
      ]
    },
    {
      "name": "com_example.backend.items",
      "type": "preset",
      "dependencies": [
        "com_example.backend#style",
        "com_example.backend.items#script"
      ]
    }
  ]
}
</programlisting>

      <para>We declare various named assets. The
      <code>com_example.backend</code> style asset loads the
      <filename>backend.min.css</filename> file. However, that file depends on
      the <code>com_example.typography</code> asset which loads the
      <filename>typography.min.css</filename> file. In its turn, this asset
      depends on the core <code>fontawesome</code> asset which loads the
      FontAwesome icon font in any way Joomla figures out is
      appropriate.</para>

      <para>When we tell Joomla to load the <code>com_example.backend</code>
      style asset it will first load the CSS files for FontAwesome (if our
      backend template has not already loaded it), then our
      <filename>typography.min.css</filename> file and finally our
      <filename>backend.min.css</filename> file. This all happens
      automatically. All we have to do in our extension's template layout code
      is</para>

      <programlisting>$this-&gt;document-&gt;getWebAssetManager()-&gt;useStyle('com_example.backend');</programlisting>

      <para>If at a later point we decide that the backend style needs to
      depends on yet another CSS asset we will add it to its dependencies
      array in the <filename>joomla.asset.json</filename> file <emphasis>and
      we are done</emphasis>. We do not have to touch our view templates. We
      do not have to think about anything else. Joomla will figure it out. No
      more hard to track down bugs!</para>

      <para>You may have noticed that we also declared a script asset called
      <code>com_example.backend.items</code> which loads the file
      <filename>backend_items.js</filename> deferred. Deferred means that we
      tell the browser to load it after it has finished initialising the DOM.
      This means that we do not need to add any special code to execute
      something after the DOM is initialised which saves us a lot of
      frustration and bugs. We use the script resource like this:</para>

      <programlisting>$this-&gt;document-&gt;getWebAssetManager()-&gt;useScript('com_example.backend.items');</programlisting>

      <para>We have told Joomla that our script only depends on
      <code>core</code>, i.e. the Joomla core JavaScript. This is not
      mandatory, but something you will see plenty of times because you'll be
      using <code>Joomla.getOptions</code> in your JavaScript code to retrieve
      settings <link linkend="com-data-to-frontend">passed from the backend to
      the frontend</link>. This is the recommended method instead of setting
      arbitrary JavaScript variables in inline JavaScript code. In fact, using
      inline JavaScript code is discouraged (but not forbidden) in Joomla 4
      and later.</para>

      <para>If at a later point we modify our JavaScript to also depend on
      Bootstrap's Modal dialog helper we will just update its
      dependencies:</para>

      <programlisting>    {
      "name": "com_example.backend.items",
      "description": "JavaScript for the backend Items page.",
      "type": "script",
      "uri": "backend_items.js",
      "attributes" : {
        "defer": true
      },
      "dependencies": [
        "core",
        "bootstrap.modal"
      ]
    }</programlisting>

      <para>That's it! No more hunting down usages of this JavaScript file and
      updating our view template code.</para>

      <para>You can of course tell Joomla to load both CSS and JavaScript
      assets. The simplest way is being descriptive in our view
      template:</para>

      <programlisting>$this-&gt;document-&gt;getWebAssetManager()
  -&gt;useStyle('com_example.backend')
  -&gt;useScript('com_example.backend.items');</programlisting>

      <para>(note that useStyle and useScript return the WAM object which
      means they can be chain–called)</para>

      <para>However, this runs the same risk as loading assets the
      old-fashioned way. What happens if we decide that the Items page needs
      some extra CSS which does not apply to the rest of our component's
      backend? We'd have to edit the template layout file. Enter bugs.</para>

      <para>Instead of being descriptive we can be
      <emphasis>prescriptive</emphasis> using another WAM feature called
      <emphasis role="bold">presets</emphasis>. A preset consists entirely of
      dependencies. We declared it in our JSON file like this:</para>

      <programlisting>    {
      "name": "com_example.backend.items",
      "type": "preset",
      "dependencies": [
        "com_example.backend#style",
        "com_example.backend.items#script"
      ]
    }
</programlisting>

      <para>and we can load it in our view template very easily like
      this:</para>

      <programlisting>$this-&gt;document-&gt;getWebAssetManager()-&gt;usePreset('com_example.backend.items');</programlisting>

      <para>Note that the preset asset's key is the same as our script asset's
      key. Script, style and preset assets are separate collections which
      means we <emphasis>can</emphasis> reuse the same key across them. Joomla
      will not be confused. We tell it which collection to look into by using
      a different WAM method: <code>useScript</code>, <code>useStyle</code> or
      <code>usePreset</code>.</para>

      <para>Now let's see why presets are the bee's knees. Let's say we
      decided that Items also needs some special styling in a separate CSS
      file called <filename>items.min.css</filename>. We will just add this
      asset to our JSON file and update the preset:</para>

      <programlisting>    {
      "name": "com_example.backend.items",
      "description": "Backend styling just for the Items page.",
      "type": "style",
      "uri": "items.min.css",
      "dependencies": [
        "com_example.backend"
      ]
    },
    {
      "name": "com_example.backend.items",
      "type": "preset",
      "dependencies": [
        "com_example.backend#style",
        "com_example.backend.items#style",
        "com_example.backend.items#script"
      ]
    }
</programlisting>

      <para>(You may notice that our <code>com_example.backend.items</code>
      asset depends on <code>com_example.backend</code>. I didn't have to do
      that, but I like to be explicit about dependencies to avoid any stupid
      bugs if I remove any intermediate dependencies in a dependency
      chain.)</para>

      <para>We do NOT have to touch our view template file. Since we are
      telling it to load a preset, changing the preset is enough for Joomla to
      figure out what it needs to do.</para>

      <para>Using the Web Asset Manager correctly can be a massive asset (no
      pun intended!) in your extensions' public frontend. Your view templates
      can load your prescriptive presets. If you decide you want to change
      something you can change the preset. Your clients who have created
      template overrides will NOT need to update their overrides. This means
      far fewer “bug” reports and more time for you to work on your
      code.</para>

      <para>The Web Asset Manager has changed the way I write extensions and
      has solved a lot of my headaches. You can use the WAM on any component
      running on Joomla 4, regardless of whether you are using the “old”
      (Joomla 3) MVC or the “new” (Joomla 4) MVC. In fact, since it is a part
      of the Joomla document object, you can use it in modules, even plugins —
      however, if you are using it in a plugin you MUST tell the WAM to load
      your JSON file since Joomla will not do that by default for
      plugins.</para>

      <para>Finally, the WAM is a much less error–prone method to injecting
      static assets to Joomla. All Joomla document classes have a WAM, even
      when they are not HTML; it just follows that if it's a non–HTML document
      adding an asset through WAM does nothing. Compare that with what happens
      if you try to use the HTMLHelper or the addScript / addStyle document
      methods when your document is not HTML. Yup, these old ways of adding
      static assets cause Joomla to error out. Again, WAM is safe, the methods
      of yesteryear are not. One more reason to migrate your extensions to WAM
      today.</para>
    </section>
  </chapter>

  <chapter xml:id="com">
    <title>Components</title>

    <para>The Joomla component is arguably the most important extension type.
    It's not just the sheer fact that it is an application inside an
    application, letting us create custom experiences otherwise nearly
    impossible with just core code, it is also that Joomla embraces the need
    for this kind of custom experiences and has heavily invested in making
    component development relatively easy. This is in stark contrast with
    WordPress where your experience is far and foremost defined by its core
    code, custom experiences outside custom content types are actively
    discouraged and there is no sensible API for creating an equivalent
    extension type without a lot of reinventing the wheel, bending over
    backwards and judicious application of the Dark Arts.</para>

    <section xml:id="com-mvc">
      <title>The Joomla MVC: an introduction</title>

      <para>Joomla came with a strong legacy of modular architecture in
      version 1.0, when it was a little more than a fork of and improvement
      upon Mambo 4, its predecessor. Joomla 1.5 introduced extension
      developers to the concept of <link
      xlink:href="https://en.wikipedia.org/wiki/Model–view–controller">MVC</link>
      (Model-View-Controller) where each component has defined and logical
      structure, separating business logic from presentation. Joomla 4
      improves upon this legacy, by further polishing the MVC and embracing
      concepts introduced to the PHP developer's arsenal over the last decade
      and a half.</para>

      <para>Before delving into improvements and changes in Joomla 4 I think a
      little Joomla MVC refresher is in order. This is especially useful if
      you are used to the MVC definition from a college Computer Science class
      or have used real MVC in other programming languages or even PHP
      frameworks (e.g. in Laravel the typical Model is Eloquent which works
      completely differently, the View is your Blade files and the Controller
      is more of a collection of middleware rather than a single class — it's
      still MVC but a different dialect in the same way Spanish, Italian and
      French are all Romance languages).</para>

      <para>Joomla follows the MVC model typically called “skinny controller -
      fat model”. This puts most of the business logic into the Model and
      keeps the Controller a relatively nimble affair. Further to that, Joomla
      also uses another class called a Table to abstract our interaction with
      the persistence layer objects (that's a fancy, pretentious way of saying
      “database table”). So, it's really an MVCT approach.</para>

      <para>But what are these Controllers, Models and Views anyway?</para>

      <para>The Controller consists of one or more <emphasis>tasks</emphasis>
      implemented as public methods. Each one of them tells the controller to
      <emphasis>do</emphasis> something. For example display an article,
      publish or unpublish an article, delete an article, log in the user,
      check the Multi-factor Authentication provided by the user, create a
      user data deletion request and so on and so forth. Controllers are
      orchestrators; they know what work needs to be done but they do not do
      it themselves. The Controller handles requests: it reads the user input
      and decides what needs to happen next which is invariably one of two
      things. For simple tasks with no output like publishing an article,
      deleting an article, logging in a user etc it will get the Model, tell
      it what to do and then issue a redirection to a different page, possibly
      setting a (very short!) message to show to the user. Most of the time it
      will need to create a document, e.g. an HTML page, a JSON document, an
      RSS feed etc. In this case it will get the appropriate View, push the
      Model to it and ask it to render itself. It then takes the rendered
      document and echoes it; Joomla will intercept that and decide what to do
      with the document effectively returned by the Controller. If an error
      occurred the Controller will catch it and decide what to do with it:
      swallow it or push it up the stack so that it ends up becoming an error
      page for the user.</para>

      <para><emphasis>Note that unlike the normative Controller of the MVC
      pattern the Joomla component's Controller DOES NOT normally push data to
      the Model. Yes, this is a violation of the separation of concerns.
      However, addressing that would be a massive backwards compatibility
      break which would necessitate the rethinking and rewriting of all Joomla
      components, core and third party. As a result we are unlikely to ever
      see this changing.</emphasis></para>

      <para>The Model is the workhorse of the component. It has the
      <emphasis>business logic</emphasis>, i.e. it knows how to get things
      done. In most cases it is a data–aware model which means that it knows
      how to get stuff from the database, put stuff back to the database and
      perform other auxiliary functions with the database data. It does NOT
      handle any presentation logic, i.e. it will NOT output any HTML. It
      returns raw data whenever it is asked to. Therefore you can use a Model
      in any context: inside the component, in a CLI script, in the API
      application (which only handles and returns JSON data), a Scheduled
      Task, a module, a plugin, even a template (though that would be a bit of
      an architectural violation; I won't judge you harshly if you do that
      because you're on a deadline and/or a shoestring budget).</para>

      <para><emphasis>Note that unlike the normative Model of the MVC pattern
      the Joomla component's Model will seek data from the user session and if
      it's not found there it will try to get it from the request. This makes
      it a pain in the posterior to use outside the frontend, backend and API
      applications, e.g. in a CLI application. Yes, there's a trick to that
      (and probably a section I will have to write at some point): set its
      state manually and it will no longer try to get data from the
      request.</emphasis></para>

      <para>As I said, Joomla also has a Table class which, architecturally
      speaking, is somewhere between a Model and a Persistence Layer. But
      we're not CS majors, we're Joomla extension developers. What we need to
      know is that the Table class is an abstraction which represents exactly
      one record of a database table. Table classes only exist in the backend
      of your component but can be used anywhere. They are used either inside
      a Model or directly on their own.</para>

      <para><emphasis>Tables are used by Models but not when returning
      multiple rows. When you run getItems on a ListModel you get an array of
      stdClass objects. This sounds odd at first but it makes sense; Models
      can join multiple tables and return embellished data in lists. For
      example, you may not just get a user ID but also the user's name and
      email address as separate fields. In most (but not all!) cases you could
      instantiate a Table object and call its bind() method with one of the
      aforementioned stdClass objects as its argument to get a Table object
      representation of your data. Just remember in this case that
      instantiating a Table object is computationally expensive as it needs to
      parse the database table's column definitions. Create an instance of the
      Table object. Then clone it for each row you are processing and bind the
      data to the Table object's clone. When processing a few dozen or more
      rows it can save you hundreds of milliseconds of page load
      time.</emphasis></para>

      <para>Then, we have Views. Now, this is the biggest departure of the
      normative MVC pattern. In Computer Science the View only renders
      information in a suitable way for the user to understand. A Joomla
      component's View is actually part controller and part ViewModel. Which
      means that Joomla's MVC is neither MVC nor MVVM, it's its own thing.
      But, as we said before, we are not CS majors, we are Joomla extension
      developers. So let's see what our View does.</para>

      <para>Our View gets data from the Model. It does a bit of error checking
      to make sure nothing is amiss — if it is, it will show an appropriate
      error state be it the new in Joomla 4 Empty State (guiding the user to
      please create some data when we have nothing to show them) or an error
      page if something has gone so bad we don't know what to do. It is also
      responsible for setting up the page metadata (frontend) or the page's
      Title and Toolbar (backend) which is View–related stuff in the same way
      that making coffee is related to hosting an in-person meeting: not
      really your job but people would be really upset if nobody did
      it.</para>

      <para>In the end, the View renders the information in an appropriate
      format for the user — which is what a View is really supposed to do if
      it wants to be called a View! For HTML pages it calls one or more View
      Template files to render some HTML. For other view types such as JSON,
      Raw, XML, Feed and so on a view template file may be used but it's
      neither necessary nor does it always make sense. If you're returning a
      JSON document or a CSV it makes far more sense to construct it directly
      in your View code and return it than going through an unnecessary
      round-trip through a view template file.</para>

      <para>Finally, we need to talk about the View Template files. These are
      the real View of the MVC pattern: they convert the raw data we got from
      our Model to the HTML which will be displayed to the user. Why not have
      the View return the HTML directly? Well, we <emphasis>could</emphasis>
      but we'd have two problems. First, the View itself is also part
      Controller and part ViewModel therefore we'd have an issue with the
      separation of concerns, mixing business logic with presentation logic
      (bad idea; we are using MVC to avoid this bad practice). Second,
      Joomla's raw, unadulterated power comes from the fact that our end users
      can <emphasis>override</emphasis> View Templates in their sites, thereby
      changing the presentation of our component in ways we can neither think
      of nor support in any meaningful way across our entire user base.</para>

      <para>This is the overview of Joomla's MVC and you'll be happy to know
      that it has not actually changed ever since Joomla 1.5. Some
      implementation details have changed but the core concepts — the good,
      the bad and the ugly parts alike — have remained unchanged in Joomla 4.
      In other words, if you already have a perfectly serviceable component
      written for Joomla 3 you <emphasis>can</emphasis> migrate it to Joomla
      4. It's not a different language (like Italian to Spanish), it's a
      different <emphasis>dialect</emphasis>. Yes, you'll need to learn the
      vernacular of the new dialect but it's much, much easier than learning a
      new language. I am saying that as someone who had to learn three foreign
      (human) languages and more programming languages than I care to
      list.</para>
    </section>

    <section xml:id="com-j3-vs-j4-mvc">
      <title>Joomla 3 MVC vs Joomla 4 MVC</title>

      <para>As we already said, the basic functionality of Joomla's MVC has
      remained the same throughout Joomla 3 and 4. If you know how to make a
      Joomla 3 component you know most of what you need to make a Joomla 4
      component. The differences are a few minor, but salient, points.</para>

      <para><link linkend="com-namespaces"><emphasis
      role="bold">Namespaces</emphasis></link>. All native Joomla 4 component
      use <link
      xlink:href="https://www.php.net/manual/en/language.namespaces.php">PHP
      namespaces</link> for their PHP code. This is a very simple change in
      thinking for models, views and controllers. For example, instead of your
      frontend model being called <code>ExampleModelItem</code> it will now be
      the class <code>ItemModel</code> in the namespace <modifier><replaceable>\My\Prefix</replaceable>\Site\Model</modifier>
      where <code>\My\Prefix</code> is something you can define, and has no
      restrictions other than it needs to be a valid PHP namespace, unique to
      your component and should not start with <code>\Joomla</code> (component
      namespaces starting withIn <code>\Joomla</code> are reserved for core
      components). This also applies to custom form fields you may need to
      create in your component — and there <emphasis>is</emphasis> a way to
      tell Joomla which namespace to look custom form fields in with new
      attributes in XML forms.</para>

      <para><link linkend="com-services"><emphasis role="bold">Service
      provider</emphasis></link>. All Joomla components are passed a
      Dependency Injection Container (DIC) which is, in fact, a Service
      Locator. This even applies to components written with the Joomla 3 MVC
      as we'll see in <link linkend="com-lifetime">the lifetime of a
      component</link>. You can register services specific to your component
      in your service locator. At the very least, Joomla expects you to set up
      the <link linkend="com-extension">extension class</link> of your
      component. Unfortunately, even simple components need to have a service
      provider as there is no convention–over–configuration in Joomla 4's
      component DIC.</para>

      <para><link linkend="com-extension"><emphasis role="bold">Extension
      class</emphasis></link>. The extension class
      <emphasis>replaces</emphasis> the entry point file (e.g.
      <filename>administrator/components/com_example/example.php</filename>)
      you had in Joomla 3 MVC. All components written with the Joomla 4 MVC
      have an extension class which extends from
      <code>Joomla\CMS\Extension\MVCComponent</code>. It is used to register
      special services used when working with your component such as the
      <code>MVCFactory</code> service (responsible for creating model, view
      and controller object instances), an <link linkend="com-html">HTML
      helper service</link> which extends Joomla's HTMLHelper, a <link
      linkend="com-router">Router service</link> for frontend search engine
      friendly (SEF) URL routing, and a <link
      linkend="com-categories">Category service</link> if your component uses
      core Categories. It also returns your component's <link
      linkend="com-dispatcher">Dispatcher</link> which is where the execution
      of your component starts. For very simple components you can even use
      the core MVCComponent class as your extension class, without
      sub–classing. See, for example, what the core
      <code>com_actionlogs</code> component does.</para>

      <para><emphasis role="bold"><link
      linkend="com-dispatcher">Dispatcher</link> instead of a front
      controller</emphasis>. In the Joomla 3 MVC paradigm you had a
      <filename>controller.php</filename> file in the root of your component's
      directory structure. This was a front-controller, supposed to figure out
      which controller to use to handle the specified view and task in the
      request. This was a bit gimmicky and error–prone, especially if you had
      components capable of displaying more than one discrete types of
      information, e.g. a downloads repository would be able to display
      categories, releases in a category and files in a release which made for
      three discrete content types which had to be handled by the same front
      controller. The new Dispatcher does the same job, it works without
      sub–classing it for most simple extensions and benefits greatly the more
      complex extensions which need more involved request processing.</para>

      <para><emphasis role="bold"><link linkend="com-html">HTML helper</link>
      is a service</emphasis>. If you had ever registered an HTMLHelper class
      with static calls this is no longer the recommended method. If you need
      an HTML helper for your extension you need to register it through the
      extension class and its methods are no longer static. Since it's a real
      object instantiated by the extension object it has access to the
      component's DIC, therefore to any service you registered in your service
      provider or you were given by Joomla in the DIC. This makes helpers
      testable and means that they can access custom services (e.g. a shipping
      cost calculation service if you are writing an e-commerce component)
      without trying to contort your code.</para>

      <para><emphasis role="bold">New format for </emphasis><link
      linkend="com-router"><emphasis role="bold">Router</emphasis></link>.
      Joomla 4 comes with a new Router which is instantiated through a
      service. The new component router superclass allows you to write
      efficient routers without a lot of boilerplate, duplicated and
      convoluted code.</para>
    </section>

    <section xml:id="com-lifetime">
      <title>The lifetime of a component</title>

      <para>In the previous section we talked about the new concepts in the
      Joomla 4 MVC but it's really hard to understand how they all work
      together. It's best if we talk about the lifetime of a component, i.e.
      what happens when you try to access a Joomla URL in the form
      <uri>index.php?option=com_example&amp;view=foo</uri>.</para>

      <para>The lifetime of our component starts in the application object
      (<code>SiteApplication</code>, <code>AdministratorApplication</code> or
      <code>ApiApplication</code>), namely its <code>dispatch()</code> method.
      All these methods do some initialisation and call
      <code>Joomla\CMS\Component::renderComponent()</code>. This method runs
      this line where things get interesting for our component:</para>

      <programlisting>$app-&gt;bootComponent($option)-&gt;getDispatcher($app)-&gt;dispatch();</programlisting>

      <para>Let's rewrite it so it's more readable:</para>

      <para><programlisting>$componentExtension = $app-&gt;bootComponent($option)
$componentDispatcher = $componentExtension-&gt;getDispatcher($app)
$componentDispatcher-&gt;dispatch();</programlisting>What Joomla does is ask
      the application object to <emphasis>somehow</emphasis> get a component
      extension object — even if it is a legacy component using the Joomla 3
      MVC. Then it asks the component extension object to get it the
      component's Dispatcher object. Finally, it tells the component's
      Dispatcher to dispatch (execute) the component.</para>

      <para>These three steps are crucial to understanding the difference
      between legacy Joomla 3 MVC components, modern Joomla 4 MVC components
      and how Joomla 4 makes them all work.</para>

      <section xml:id="com-lifetime-booting">
        <title>Booting the component</title>

        <para>The <code>bootComponent</code> method is implemented by
        <code>Joomla\CMS\Extension\ExtensionManagerTrait</code>. The first
        thing it does, by calling its <code>loadExtension</code> method, is to
        figure out if this is a Joomla 4 MVC or Joomla 3 MVC component. It
        does that by looking for the
        <filename>services/provider.php</filename> file under the component's
        root. As you may have guessed this is our component's <link
        linkend="com-services">service provider</link> and the reason why all
        Joomla 4 MVC components, even the simplest ones for which we could
        infer their service provider, really do need to have a service
        provider file.</para>

        <para>If the file exists it's loaded and its services are registered
        into the copy of the Joomla DIC which is used as our component's
        DIC.</para>

        <note>
          <para>This means that our component only sees a frozen in time copy
          of the global application services. You cannot register any services
          in the component's DIC and expect them to be available in the global
          application.</para>
        </note>

        <para>If the file does not exist, Joomla creates an instance of the
        <code>Joomla\CMS\Extension\LegacyComponent</code>. As you can see,
        this extension object uses a legacy MVC factory object which "speaks"
        the Joomla 3 non-namespaced MVC class names and a legacy component
        dispatcher which looks for the <filename>componentName.php</filename>
        (in our example: <filename>example.php</filename>) component entry
        point file and loads it. This is exactly how Joomla 4 can render
        components using Joomla 3 MVC.</para>

        <para>The rest of this section will talk about a Joomla 4 MVC
        component.</para>

        <para>Finally, Joomla returns <link linkend="com-extension">the
        component's extension object</link> as the result of the
        <code>bootComponent</code> method.</para>

        <tip>
          <para>You can call
          <code>\Joomla\CMS\Factory::getApplication()-&gt;bootComponent('com_example')</code>
          to get the <code>com_example</code> component's extension object
          anytime, anywhere — <emphasis role="bold">including in modules and
          plugins</emphasis>. If you subclass the
          <code>Joomla\CMS\Extension\MVCExtension</code> class in your own
          component you can create your own methods to return <emphasis>ANY
          OBJECT KNOWN TO THE COMPONENT AND ITS CONTAINER</emphasis>.</para>

          <para>This is of enormous importance.</para>

          <para>You can instantiate any MVC class of the component. You have
          access to your HTML helper, categories service and router service.
          You can get an instance of any of the custom services you created in
          your component. All of that WITHOUT any static helpers in your
          extension, WITHOUT worrying that something might break if you call
          your code outside your component. Your Models can provide a public
          API for third party developers communicating with your
          component.</para>

          <para>Joomla core components already do that. For example, you can
          get the backend <code>ArticleModel</code> of
          <code>com_content</code> in a frontend component or plugin to create
          a new Joomla article <emphasis>the right way</emphasis>:</para>

          <programlisting>$articleModel = \Joomla\CMS\Factory::getApplication()
  -&gt;bootComponent('com_content')
  -&gt;getMVCFactory()
  -&gt;createModel('Article', 'Administrator');</programlisting>
        </tip>
      </section>

      <section xml:id="com-lifetime-dispatcher">
        <title>Getting the Dispatcher</title>

        <para>The extension object is responsible for returning a number of
        interesting objects through its methods. These objects are meant to be
        used for interacting with the component. One of these is
        <code>getDispatcher</code> which lets us retrieve the component's
        <link linkend="com-dispatcher">Dispatcher</link> object.</para>

        <para>Your extension can have a custom dispatcher class,
        <code>\My\Prefix\Dispatcher\Dispatcher</code>, where
        <code>\My\Prefix</code> is your component's prefix. If this class
        exists, an object instance of it is returned.</para>

        <para>If your extension does not have a dispatcher an instance of the
        default <code>Joomla\CMS\Dispatcher\ComponentDispatcher</code> (site
        and administrator applications) or
        <code>Joomla\CMS\Dispatcher\ApiDispatcher</code> (API application)
        will be created and returned instead.</para>
      </section>

      <section xml:id="com-lifetime-dispatching">
        <title>Dispatching the component</title>

        <para>The dispatcher object has a <code>dispatch()</code> method. This
        method looks in the request data to figure out which controller it
        needs to instantiate and which task it should execute on it. The
        controller object is instantiated through your component's
        <code>MVCFactory</code> service and its <code>execute</code> and
        <code>redirect</code> methods are called on it. So, yes, this is
        basically what your old Joomla 3 MVC
        <filename>controller.php</filename> file was doing.</para>

        <tip>
          <para>Having a custom dispatcher means that you can manipulate the
          <emphasis>controller and task</emphasis> based on other request
          variables.</para>

          <para>This is very important when your component is accessed
          <emphasis>outside of a Joomla menu item (no Itemid in the request
          variables)</emphasis>. In this case Joomla always uses the default
          (Home) menu item for the current language. This means that you may
          be getting a <uri>controller</uri>, <uri>view</uri> or
          <uri>task</uri> request variable — as well as other variables which
          might mess with your component, like <uri>id</uri> — from the Home
          menu item.</para>

          <para>Your Dispatcher is responsible for figuring out if this is the
          case and fix the input variables to prevent weird bugs / showing the
          wrong page of your component when it's accessed without a menu item
          id, e.g. a URL like <uri>/component/example?view=foobar</uri>. This
          is something which has happened a lot when I converted my own
          extensions to Joomla 4, including LoginGuard (the extension
          contributed as Joomla's Multi-factor Authentication feature in
          Joomla 4.2).</para>
        </tip>
      </section>
    </section>

    <section xml:id="com-dirs">
      <title>Directory structure</title>

      <para>The directory structure of a typical Joomla 4 MVC component is as
      follows, assuming it's called <code>com_example</code> and has the
      namespace prefix <code>\Acme\Example</code>. Directories are suffixed
      with <filename>/</filename>. Please note that capitalisation matters
      (directory and file names are case–sensitive).</para>

      <itemizedlist>
        <listitem>
          <para><filename>administrator/components/com_example/</filename> The
          component's backend directory</para>

          <itemizedlist>
            <listitem>
              <para><filename>forms/</filename> Optional. List view forms and
              search tools forms (formerly in models/forms)</para>

              <itemizedlist>
                <listitem>
                  <para><filename>items.xml</filename> An example form for the
                  Items list view.</para>
                </listitem>

                <listitem>
                  <para><filename>filter_items.xml</filename> An example
                  search tools form for the Items list view.</para>
                </listitem>

                <listitem>
                  <para><filename>item.xml</filename> An example form for the
                  Item edit view.</para>
                </listitem>

                <listitem>
                  <para>…</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>language/</filename> Not required but you should
              always somehow provide language files with your extension. The
              language files of your component (typically installed in
              <filename>administrator/languages/en-GB</filename>)</para>

              <itemizedlist>
                <listitem>
                  <para><filename>en-GB/</filename> The English (Great
                  Britain) language files. That's the default Joomla
                  language.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>com_example.ini</filename> The main
                      language file for your component's views. Note that
                      there is no longer an <filename>en-GB.</filename>
                      prefix; it's implied by the directory the language file
                      is in.</para>
                    </listitem>

                    <listitem>
                      <para><filename>com_example.sys.ini</filename> The
                      language file used by Joomla to display backend menu
                      items, permissions, the component's Options page, core
                      categories used by your component, select menu item
                      types in the menu manager, and render each menu item
                      type's configuration parameters.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>layouts/</filename> Optional. Any Joomla Layouts
              you want to ship with your extension for use in its
              backend.</para>
            </listitem>

            <listitem>
              <para><filename>services/</filename> Required. Here lives the
              <link linkend="com-services">Service Provider</link> of your
              component.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>provider.php</filename> The service provider
                  file.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>sql/</filename> Optional, unless your extension
              makes changes to database structure or content.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>updates/</filename> Required. Your
                  component's schema (database) files applied on each
                  update.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>mysql/</filename> Optional. Indicates
                      updates for sites running on the MySQL database.</para>

                      <itemizedlist>
                        <listitem>
                          <para><filename>1.0.0-20220815-0000.sql</filename> A
                          database update file. You should name them
                          <filename>version-date-time.sql</filename>. The
                          version part is mandatory.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>install.mysql.utf8.sql</filename> The SQL
                  executed on your component's first installation. Update
                  files are not executed in this case.</para>
                </listitem>

                <listitem>
                  <para><filename>uninstall.mysql.utf8.sql</filename> The SQL
                  executed on your component's uninstallation. Remove any
                  tables or database data you created.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>src/ Required. The root of your extension's PHP files and
              the root of the PSR-4 <code>\Acme\Example\Administrator</code>
              namespace prefix.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>Controller/</filename> Required. Your
                  component's controllers</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ItemsController.php</filename> An
                      example controller for a ListView</para>
                    </listitem>

                    <listitem>
                      <para><filename>ItemController.php</filename> An example
                      controller for an AdminView</para>
                    </listitem>

                    <listitem>
                      <para>…</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Dispatcher/</filename> Optional. Holds your
                  custom component dispatcher.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Dispatcher.php</filename> Your custom
                      component dispatcher.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Extension/</filename> Optional. Holds your
                  custom extension class.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ExampleExtension.php</filename> Your
                      custom extension class.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Field/</filename> Optional. Custom form
                  fields. Use them in your XML forms using the attribute
                  <code>addfieldprefix="Acme\Example\Administrator\Field"</code>.</para>
                </listitem>

                <listitem>
                  <para><filename>Model/</filename> Required. Your component's
                  Models.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ItemsModel.php</filename> An example
                      model for the Items list view.</para>
                    </listitem>

                    <listitem>
                      <para><filename>ItemModel.php</filename> An example
                      model for the Item view. Handles editing and adding
                      records.</para>
                    </listitem>

                    <listitem>
                      <para>…</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Provider/</filename> Optional. Custom
                  service providers.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>RouterFactory.php</filename> Example of
                      a RouterFactory provider, if you need a frontend SEF URL
                      router.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Router/</filename> Optional. The recommended
                  place to put your custom RouterFactory, if you need a
                  frontend SEF URL router.</para>
                </listitem>

                <listitem>
                  <para><filename>Service/</filename> Optional. Custom
                  services.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Html/</filename> Optional. Where your
                      custom HTML services (which are made available through
                      Joomla's HTMLHelper) live.</para>

                      <itemizedlist>
                        <listitem>
                          <para><filename>Example.php</filename> An example
                          HTML service.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Table/</filename> Required. Your Table
                  classes.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ItemTable.php</filename> An example
                      table class for the items of this component (which
                      should ideally live in the
                      <database>#__example_items</database> table if you want
                      to follow Joomla best practices).</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>View/</filename> Required. Your view
                  classes. All subdirectories must be in Uppercasefirst format
                  and match the controller's name before the
                  <code>Controller</code> word.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Items/</filename> The directory for the
                      Items list view.</para>

                      <itemizedlist>
                        <listitem>
                          <para><filename>HtmlView.php</filename> The HTML
                          view class for rendering this backend view.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>

                    <listitem>
                      <para><filename>Item/</filename> The directory for the
                      Item add/edit view.</para>

                      <itemizedlist>
                        <listitem>
                          <para><filename>HtmlView.php</filename> The HTML
                          view class for rendering this backend view.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>tmpl/</filename> Required. The view templates
              for your backend views.</para>

              <important>
                <para>All the sub–directories are in <emphasis role="bold">all
                lowercase</emphasis>. This is VERY important!</para>

                <para>Be careful if you are developing on Windows or macOS
                (which use case–insensitive filesystems). You might
                accidentally use MixedCase or Uppercasefirst folder names.
                While this will work fine on Windows and macOS it will
                <emphasis>fail</emphasis> on the Linux servers most sites run
                on. That's because Linux primarily uses case-sensitive
                filesystems.</para>
              </important>

              <itemizedlist>
                <listitem>
                  <para><filename>items/</filename></para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>default.php</filename> The view template
                      for the Items view.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>item/</filename></para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>edit.php</filename> The view template
                      for the Item view.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>access.xml</filename> The component's
              permissions configuration file</para>
            </listitem>

            <listitem>
              <para><filename>config.xml</filename> The component;s Options
              page form file</para>
            </listitem>

            <listitem>
              <para><filename>example.xml</filename> The component's XML
              manifest</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><filename>components/com_example/</filename> The component's
          frontend directory</para>

          <itemizedlist>
            <listitem>
              <para><filename>forms/</filename> Optional. Any forms for
              frontend views (formerly in models/forms).</para>
            </listitem>

            <listitem>
              <para><filename>language/</filename> Not required but you should
              always somehow provide language files with your extension. The
              language files of your component (typically installed in
              <filename>languages/en-GB</filename>)</para>

              <itemizedlist>
                <listitem>
                  <para><filename>en-GB/</filename> The English (Great
                  Britain) language files. That's the default Joomla
                  language.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>com_example.ini</filename> The main
                      language file for your component's frontend
                      views.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>layouts/</filename> Optional. Any Joomla Layouts
              you want to ship with your extension for use in its
              frontend.</para>
            </listitem>

            <listitem>
              <para>src/ Required. The root of your extension's PHP files and
              the root of the PSR-4 <code>\Acme\Example\Site</code> namespace
              prefix.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>Controller/</filename> Required. Your
                  component's controllers</para>
                </listitem>

                <listitem>
                  <para><filename>Dispatcher/</filename> Optional. Holds your
                  custom component dispatcher for the frontend only.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Dispatcher.php</filename> Your custom
                      component frontend dispatcher.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Model/</filename> Required. Your component's
                  Models.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ItemsModel.php</filename> An example
                      model for the Items list view.</para>
                    </listitem>

                    <listitem>
                      <para><filename>ItemModel.php</filename> An example
                      model for the Item view. Handles editing and adding
                      records.</para>
                    </listitem>

                    <listitem>
                      <para>…</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Service/</filename> Optional. Custom
                  services.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Category.php</filename> Optional. Your
                      site's category service.</para>
                    </listitem>

                    <listitem>
                      <para><filename>Router.php</filename> Optional. Your
                      site's SEF router.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>View/</filename> Required. Your frontend
                  view classes. All subdirectories must be in Uppercasefirst
                  format and match the controller's name before the
                  <code>Controller</code> word.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>tmpl/</filename> Required. The view templates
              for your backend views. All the sub–directories are in <emphasis
              role="bold">all lowercase</emphasis>.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><filename>api/components/com_example/</filename> Optional.
          Your Joomla API application integration. Just having this directory
          is not enough, you will also need a published plugin for your
          application in the <filename>webservices</filename> folder.</para>

          <itemizedlist>
            <listitem>
              <para>src/ Required. The root of your extension's PHP files and
              the root of the PSR-4 <code>\Acme\Example\Api</code> namespace
              prefix.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>Controller/</filename> Required. Your
                  component's controllers</para>
                </listitem>

                <listitem>
                  <para><filename>View/</filename> Required. Your API view
                  classes. All subdirectories must be in Uppercasefirst format
                  and match the controller's name before the
                  <code>Controller</code> word. Note that these views DO NOT
                  use view template files; they return JSON data
                  directly.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><filename>media/com_example/</filename> Optional. Your
          component's static assets.</para>

          <itemizedlist>
            <listitem>
              <para><filename>css/</filename> Optional. Custom CSS files for
              your component.</para>
            </listitem>

            <listitem>
              <para><filename>js/</filename> Optional. Custom JavaScript files
              for your component.</para>
            </listitem>

            <listitem>
              <para><filename>joomla.asset.json</filename> The <link
              linkend="concepts-webassetmanager">WebAssetManager configuration
              file</link> for your static assets.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="com-services">
      <title>Service provider</title>

      <para>As discussed in the previous section, the service provider file is
      mandatory for Joomla 4 MVC components and lives in the component's
      <filename>services</filename> folder and always named
      <filename>provider.php</filename>.</para>

      <para>The absolutely minimal minimal service provider file looks like
      the following:</para>

      <programlisting>&lt;?php
defined('_JEXEC') || die;

use Acme\Example\Administrator\Extension\ExampleComponent;
use Joomla\CMS\Dispatcher\ComponentDispatcherFactoryInterface;
use Joomla\CMS\Extension\ComponentInterface;
use Joomla\CMS\Extension\Service\Provider\MVCFactory;
use Joomla\CMS\MVC\Factory\MVCFactoryInterface;
use Joomla\DI\Container;
use Joomla\DI\ServiceProviderInterface;

return new class implements ServiceProviderInterface {
	public function register(Container $container)
	{
		// PART 1: Register service providers to the component's container
		$container-&gt;registerServiceProvider(new MVCFactory('Acme\\Example'));

		// PART 2: Instantiate and set up your extension object
		$container-&gt;set(
			ComponentInterface::class,
			function (Container $container) {
				/**
				 * PART 2.a: Instantiate the extension object
				 *
				 * If you do not have a custom extension class use \Joomla\CMS\Extension\MVCComponent instead.
				 */
				$component = new \Acme\Example\Administrator\Extension\ExampleComponent(
					$container-&gt;get(ComponentDispatcherFactoryInterface::class)
				);

				// PART 2.b: Set up the extension object
				$component-&gt;setMVCFactory($container-&gt;get(MVCFactoryInterface::class));

				// PART 2.c: return the extension object
				return $component;
			}
		);
	}
};
</programlisting>

      <para>As you can see the service provider returns an <link
      xlink:href="https://www.php.net/manual/en/language.oop5.anonymous.php">anonymous
      PHP class</link> which implements the
      <code>Joomla\DI\ServiceProviderInterface</code>. That's the standard way
      to extend Joomla's DIC. Remember, as we learned in <link
      linkend="com-lifetime">the lifetime of a component</link>, Joomla
      creates a <emphasis>copy</emphasis> of its DIC and uses it as our
      component's own DIC. The service providers we set up in our component
      stay with our component, they do not leak out to the global application
      scope (the global Joomla DIC you get through the
      <code>Joomla\CMS\Factory::getContainer()</code> static method).</para>

      <para>Part 1 of that file lets us register service providers to our
      component's DIC. At the bare minimum we need to register a
      <code>Joomla\CMS\Extension\Service\Provider\MVCFactory</code> provider.
      This returns an object implementing
      <code>Joomla\CMS\MVC\Factory\MVCFactoryInterface</code> which is used by
      our component's code (and Joomla's core code) to get the MVC objects of
      our component (Controllers, Models, Views, Tables). If we want to use
      more core Joomla features with out component we may have to register
      more service providers as we'll see in the <link
      linkend="com-extension">Extension class</link> section and the rest of
      the sections of this chapter.</para>

      <para>Part 2 sets up a service provider returning an object implementing
      the <code>Joomla\CMS\Extension\ComponentInterface</code>, i.e. our
      component's extension object.</para>

      <para>Part 2.a is where we create an instance of our <link
      linkend="com-extension">extension class</link>. If you have a dead
      simple component which does not use a custom extension class you can use
      Joomla's built-in <code>\Joomla\CMS\Extension\MVCComponent</code> class
      instead. Most components will need a custom extension class so we
      instantiate it here.</para>

      <para>Part 2.b is where we set up the extension object we created in
      Part 2.a. Remember when I told you that <link
      linkend="concepts-container">Joomla's DIC is not really a Dependency
      Injection Container</link> but more of a Service Locator? Because of
      that fact, when we create the extension object it does not know of any
      service objects it needs to use. Therefore we have to push them
      manually.</para>

      <para><emphasis>Sidebar: In my opinion, the three biggest shortcomings
      of the Joomla 4 MVC are the lack of convention over configuration, the
      lack of abstracted configuration and the lack of a real Dependency
      Injection container. These three shortcomings are, respectively, why we
      need to have a service provider file, why we need Part 1 and Part 2.b
      and why we need Part 2.a. Most other PHP frameworks have already solved
      these shortcomings. This means that any complaints that Joomla is moving
      to a very abstracted approach just to compete with other PHP frameworks
      are entirely unfounded; Joomla's architecture is still a good 10 or so
      years behind the PHP state of the art. This is not a bad thing! Too much
      abstraction may be a good thing for experienced, hardcore developers
      like yours truly but not necessarily the easiest thing to get your head
      around if you're a newcomer to Joomla or PHP in
      general.</emphasis></para>

      <para>Finally, we have Part 3 where we return the configured extension
      object, necessary for our custom service provider to <emphasis>actually
      work</emphasis>.</para>

      <warning>
        <para>You may be tempted to think that the service provider is only
        ever called when Joomla is about to render your component. <emphasis
        role="bold">This is not the case</emphasis>. Joomla will load a
        component's service provider any time it needs to interact with any of
        its services including the Router, or because another extension (such
        as a plugin, or module) wants to get access to your component's Models
        or some other service or object.</para>

        <para>Just because your service provider's code is running DOES NOT
        mean you are about to render an HTML page with your component, it DOES
        NOT mean that you necessarily have access to the JPATH_COMPONENT and
        JPATH_COMPONENT_ADMINISTRATOR constants and absolutely DOES NOT mean
        that you should ever, <emphasis>ever</emphasis>, try to push CSS,
        JavaScript or run any other code which assumes that Joomla is in an
        HTML output state.</para>

        <para>If you have such code (which is generally a bad idea) you should
        run it in your component's <link
        linkend="com-dispatcher">Dispatcher</link> and only after checking
        that you are indeed running in an HTML application (check the type of
        the object returned from calling
        <code>\Joomla\CMS\Factory::getApplication()-&gt;getDocument()</code>).</para>
      </warning>
    </section>

    <section xml:id="com-extension">
      <title>Extension class</title>

      <para>As we saw earlier in <link linkend="com-lifetime">the lifetime of
      a component</link>, the Extension class of a component is <emphasis>sort
      of</emphasis> a service locator for our component. Joomla checks if that
      objects implements a PHP Interface it knows about and uses the service
      communicated via the Interface implementation (typically one of the
      corresponding PHP Traits provided by Joomla) to do something useful,
      e.g. register an HTMLHelper helper, integrate with Tags, create SEF URLs
      by using a Router and so on and so forth.</para>

      <para>If your component does not make use of any of these features you
      do not need to create a custom extension class for your component.
      Joomla gives you the perfectly serviceable
      <code>Joomla\CMS\Extension\MVCComponent</code> class which implements a
      minimal Joomla 4 component: it can run because it returns a Dispatcher
      and it can create MVC objects using the Joomla 4 MVC because it returns
      an MVCFactory object. This is enough for a component which only runs in
      the backend or runs in both the frontend and the backend but has no way
      of letting Joomla create SEF URLs for it. You may think this is useless
      but I'd contest you're not thinking simple enough. Case in point, some
      core Joomla components doing exactly that. For example the
      <code>com_actionlogs</code> component which only has a backend user
      interface.</para>

      <para>That said, there wouldn't be much to write if all or even most
      components didn't need a custom extension class. You see, most
      components need one or more of the following features. I am documenting
      the features I discovered that need customisations in the extension
      class and give you an overview of the required changes in your
      component's code to make them work.</para>

      <itemizedlist>
        <listitem>
          <para>Use a custom <link linkend="com-html">HTML
          Helper</link>.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\HTML\HTMLRegistryAwareTrait</code> and use the
          <code>Joomla\CMS\HTML\HTMLRegistryAwareTrait</code>. The extension
          class must override the <code>boot</code> method and have a line
          similar to <code>$this-&gt;getRegistry()-&gt;register('something',
          new MyHTMLHelper())</code>. We'll see what that means in the section
          covering the HTML helper.</para>
        </listitem>

        <listitem>
          <para>Use <link linkend="com-categories">core
          categories</link>.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\Categories\CategoryServiceInterface</code> and use
          the <code>Joomla\CMS\Categories\CategoryServiceTrait</code>. Your
          service provider (<filename>provider.php</filename>) needs to
          register a
          <code>Joomla\CMS\Extension\Service\Provider\CategoryFactory</code>
          service provider and use the extension object's
          <code>setCategoryFactory</code> method to pass this factory to the
          extension object. The extension class must override the
          <code>getTableNameForSection</code> and
          <code>getStateColumnForSection</code> methods defined in the
          aforementioned trait and interface.</para>
        </listitem>

        <listitem>
          <para>Integrate with Joomla's Tags feature.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\Tag\TagServiceInterface</code> and use the
          <code>Joomla\CMS\Tag\TagServiceTrait</code>. The extension class
          must override the <code>getTableNameForSection</code> and
          <code>getStateColumnForSection</code> methods defined in the
          aforementioned trait and interface.</para>
        </listitem>

        <listitem>
          <para>Integrate with <link linkend="com-fields">Joomla's Custom
          Fields feature</link>.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\Fields\FieldsServiceInterface</code>. The extension
          class must implement the <code>validateSection</code> and
          <code>getContext</code> methods defined in the aforementioned
          interface.</para>
        </listitem>

        <listitem>
          <para>Provide a <link linkend="com-router">Router</link> for
          meaningful, human-readable SEF URLs in the frontend.</para>

          <para>Your component must have a class implementing the
          <code>Joomla\CMS\Component\Router\RouterFactoryInterface</code>
          (Router factory) and a class implementing the
          <code>Joomla\DI\ServiceProviderInterface</code> (Router factory
          provider). Your extension class must implement the
          <code>Joomla\CMS\Component\Router\RouterServiceInterface</code> and
          use the <code>Joomla\CMS\Component\Router\RouterServiceTrait</code>.
          Your service provider (<filename>provider.php</filename>) needs to
          register your Router factory provider and use the extension object's
          <code>setRouterFactory</code> method to pass the resulting Router
          factory to the extension object.</para>
        </listitem>

        <listitem>
          <para>Let Joomla associate items between languages on multi–language
          sites.</para>

          <para>Your component must have a class extending the
          <code>Joomla\CMS\Association\AssociationExtensionHelper</code>. Your
          service provider (<filename>provider.php</filename>) must register
          this class with the
          <code>Joomla\CMS\Association\AssociationExtensionInterface::class</code>
          key and use the extension object's
          <code>setAssociationExtension</code> method to assign the object
          resulting from that service to the extension object. Your extension
          object needs to implement the
          <code>Joomla\CMS\Association\AssociationServiceInterface</code> and
          use the
          <code>Joomla\CMS\Association\AssociationServiceTrait</code>.</para>
        </listitem>

        <listitem>
          <para>Integrate with Joomla's Workflows feature.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\Workflow\WorkflowServiceInterface</code> and use
          the <code>Joomla\CMS\Workflow\WorkflowServiceTrait</code>. The
          extension class must override the <code>getModelName</code>,
          <code>filterTransitions</code>,
          <code>getWorkflowTableBySection</code>,
          <code>getWorkflowContexts</code> and
          <code>getCategoryWorkflowContext</code> methods defined in the
          aforementioned trait and interface.</para>
        </listitem>
      </itemizedlist>

      <para>As you can see, trying to do pretty much anything useful does
      require a custom extension class.</para>

      <section xml:id="com-extension-naming">
        <title>Naming your extension class</title>

        <para>There are no hard rules for naming your component's extension
        class. That said, to help anyone reading your code — including
        yourself six or so months later — retain a modicum of their sanity it
        is advisable to use the convention
        <code><replaceable>\My\Prefix</replaceable>\Administrator\Extension\<replaceable>Name</replaceable>Component</code>
        where \My\Prefix is the namespace prefix of your component and
        <code>Name</code> is the name of your component without the
        <code>com_</code> prefix.</para>

        <para>For example, if you have a component named
        <code>com_example</code> with the namespace prefix
        <code>\Acme\Example</code> your extension class should be
        <code>\Acme\Example\Administrator\Extension\ExampleComponent</code>
        and placed in the file
        <filename>administrator/components/com_example/src/Extension/ExampleComponent.php</filename>.</para>
      </section>

      <section xml:id="com-extension-provider">
        <title>Using your extension class in the service provider</title>

        <para>As you remember from the service provider section, in Part 2.a
        you need to instantiate the extension class. These lines would look
        like this:</para>

        <programlisting>$component = new \Acme\Example\Administrator\Extension\ExampleComponent(
	$container-&gt;get(ComponentDispatcherFactoryInterface::class)
);</programlisting>

        <para>Simple, isn't it?</para>
      </section>

      <section xml:id="com-extension-outside-com">
        <title>Using your extension class from outside the component</title>

        <para>Now we are finally able to answer the question which you had in
        mind coming to this section: why in the name of Cthulu do I have to
        have an extension class and what does it accomplish beyond adding yet
        another layer of complexity to my extension writing problems?</para>

        <para>For that, let's consider this. Let's say we have a news site and
        we are building a system plugin which checks every day for newly
        published articles, auto–generating a daily summary blog post using
        the intro text of these articles and some preset template (maybe even
        some judicious use of a GPT-3–based AI). This plugin would need to
        publish an article. You could of course just instantiate the
        <code>ArticleTable</code> class of <code>com_content</code> directly
        to do that but this would not run any content plugins or create the
        right entries in the #__assets table, breaking your site. You need to
        use the com_content Article backend model of
        <code>com_content</code>.</para>

        <para>Back in the Joomla 3 days you would do that by directly
        instantiating the <code>ContentModelArticle</code> class. Okay, first
        problem: Joomla didn't know where to find it so you have to
        <code>require_once()</code> the file. Second problem: what if that
        model changes over time and has dependencies to other classes you have
        failed to require the files of? Believe me, I've been there, done that
        and it was about as enjoyable as using a rusty fork to pull my eyes
        out of their sockets.</para>

        <para>In Joomla 4 you don't have to care about the class autoloading,
        but the <code>ArticleModel</code> will actually need access to other
        services provided by the <code>com_content</code> component for things
        like tagging, custom fields and workflows. If you try to instantiate
        the model class directly you will get a lot of errors as well. So, who
        are you gonna call? No, not Ghostbusters; they are Hollywood fiction.
        You're gonna call the very real and very useful
        <code>bootComponent</code> method of the application!</para>

        <programlisting>$contentExtension = \Joomla\CMS\Factory::getApplication()
  -&gt;bootComponent('com_content');
$articleModel = $contentExtension
  -&gt;getMVCFactory()
  -&gt;createModel('Article', 'Administrator');</programlisting>

        <para>The first two lines told Joomla to “boot” the
        <code>com_content</code> component, returning its <emphasis>extension
        object</emphasis>. Now we have have access to all services known to
        this object through its various getters (method whose name start with
        <code>get</code>).</para>

        <para>This works for any component, anywhere, anytime. You can be in
        the frontend, backend, API application or CLI application or in an
        execution context you don't care to know about in a Scheduled Tasks
        plugin. No problem! You can boot any components — yours, core, or
        third party — to get its extension object and Bob's your uncle.</para>
      </section>

      <section xml:id="com-extension-dic-proxy">
        <title>Getting access to the component's DIC anytime, anywhere</title>

        <para>I see that some of you are <emphasis>still</emphasis> not
        convinced that the extension object is a cool concept.</para>

        <para>Remember when I told you that the Joomla DIC — therefore the
        component's DIC which is a customised copy of it — is not a real
        Dependency Injection Container but a Service Locator and lamented the
        fact that you cannot get a reference to it from anywhere in your
        component, unlike modern PHP frameworks like Laravel?</para>

        <para>Well, it turns out that you can get access to your component's
        DIC anywhere, anytime. You just need to add the following handy code
        to your extension's class:</para>

        <programlisting>	protected static $dic;

	public function boot(ContainerInterface $container)
	{
		self::$dic = $container;
	}
	
	public static function getContainer()
	{
		if (empty(self::$dic))
		{
			Factory::getApplication()
			       -&gt;bootComponent('com_example');
		}
		
		return self::$dic;
	}
</programlisting>

        <para>This code is very simple. We declare a protected static variable
        holding our component's DIC. This is initialised by the boot method
        which is called whenever the component is booted. The static method
        getContainer returns the component's DIC; if the DIC was undefined at
        this point it boots the component first.</para>

        <para>So now you can simply do:</para>

        <programlisting>$exampleDIC = \Acme\Example\Administrator\Extension\ExampleComponent::getContainer();</programlisting>

        <para>The component's DIC gives you access to all of the application's
        services and your component's service. Using the MVCFactory to get an
        MVC object you can be sure that it will work as intended.</para>
      </section>
    </section>

    <section xml:id="com-dispatcher">
      <title>Dispatcher</title>

      <para>As we said <link linkend="com-j3-vs-j4-mvc">when comparing the
      Joomla 3 to the Joomla 4 MVC</link>, the Dispatcher takes the place of
      the front controller (<filename>controller.php</filename>) in the legacy
      Joomla 3 MVC. In some ways it also takes the place of the entry point
      file (e.g. <filename>example.php</filename> for a component named
      <code>com_example</code>) as it's the first code which is executed when
      our component is loaded with the explicit intent of rendering
      output.</para>

      <para>Most components do not need a custom Dispatcher. The default
      Dispatcher provided by Joomla is just fine.</para>

      <para>If you do decide to create a custom Dispatcher its class name
      <emphasis role="bold">MUST</emphasis> be
      <code><replaceable>\My\Prefix</replaceable>\Administrator\Dispatcher\Dispatcher</code>
      (backend),
      <code><replaceable>\My\Prefix</replaceable>\Site\Dispatcher\Dispatcher</code>
      (frontend) or
      <code><replaceable>\My\Prefix</replaceable>\Api\Dispatcher\Dispatcher</code>
      (API application) where <code>\My\Prefix</code> is the namespace prefix
      for your component. This class must extend from
      <code>\Joomla\CMS\Dispatcher\ComponentDispatcher</code>.</para>

      <para>Typically, there are two methods you might need to customise. One
      is <code>loadLanguage</code> which loads your component's language
      files. You may have to customise that if, for example, you need to load
      the backend files in the frontend or vice versa, or if you need to load
      some core component's language files on top of yours.</para>

      <para>The other method may be the <code>dispatch()</code> method which
      figures out the view, task and controller from the input and executes
      the component.</para>

      <para>Usually, I override the <code>dispatch()</code> method to add a
      minimum PHP version check and fix up the request variables so I always
      have a view and task. The latter helps when writing Routers for
      components which have record add / edit views in the
      <emphasis>frontend</emphasis>. Such a Dispatcher would look like the
      following code example.</para>

      <programlisting>&lt;?php
namespace Acme\Example\Site\Dispatcher;

defined('_JEXEC') or die;

class Dispatcher extends \Joomla\CMS\Dispatcher\ComponentDispatcher
{
	/**
	 * The default controller (and view), if none is specified in the request.
	 *
	 * @var   string
	 */
	protected $defaultController = 'items';

	/** @inheritdoc */
	public function dispatch()
	{
		$minPHPVersion = '7.4.0';

		if (version_compare(PHP_VERSION, $minPHPVersion, 'lt'))
		{
			throw new \RuntimeException(
				sprintf(
					'This component requires PHP %s or later.',
					$minPHPVersion
				)
			);
		}

		$this-&gt;applyViewAndController();
		
		parent::dispatch();
	}

	/**
	 * Applies the view and controller to the input object communicated to the MVC objects.
	 *
	 * If we have a controller without view or just a task=controllerName.taskName we populate the view to make things
	 * easier and more consistent for us to handle.
	 *
	 * @return  void
	 */
	protected function applyViewAndController(): void
	{
		$controller = $this-&gt;input-&gt;getCmd('controller', null);
		$view       = $this-&gt;input-&gt;getCmd('view', null);
		$task       = $this-&gt;input-&gt;getCmd('task', 'default');

		if (strpos($task, '.') !== false)
		{
			// Explode the controller.task command.
			[$controller, $task] = explode('.', $task);
			$view = null;
		}

		if (empty($controller) &amp;&amp; empty($view))
		{
			$controller = $this-&gt;defaultController;
			$view       = $this-&gt;defaultController;
		}
		elseif (empty($controller) &amp;&amp; !empty($view))
		{
			$controller = $view;
		}
		elseif (!empty($controller) &amp;&amp; empty($view))
		{
			$view = $controller;
		}

		$controller = strtolower($controller);
		$view       = strtolower($view);

		$this-&gt;input-&gt;set('view', $view);
		$this-&gt;input-&gt;set('controller', $controller);
		$this-&gt;input-&gt;set('task', $task);
	}
}</programlisting>
    </section>

    <section xml:id="com-namespaces">
      <title>Namespaces and MVC</title>

      <para>Before we delve into the specifics of how Models, Views,
      Controllers and Tables work in the Joomla 4 MVC we need to talk about
      how they are <emphasis>named</emphasis>.</para>

      <section xml:id="com-namespaces-j3">
        <title>How things worked from Joomla 1.5 to 3.10</title>

        <para>In Joomla 3 the naming convention was
        <code>ComponentTypeName</code> where</para>

        <itemizedlist>
          <listitem>
            <para><code>Component</code> is the name of the component without
            the <code>com_</code> prefix and with the first letter in
            uppercase. For example, if you have <code>com_example</code> the
            first part of an MVC class name was <code>Example</code>.</para>
          </listitem>

          <listitem>
            <para><code>Type</code> is the type of the class you have, i.e.
            one of <code>Component</code>, <code>Model</code>,
            <code>View</code>, or <code>Table</code>. Again, the first letter
            is uppercase.</para>
          </listitem>

          <listitem>
            <para>Name is the name of the specific MVC class with its first
            letter in uppercase, e.g. <code>Item</code>.</para>
          </listitem>
        </itemizedlist>

        <para>This conventions held true in both the front- and backend parts
        of your component. For example, both the frontend and the backend
        would have a class named ExampleControllerItem and they could not
        extend from each other. This led to a <emphasis>lot</emphasis> of code
        duplication. Code duplication is the natural enemy of <link
        xlink:href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</link>
        (Don't Repeat Yourself) code and a source of the most egregious bugs.
        That's why this practice is mockingly called WET: Write Everything
        Twice. When you put it like that it sounds exactly as ridiculous as it
        is practicing it.</para>

        <para>As for file naming, things were pretty clear for Controllers,
        Models and Tables. The name of the file was the <code>Name</code> part
        of your class name, but in all lowercase. For example, the class
        <code>ExampleControllerItem</code> was placed in a file called
        <filename>item.php</filename>.</para>

        <para>Views were... a bit more complicated. A view has a
        <emphasis>view type</emphasis> which corresponds to the
        <parameter>format</parameter> URL parameter, the default (if not
        specified) being <option>html</option>. However, if all view classes
        of the <code>com_example</code> component for the view name
        <code>item</code> are called <code>ExampleViewItem</code> how does
        Joomla figure out which one to load for the <code>html</code>,
        <code>json</code>, <code>raw</code>, <code>feed</code> etc view types?
        The trick was in the <emphasis>file name</emphasis>. Regardless of the
        name of the view class, the file name the class was stored in was
        following the naming convention
        <filename>view.<replaceable>view_type</replaceable>.php</filename>
        where the <replaceable>view_type</replaceable> is the view type in all
        lowercase (corresponds to the URL <parameter>format</parameter>
        parameter). The HTML view class would be stored in a file called
        <filename>view.html.php</filename>. This was maddening because a. the
        file name does not include even a hint to the class name and b. view
        classes cannot extend from each other. Another case of WET.</para>

        <para>With such complicated class and file naming — not to mention one
        not always being related to the other — it was impossible to write
        anything that remotely resembled a working autoloader for component
        classes. This resulted in Joomla using some ugly static calls in its
        base controller, model, view and table classes to get the MVC object
        you wanted. Whether that worked or not depended on whether they were
        called from within the same component or if you had used other badly
        documented static calls to tell these base classes where to look for
        component classes. If you wanted to mix front- and backend classes…
        let's just say the result was not pretty.</para>

        <para>Basically, the Joomla 1.5 to 3.10 MVC class and file naming was
        a rolling Dumpster fire in the sixth ring of Hell. Yet, it was still
        better than nothing, i.e. what WordPress plugin developers have to
        contend with even to this day. It's funny how literally anything is
        better than nothing and how attached people got to what is objectively
        a bad solution which was rushed out of the door.</para>

        <para>A bit of history: The MVC in Joomla 1.5 to 3.10 was never
        considered “finished” by its lead developer, Johan Janssens. He was
        aware of its shortcomings but ran out of time improving it in 2006.
        Janssens left the project shortly after Joomla 1.5 was released. The
        MVC architecture wasn't updated significantly in subsequent versions.
        Features were still added to it, e.g. Forms support in Joomla 1.6, but
        the class and file naming remained untouched until the release of
        Joomla 4 in 2020.</para>
      </section>

      <section xml:id="com-namespaces-j4">
        <title>How things work Joomla 4.0 onwards</title>

        <para>Fixing the hot mess of class and file naming in component's MVC
        was one of the priorities in Joomla 4. Having a CMS in 2020 (when
        Joomla 4 was released) still use a half–finished and proven
        problematic architecture from 2006 would just not cut it.</para>

        <para>The first step was to add <link
        linkend="concepts-namespaces">namespaces</link> and make sure that the
        <link linkend="com-dirs">folder and file names</link> follow the <link
        xlink:href="https://www.php-fig.org/psr/psr-4/">PSR-4</link>
        standard.</para>

        <para>Your component's namespace prefix is declared in the XML
        manifest of the component using a new XML element under the
        <code>&lt;extension&gt;</code> root element:</para>

        <programlisting>&lt;namespace path="src"&gt;My\Namespace\Prefix&lt;/namespace&gt;</programlisting>

        <para>The <code>path</code> attribute tells Joomla which subdirectory
        of your extension holds the PSR-4 of your extension's PHP files. It is
        best practice to name it <filename>src</filename> but <emphasis>you
        don't have to</emphasis>. I always assume you are using
        <filename>src</filename>.</para>

        <para>The text inside the XML element,
        <code>My\Namespace\Prefix</code> in our example, is the namespace
        prefix you will be using. Each component can register its own
        namespace prefix without any restrictions. It is
        <emphasis>recommended</emphasis> to use the convention
        <code>\Company\Something</code> where <code>Company</code> is your
        company name (or a shortened version thereof) and
        <code>Something</code> corresponds to the <code>com_something</code>
        extension name of your component. For example, the component
        <code>com_example</code> by Acme, Inc could have a namespace prefix of
        <code>\Acme\Example</code> set up in its XML manifest.</para>

        <para>Note that this is the common namespace prefix for your entire
        component. Your component has a different part for each of the three
        web applications in Joomla: frontend (site), backend (administrator)
        and api (the brand–new JSON API; this is optional).</para>

        <para>Here is how namespace prefixes work across different types of
        extensions, assuming a common namespace prefix
        <code>Acme\Example</code>:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">Component, frontend</emphasis>. The
            frontend classes MUST be under the namespace
            <code>\Acme\Example\Site</code>. The folder
            <filename>components/com_example/src</filename> is the root of the
            <code>\Acme\Example\Site</code> namespace.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Component, backend</emphasis>. The
            backend classes MUST be under the namespace
            <code>\Acme\Example\Administrator</code>. The folder
            <filename>administrator/components/com_example/src</filename> is
            the root of the <code>\Acme\Example\Administrator</code>
            namespace.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Component, API application</emphasis>.
            The API application classes MUST be under the namespace
            <code>\Acme\Example\Api</code>. The folder
            <filename>api/components/com_example/src</filename> is the root of
            the <code>\Acme\Example\Api</code> namespace.</para>
          </listitem>
        </itemizedlist>

        <para>As for the class naming, it's not a big departure from Joomla 3.
        It's just a more normalised version which takes namespaces into
        account.</para>

        <para>In Joomla 4 and beyond the naming convention for controllers,
        models and tables is
        <code>\<replaceable>NamespacePrefix</replaceable>\<replaceable>ApplicationType</replaceable>\<replaceable>Type</replaceable>\<replaceable>Name</replaceable><replaceable>Type</replaceable></code>
        where:</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>NamespacePrefix</replaceable> is your common
            namespace prefix, e.g. <code>\Acme\Example</code>.</para>
          </listitem>

          <listitem>
            <para><replaceable>ApplicationType</replaceable> is the type of
            the application part of your component i.e. one of
            <code>Site</code> (frontend), <code>Administrator</code>
            (backend), or <code>Api</code> (JSON API application).</para>
          </listitem>

          <listitem>
            <para><replaceable>Name</replaceable> is the name of the specific
            MVC class with its first letter in uppercase, e.g.
            <code>Item</code>.</para>
          </listitem>

          <listitem>
            <para><code><replaceable>Type</replaceable></code> is the type of
            the class you have, i.e. one of <code>Component</code>,
            <code>Model</code>, or <code>Table</code>. Again, the first letter
            is uppercase.</para>
          </listitem>
        </itemizedlist>

        <para>Controllers, models and tables are placed under your
        <filename>src</filename> directory following PSR-4. So, a backend
        class <code>\Acme\Example\Administrator\Model\ItemModel</code> for a
        component <code>com_example</code> whose common namespace prefix is
        <code>\Acme\Example</code> is placed in the file
        <filename>administrator/components/com_example/src/Model/ItemModel.php</filename>.</para>

        <para>Views have a very slightly different convention because we also
        have the <emphasis>view type</emphasis>. Their naming convention is
        <code>\<replaceable>NamespacePrefix</replaceable>\<replaceable>ApplicationType</replaceable>\View\<replaceable>Name</replaceable>\<replaceable>ViewType</replaceable></code>
        where:</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>NamespacePrefix</replaceable> is your common
            namespace prefix, e.g. <code>\Acme\Example</code>.</para>
          </listitem>

          <listitem>
            <para><replaceable>ApplicationType</replaceable> is the type of
            the application part of your component i.e. one of
            <code>Site</code> (frontend), <code>Administrator</code>
            (backend), or <code>Api</code> (JSON API application).</para>
          </listitem>

          <listitem>
            <para>Name is the name of the specific MVC class with its first
            letter in uppercase, e.g. <code>Item</code>.</para>
          </listitem>

          <listitem>
            <para><code>ViewType</code> corresponds to the format URL
            parameter with its first letter in uppercase, e.g.
            <code>Html</code>, <code>Json</code>, <code>Feed</code>,
            <code>Raw</code> and so on.</para>
          </listitem>
        </itemizedlist>

        <para>View classes are placed under your <filename>src</filename>
        directory following PSR-4. So, a backend class
        <code>\Acme\Example\Administrator\View\Item\Html</code> for a
        component <code>com_example</code> whose common namespace prefix is
        <code>\Acme\Example</code> is placed in the file
        <filename>administrator/components/com_example/src/View/Item/Html.php</filename>.</para>

        <para>Right away you can see how namespaces are benefiting us. A
        controller, model, or view in the frontend, backend and api
        application have a different FQN (<link
        xlink:href="https://www.php.net/manual/en/language.namespaces.rules.php">Fully
        Qualified Name</link>). They no longer have the same name. One can
        extend the other if we want to, we <emphasis>can</emphasis> mix
        front-, backend and api MVC objects if we need to and all of these
        classes can be autoloaded without having to use weird static calls.
        Cool!</para>
      </section>
    </section>

    <section xml:id="com-mvcfactory">
      <title>The MVCFactory</title>

      <para>In Joomla 3 you had to make a static call to the base MVC class
      included in Joomla itself to get an instance of an MVC object. For
      example, getting your ExampleModelItem model object you had to do
      something like the following.</para>

      <programlisting>$model = \Joomla\CMS\MVC\Model\BaseDatabaseModel::getInstance('Item', 'ExampleModel');</programlisting>

      <para>If you were to do that in the frontend of the site you'd get the
      frontend <code>ExampleModelItem</code> class stored in
      <filename>components/com_example/models/item.php</filename>. If you were
      to do that in the backend of the site you'd get the backend
      <code>ExampleModelItem</code> class stored in
      <filename>administrator/components/com_example/models/item.php</filename>.
      If you did that from outside the <code>com_example</code> component,
      e.g. in a module or plugin, it would fail unless either the class was
      already loaded beforehand OR you had done something like</para>

      <programlisting>\Joomla\CMS\MVC\Model\BaseDatabaseModel::addIncludePath(
  'components/com_example/models', 'ExampleModel'
);</programlisting>

      <para>Having to call a static method to get an object is bad
      architecture since the superclass where the static method lives in
      becomes a God Object — it knows way too much about how everything works
      in the entire CMS! Moreover, having the ability to auto–load classes
      only under certain circumstances, and having the object returned depend
      on both the application running under and magic configuration supplied
      by static method calls made it impossible to know what will be returned
      every time. The fact that backend and frontend classes had the exact
      same Fully Qualified Name made it impossible to double–check something
      didn't go awry. This loopy behaviour was a constant source of
      bugs.</para>

      <para>Joomla 4 addressed this source of endless frustration by
      introducing the MVCFactory service in the <link
      linkend="concepts-container">component's DI container</link>. The
      MVCFactory object implements the <link
      xlink:href="https://en.wikipedia.org/wiki/Factory_method_pattern">Factory
      method pattern</link> which means it can create instances of our MVC
      objects: controllers, models, views and tables.</para>

      <important>
        <para>Each MVCFactory object instance can only create MVC objects for
        a <emphasis role="bold">specific</emphasis> component! This is in
        stark contrast with the static calls in Joomla 3 which could create an
        MVC object for just about any component.</para>

        <para>This is actually a good thing! It is implementing the
        fundamental computer science principle called <link
        xlink:href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation
        of Concerns</link>. Put another way, if I get the MVCFactory object
        for <code>com_example</code> I know that it can create any MVC object
        I need for <code>com_example</code> and only that components. It won't
        be “polluted” by any other component. Every time I call an MVCFactory
        method <emphasis role="bold">I AM 100% CONFIDENT</emphasis> I am
        getting the object I asked for and expected, not something potentially
        random I have no way of checking. Therefore, the MVCFactory object
        solves the single biggest source of frustration in Joomla component
        development. Hallelujah!</para>
      </important>

      <para>When you are writing code in a Controller or Model class you can
      get your own component's MVCFactory instance using the
      <code>$this-&gt;getMVCFactory()</code> method.</para>

      <para>If you are outside a component — a module, plugin, template or a
      different component — you can <emphasis>still</emphasis> get the
      MVCFactory of any installed and enabled component on the site as we saw
      in <link linkend="com-lifetime">the lifetime of a
      component</link>:</para>

      <programlisting>$comContentMVCFactory = \Joomla\CMS\Factory::getApplication()
  -&gt;bootComponent('com_content')
  -&gt;getMVCFactory();</programlisting>

      <tip>
        <para>Before trying to boot a component you are supposed to check the
        component is installed <emphasis>and</emphasis> enabled. You can do
        that very simply, e.g. for <code>com_content</code>, with this
        code</para>

        <programlisting>\Joomla\CMS\Component\ComponentHelper::isEnabled('com_content')</programlisting>
      </tip>

      <para>The MVCFactory has four public methods corresponding to the MVC
      objects we can create:</para>

      <variablelist>
        <varlistentry>
          <term>createController</term>

          <listitem>
            <para>Loads and creates a controller object.</para>

            <programlisting>$myController = $this-&gt;getMVCFactory()
  -&gt;createController('Item', 'Administrator');</programlisting>

            <para>The first argument is the name of the controller. The second
            argument is the application type (<code>Site</code>,
            <code>Administrator</code>, or <code>Api</code>).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>createModel</term>

          <listitem>
            <para>Loads and creates a model object.</para>

            <programlisting>$myModel = $this-&gt;getMVCFactory()
  -&gt;createModel('Item', 'Administrator');</programlisting>

            <para>The first argument is the name of the controller. The second
            argument is the application type (<code>Site</code>,
            <code>Administrator</code>, or <code>Api</code>).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>createView</term>

          <listitem>
            <para>Loads and creates a view object.</para>

            <programlisting>$myView = $this-&gt;getMVCFactory()
  -&gt;createView('Item', 'Administrator', 'Html');</programlisting>

            <para>The first argument is the name of the controller. The second
            argument is the application type (<code>Site</code>,
            <code>Administrator</code>, or <code>Api</code>). The third
            argument is the view type which corresponds to the
            <parameter>format</parameter> URL parameter.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>createTable</term>

          <listitem>
            <para>Loads and creates a table object.</para>

            <programlisting>$myTable = $this-&gt;getMVCFactory()
  -&gt;createTable('Item', 'Administrator');</programlisting>

            <para>The first argument is the name of the controller. The second
            argument is the application type (<code>Site</code>,
            <code>Administrator</code>, or <code>Api</code>).</para>

            <warning>
              <para>Joomla table classes are only defined in the backend
              (<code>Administrator</code>) of your component. Therefore your
              second argument MUST always be
              <code>'Administrator'</code>.</para>

              <para>While you could conceivably define table classes in the
              site or api parts of your component it's not recommended and you
              should not expect Joomla's core code to be able to find them.
              Think of that second argument as a “forwards compatibility”
              provision, in case Joomla ever fully supports creating tables in
              the site or api parts of your component.</para>
            </warning>
          </listitem>
        </varlistentry>
      </variablelist>

      <bridgehead>MVCFactory and Dependency Injection</bridgehead>

      <para>The MVCFactory also performs a modicum of dependency injection. It
      inspects each created MVC object and checks which interfaces it
      implements. Depending on which interfaces are implemented some basic
      objects (form factory, dispatcher, router, cache controller, database
      object) are taken from the corresponding services in the component's DI
      container and injected into the MVC object.</para>

      <para>If you want to inject additional services you will have to extend
      the MVCFactory service in your component's service provider using a
      custom MVCFactory wrapper. When registering the service extension in
      your component's <link linkend="com-services">service provider</link>
      you can push your custom service to the MVCFactory wrapper and use it in
      the overridden methods of the wrapper. We will see an example of that
      <link linkend="com-models-push-service-joomla">pushing a custom service
      into a Model</link> later in this book.</para>

      <para>While this sounds like a bit of a chore, it is actually a very
      clean architecture. If you decide to make a change in your service's
      initialisation — or swap it out with a completely different
      implementation altogether — you can do that trivially by changing one
      line of code in your service provider. No more hunting down all over
      your codebase for that elusive reference to the service you are using.
      This is just another way Dependency Injection helps you write more
      sustainable code.</para>
    </section>

    <section xml:id="com-models">
      <title>Models</title>

      <para>The bulk of the implementation logic for Joomla 4 MVC models is
      the same as in Joomla 3 MVC.</para>

      <para>The Model classes extend from one of the base Joomla MVC Model
      super–classes:</para>

      <variablelist>
        <varlistentry>
          <term>Joomla\CMS\MVC\Model\BaseModel</term>

          <listitem>
            <para>The most basic model you can get. It does not connect to a
            database and does not support form. This is the kind of model you
            may need to use if you have a static view in your component (e.g.
            a control panel not implemented with a core <link
            linkend="com-dashboard">Dashboard</link>), if your model deals
            with data outside of the database (e.g. processing images, talking
            to a third party API over HTTP, converting files, etc) or if it
            uses an external or third party library (e.g. in Akeeba Backup the
            BackupModel uses our Akeeba Engine backup engine library).</para>

            <para>The basic service it provide is model state management using
            the <code>getState</code>, <code>setState</code> and
            <code>populateState</code> methods.</para>

            <tip>
              <para>In a proper MVC implementation the only way the Controller
              would “talk” to a Model is by setting its state and then reading
              either the return value of the method it called or inspecting
              the Model's state.</para>

              <para>In Joomla MVC the model state is a weird beast. It is
              ‘normally’ set by reading it from the session and overriding it
              from the request parameters using the application's
              <code>getUserStateFromRequest</code> method.</para>

              <para>While this is mostly okay for simple administrator pages
              listing and editing records you may find yourself in situations
              where you need to “talk” to the model from the Controller.
              Instead of passing this information around as HTTP GET/POST
              parameters — which can be inspected and
              <emphasis>overridden</emphasis> by a curious or malicious user —
              I urge you to instead override the <code>display</code> method
              of your Controller and set the Model's state after instantiating
              it. This is something you will not see anywhere in the Joomla
              core code but something you SHOULD be doing in your more complex
              components to avoid embarrassing and easily preventable security
              vulnerabilities.</para>

              <para>Speaking of which, <emphasis>always</emphasis> validate
              the data type and values of your model state in your code.
              Writing secure code requires you to adopt a “trust no–one”
              stance against any data which is not hard–coded into your
              extension's code! Do not assume that the data will be safe
              because (you think that) only a Super User can access a specific
              view. First of all, your assumption may be wrong. Moreover, your
              Model may be used outside the View you have in mind, even by
              third party components, plugins and modules integrating with
              your extension. Trust no–one, not even your own
              assumptions!</para>
            </tip>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\BaseDatabaseModel</term>

          <listitem>
            <para>This is an extension to BaseModel primarily adding database
            support. You can get the applicable database object with
            <code>$this-&gt;getDbo()</code> (Joomla 4.0 or later 4.x version)
            or <code>$this-&gt;getDatabase()</code> (Joomla 4.2 and later
            versions, including 5.0 and later).</para>

            <para>Beyond that, it lets you dispatch events using the global
            Event Dispatcher you get with
            <code>$this-&gt;getDispatcher()</code> (Joomla 4.2 and later), get
            the Joomla user object of the currently logged in user with
            <code>$this-&gt;getCurrentUser()</code> (Joomla 4.2 and later),
            and get the CacheControllerFactory to talk to Joomla's cache with
            <code>$this-&gt;getCacheControllerFactory()</code> (Joomla 4.2 and
            later).</para>

            <para>This is the most used type of model super–class, either
            having your models directly extend it or indirectly extend it by
            using one of its descendant classes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\FormModel</term>

          <listitem>
            <para>This is an extension to the BaseDatabaseModel which
            additionally implements Form handling.</para>

            <important>
              <para>This IS NOT the class you want to extend in pages which
              edit existing or create new records! What you are looking for in
              this case is Joomla\CMS\MVC\Model\AdminModel (yes, even in the
              frontend!).</para>
            </important>

            <para>This is the kind of Model you are going to use on pages
            which render a Form using an XML file for collecting information
            from the user BUT NOT for the purpose of editing or creating a
            record.</para>

            <para>A practical example of this is the Joomla Global
            Configuration page's model
            (<code>Joomla\Component\Config\Administrator\Model\ApplicationModel</code>)
            which does render an XML form with the Global Configuration
            option. Compare this to the article edit page's model
            (<code>Joomla\Component\Content\Administrator\Model\ArticleModel</code>)
            and the difference becomes evident right away!</para>

            <para>In your components you might want to use this type of Model
            in custom configuration pages. For example, you may have a
            component which post new articles automatically on social media.
            You may want to create different configurations for Facebook,
            Twitter, Reddit and whatnot. The page managing each of these
            configurations, each one using its own XML form file, would very
            likely use a Model class extending from <code>FormModel</code>
            instead of <code>AdminModel</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\AdminModel</term>

          <listitem>
            <para>This is an extension to the <code>FormModel</code> which is
            designed specifically for creating new and editing existing
            records.</para>

            <para>What is the difference? Whereas <code>FormModel</code> is
            made to deal with the collection of arbitrary data, the
            <code>AdminModel</code> is made to create and edit records having
            the same data shape, defined in a database table. As a result, it
            works together with a <link linkend="com-tables">Table
            object</link>. Most of its methods will be talking to the Table
            object.</para>

            <para>It also supports automatic integration with content plugins
            and implements the methods you need to save new/existing records,
            reorder records, change record associations, batch process
            records, check–in and check–out records to the database, change
            the publish / trash state, and permanently delete records. Yup,
            this type of Model basically handles nearly everything you need to
            manage records in the backend of a site
            <emphasis>except</emphasis> listing records.</para>

            <note>
              <para>I had personally found it extremely confusing that the
              <code>AdminModel</code> (and the corresponding
              <code>FormController</code>) is responsible for handling all the
              actions you see available in the toolbar of a records list page.
              When you think about architecture it does make sense. When you
              are new to Joomla you might wonder why this is not handled by
              <code>ListModel</code> (and its corresponding
              <code>AdminController</code>). This is unfortunately a case of
              “you do this just because”, not a case of using what you'd
              intuitively think is the right thing to use. I know,
              right?!</para>

              <para>You may also get confused by the fact that an
              AdminController has a ListModel whereas a FormController has an
              AdminModel. It looks like someone had a stroke trying to name
              things.</para>

              <para>Thankfully, no, nobody had a stroke — the weird naming
              comes from the fact that when forms were introduced in Joomla
              1.6 we had to maintain backwards compatibility to Joomla 1.5,
              thereby causing a class naming mayhem. You know what are the two
              hardest things in software development? Handling dates, managing
              backwards compatibility and off–by–one errors!</para>
            </note>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\ItemModel</term>

          <listitem>
            <para>This is an extension of the DatabaseModel, designed to
            <emphasis>display</emphasis> a single record in the
            frontend.</para>

            <para>This is something you will use probably a lot in the
            frontend of your application when you want to show a single record
            which cannot be edited. Unlike the FormModel and the AdminModel,
            this Model class does not have any kind of management code for the
            records. It just displays them and that's it.</para>

            <tip>
              <para>Practically speaking, you might just end up extending your
              frontend Model from your backend Model which in turn extends
              from Joomla's AdminModel if you need to provide any kind of
              frontend administration of your component. There is no point
              creating two models to talk to the same data, one just to show
              it and one just to modify it. It also makes no sense to have
              your frontend Model extend from AdminModel and duplicate your
              code (WET code) when you can simply extend your backend model
              and refrain from repeating yourself (DRY code).</para>
            </tip>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\ListModel</term>

          <listitem>
            <para>This class extends from the DatabaseModel and has the
            ability to manage forms (you need them for Search Tools a.k.a.
            list filters) and, crucially, to provide pagination–aware list of
            records from a database table.</para>

            <para>You know how the main Joomla backend user interface pattern
            is a list of records? Yup, this is the Model which implements
            it.</para>

            <tip>
              <para>In the frontend of your component you will very frequently
              find yourself needing to list a bunch of items in
              pagination–aware lists. The traditional Joomla code pattern was
              to create a frontend Model which extended from BaseDatabaseModel
              and have the same code to list items copied over from the
              backend.</para>

              <para>Don't do that. It's WET code and I've already mentioned
              that it's the source of many a bug.</para>

              <para>What you will practically find yourself doing is extending
              the frontend Model from the backend Model. Unlike Joomla 3, this
              is now possible!</para>

              <para>You need to be acutely aware, though, that you will need
              to override the <code>populateState</code> method in the
              frontend model. By default, this method will accept any kind of
              user input for filtering the list of records which could indeed
              be used by a malicious user to display items they are not
              supposed to access!</para>

              <para>An even better approach is what I hinted to earlier.
              Override the <code>display</code> method of your Controller. In
              there, first do a <code>getState</code> on your model (to run
              the <code>populateState</code> and be done with it), then
              explicitly set the Model state using its <code>setState</code>
              method before passing it to your View object. When you do that,
              the state set by your Controller's code overrides whatever
              <code>populateState</code> did, thereby mitigating any security
              risks.</para>
            </tip>
          </listitem>
        </varlistentry>
      </variablelist>

      <section xml:id="com-models-interfaces-traits">
        <title>Interfaces and Traits</title>

        <para>In Joomla 3 each Model type tried to do everything under the sun
        and even implement features which might have nothing to do with your
        component, like tags and versioning.</para>

        <para>In Joomla 4 and later versions the default Model classes don't
        do any of that. That's a good thing because it promotes the computer
        science principle called Separation of Concerns. If you need
        additional features you will be doing a bit of <emphasis>object
        composition</emphasis>.</para>

        <para>For those with a Computer Science background, you may wonder how
        you can do object composition in a language like PHP which, unlike C
        for example, does not allow classes to inherit (extend) from multiple
        classes. The answer is by using Traits provided by Joomla.</para>

        <variablelist>
          <varlistentry>
            <term>\Joomla\CMS\Versioning\VersionableModelTrait</term>

            <listitem>
              <para>Implements support for Versions (record history).</para>

              <para>Only applicable to models extending from
              <code>AdminModel</code>. This requires the <guilabel>Behaviour -
              Versionable</guilabel> plugin to be published. The corresponding
              Table must implement the
              <code>\Joomla\CMS\Versioning\VersionableTableInterface</code>
              interface and the corresponding Controller must use the
              <code>\Joomla\CMS\Versioning\VersionableControllerTrait</code>
              trait.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\Joomla\CMS\MVC\Model\WorkflowBehaviorTrait</term>

            <listitem>
              <para>Implements support for Workflows (prescribed steps for
              state changes in records).</para>

              <para>Only applicable to models extending from
              <code>AdminModel</code>. The model must implement the
              <code>\Joomla\CMS\MVC\Model\WorkflowModelInterface</code>
              interface.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section xml:id="com-models-push-service-joomla">
        <title>Pushing services to the Model: the Joomla Way</title>

        <note>
          <para>This way only applies to Joomla 4.3 and later. If you want
          your component to support earlier Joomla versions you will have to
          use the alternative method outlined towards the end of this
          section.</para>
        </note>

        <para>TODO — This section is pending the submission and acceptance of
        a Pull Request to the Joomla Project.</para>
      </section>

      <section xml:id="com-models-push-service-alt">
        <title>Pushing services to the Model: an alternative</title>

        <para>While Joomla 4.3 and later allows you to push services into the
        Model using an MVCFactory wrapper which extends the MVC service,
        necessary parts of this architecture did not exist in previous Joomla
        versions. We will have to use a slightly less “architecturally clean”
        solution.</para>

        <para>We will <emphasis role="bold">pull</emphasis> the custom service
        <emphasis role="bold">from</emphasis> the component's DIC.</para>

        <para>First, you need to make sure that you register a service
        provider in <link linkend="com-services">your component's service
        provider</link> implementation:</para>

        <programlisting>$container-&gt;set(
    \Acme\Example\Administrator\Service\FacebookPublish::class,
    function (Container $container) {
        return new \Acme\Example\Administrator\Service\FacebookPublish();
    }
);</programlisting>

        <para>Then, you need to modify your <link
        linkend="com-extension">component's extension class section</link> as
        we saw on that section's “Getting access to the component's DIC
        anytime, anywhere” to be able to statically return the component's DI
        Container anytime, anywhere:</para>

        <programlisting>	protected static $dic;

	public function boot(ContainerInterface $container)
	{
		self::$dic = $container;
	}
	
	public static function getContainer()
	{
		if (empty(self::$dic))
		{
			Factory::getApplication()
			       -&gt;bootComponent('com_example');
		}
		
		return self::$dic;
	}</programlisting>

        <para>Now your Model can simply pull the service from the Component's
        DIC in its constructor:</para>

        <programlisting>&lt;?php

namespace Acme\Example\Administrator\Model;

use Acme\Example\Administrator\Extension\ExampleComponent;
use Acme\Example\Administrator\Service\FacebookPublish;
use Joomla\CMS\Form\FormFactoryInterface;
use Joomla\CMS\MVC\Factory\MVCFactoryInterface;
use Joomla\CMS\MVC\Model\AdminModel;

class ItemModel extends AdminModel
{
	private $fbPublish;

	public function __construct($config = [], MVCFactoryInterface $factory = null,
								FormFactoryInterface $formFactory = null)
	{
		parent::__construct($config, $factory, $formFactory);

		$exampleDIC      = ExampleComponent::getContainer();
		$this-&gt;fbPublish = $exampleDIC-&gt;get(FacebookPublish::class);
	}

	protected function getFacebookPublish(): FacebookPublish
	{
		return $this-&gt;fbPublish;
	}

	// The rest of your model's code goes here…
}</programlisting>

        <para>For completeness' sake, here are there are two (minor) downsides
        to this approach:</para>

        <itemizedlist>
          <listitem>
            <para>The Model now has a direct hard dependency on the
            component's extension class. For real world use inside Joomla this
            is not a big deal; the only recommended way to create instances of
            a component's Models is through its MVCFactory object which
            necessarily goes through the component's extension object. If you
            are writing Unit Tests, though, you can no longer isolate the
            Model. You will need to inject a dependency injection container
            with your custom service in the component's extension
            class.</para>
          </listitem>

          <listitem>
            <para>The extension class has a static method to fetch the DIC. If
            this is not already set up it will try to go through the global
            application object to boot the component. If you are writing Unit
            Tests this is a problem, hence why I said that you need to inject
            a DIC to your component's extension class.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="com-controllers">
      <title>Controllers</title>

      <para>The bulk of the implementation logic for Joomla 4 MVC Controllers
      is the same as in Joomla 3 MVC.</para>

      <para>The logic is that most views are displayed using the component's
      <code>DisplayController</code> which extends from Joomla's
      <code>Joomla\CMS\MVC\Controller\BaseController</code>. You only write
      custom controllers when there's an action needed or when you need access
      to a Form object.</para>

      <tip>
        <para>The kind of MVC practiced by Joomla and described above is a bit
        “dirty”; all views share a common DisplayController for displaying.
        This is fine with Joomla's one–trick–pony components, only able to
        display one kind of information.</para>

        <para>When you have something more complex this may not be at all
        convenient. For example, a document management system might need
        separate views to display nested categories, available items
        (including the actual <emphasis>downloading</emphasis> part!) and
        uploading items, as well as viewing, adding and managing comments per
        document. In these cases it's typically much more efficient to have a
        separate controller per view. In components like that each view
        consists of a Controller, Model and View class (an MVC triad) which is
        more in line with how the normative MVC coding pattern is meant to
        work. This is perfectly possible in Joomla <emphasis>as long as you
        have a custom Dispatcher</emphasis>. You can see how I am doing that
        <link
        xlink:href="https://github.com/akeeba/release-system/blob/development/component/backend/src/Dispatcher/Dispatcher.php">in
        the Dispatcher of Akeeba Release System</link>, the software downloads
        management software used by Joomla's official Downloads site.</para>
      </tip>

      <para>The Controller classes extend from one of the base Joomla MVC
      Controller super–classes:</para>

      <variablelist>
        <varlistentry>
          <term>Joomla\CMS\MVC\Controller\BaseController</term>

          <listitem>
            <para>The most basic controller you can get. It is mainly used to
            power the <code>DisplayController</code> of the component or
            whenever you want to create custom controllers to display stuff
            and perform non–administrative actions (e.g. in the
            frontend).</para>

            <warning>
              <para>Heads up! In Joomla 3 the default display controller was
              in the root of the component as the file
              <filename>controller.php</filename> e.g.
              <filename>administrator/components/com_example/controller.php</filename>.
              This is no longer the case in Joomla 4 and later. All
              controllers are under the <filename>src/Controller</filename>
              folder and the default controller is named
              <code>DisplayController</code> which means that in the above
              example it would be located in
              <filename>administrator/components/com_example/srs/Controller/DisplayController.php</filename>.</para>

              <para>In Joomla 4 and later the <code>DisplayController</code>
              is mostly empty except for a line like this:</para>

              <programlisting>protected $default_view = 'foobar';</programlisting>

              <para>This is the name of the “default view”. That's the view
              which will be displayed if the <parameter>view</parameter> URL
              parameter is not provided in the request.</para>
            </warning>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\Controller\AdminController</term>

          <listitem>
            <para>This is an extension to BaseController. It is meant for
            displaying list views in the backend of your site, e.g. a list of
            articles.</para>

            <tip>
              <para>This is the controller you will be typically using for
              controllers whose name is <emphasis
              role="bold">plural</emphasis> such as
              <code>\Acme\Example\Administrator\Controller\ItemsController</code>.
              Since this is the Items controller and “items” is plural it
              gives us a hint that it will be displaying multiple items which,
              in the Joomla backend, is very likely to be a list.</para>

              <para>A mnemonic way to remember this is PASiFIC (yes, with the
              misspelling and all) "Plural Admin Singular Form Identifies the
              Controller".</para>
            </tip>

            <para>It also handles <emphasis role="bold">some</emphasis> of the
            admin tasks you will have to perform on records in a Joomla list
            view: publish, unpulish, archive, trash, report, orderup,
            orderdown, delete, reorder, saveorder, checkin, checkout,
            saveOrderAjax and runTransition. Everything else has to be handled
            by a singular named Controller which extends FormController. Yes,
            that's confusing and yes, it's the source of many bugs — but
            that's the same as Joomla 3 and earlier so at least it's
            <emphasis>consistently confusing</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\Controller\FormController</term>

          <listitem>
            <para>This is an extension to the BaseController which
            additionally implements Form handling. This is meant to be used in
            views which add or edit a database record. Additionally, it will
            be used in views which handle an XML Form e.g. a configuration
            page.</para>

            <tip>
              <para>This is the controller you will be typically using for
              controllers whose name is <emphasis
              role="bold">singular</emphasis> such as
              <code>\Acme\Example\Administrator\Controller\ItemController</code>.
              Since this is the Item controller and “item” is singular it
              gives us a hint that it will be displaying a single item which,
              in the Joomla backend, is very likely to be an add / edit record
              page.</para>

              <para>In the frontend of the site you may have <emphasis
              role="bold">two</emphasis> controllers for the same data type.
              One DisplayController extending from BaseController to display
              the item and one singular name controller extending from
              FormController to add or edit an item. It
              <emphasis>is</emphasis> possible to have a single controller,
              extending from FormController. You see, FormController itself
              extends from BaseController which has the display method which
              is used to display stuff, i.e. it already contains the
              functionality of the typical DisplayController.</para>
            </tip>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\Controller\ApiController</term>

          <listitem>
            <para>This is a very special kind of controller which is only used
            in the <link linkend="com-api">JSON API application part of your
            component</link> e.g. the code under
            <filename>api/components/com_example</filename>.</para>

            <para>This type of controller does not have a direct equivalent in
            the other controllers. It can do everything. Produce a list of
            records, return a single record, create a new record and modify or
            delete an existing record.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <section xml:id="com-controllers-basic-services">
        <title>Basic services in your Controller</title>

        <para>A Controller object created by Joomla has a few basic services.
        In the olden days before Joomla 4 we had to use static methods in
        <code>\Joomla\CMS\Factory</code> (formerly <code>JFactory</code>) or
        the base MVC objects themselves to get access to these services. You
        are no longer supposed to do that, you are supposed to use the
        services provided in the Controller object itself.</para>

        <bridgehead>Application</bridgehead>

        <para>In Joomla 3 and earlier we would get the currently active
        application object through
        <code>\Joomla\CMS\Factory::getApplication()</code>. Do NOT do
        that.</para>

        <para>In Joomla 4 and later you can get the currently active
        application object through <code>$this-&gt;app</code>.</para>

        <para>Please remember that the application you are getting is not
        necessarily a <code>SiteApplication</code> or
        <code>AdministratorApplication</code>. It may very well be an
        <code>ApiApplication</code> (JSON API), a
        <code>ConsoleApplication</code> (Joomla CLI app) or even a custom
        application extending from
        <code>\Joomla\CMS\Application\CMSApplication</code>.</para>

        <bridgehead>Dispatcher</bridgehead>

        <para>In Joomla 3 and earlier you'd run plugin events by doing
        something like this:</para>

        <programlisting>$results = \Joomla\CMS\Factory::getApplication()
  -&gt;triggerEvent('onSomething', [$param1, $param2]);</programlisting>

        <para>In Joomla 4 and later there are two ways to call plugin
        events.</para>

        <para>The first method is the legacy method, going through the
        application's <code>triggerEvent</code> method, which is discouraged
        and will eventually go away.</para>

        <programlisting>$results = $this-&gt;app-&gt;triggerEvent('onSomething', [$param1, $param2]);</programlisting>

        <para>The second and recommended method is going through the Joomla
        events dispatcher and using real events.</para>

        <programlisting>$event = \Joomla\CMS\Event\GenericEvent::create('onSomething', [$param1, $param2]);
$this-&gt;getDispatcher()-&gt;dispatch($event-&gt;getName(), $event);
$results = $event-&gt;getArgument('result', []);</programlisting>

        <para>While this looks a bit more complicated it has some
        benefits.</para>

        <para>Using Events to access plugins means that you get access to a
        <link linkend="plg-concrete-events">concrete event object</link>. All
        core Joomla events will correspond to concrete event objects in Joomla
        5.0, meaning that you will be able to add typehinting and have your
        IDE (e.g. phpStorm, Visual Studio Code, NetBeans, Eclipse, ...)
        auto–complete the argument names when manipulating an event.</para>

        <para>The real Events implemented in Joomla 4 and later, unlike plain
        old plugin handlers we had in Joomla 1.0 to 3.10, can prevent some of
        their arguments to be modified, prescribe exactly
        <emphasis>what</emphasis> can be modified and even allow plugins to
        stop the processing of an event when we reach a point that further
        processing is unnecessary. If you slowly move from just using custom
        event names to concrete event classes you can implement far more
        complex features in your code with much less code — believe me, I've
        been there and done that! Event handling is one of those fundamental
        things which you are <emphasis>really</emphasis> upset it's changed
        but once you start getting the idea of how the new system works you
        start wondering how you could have ever written software without
        it.</para>

        <bridgehead>Input</bridgehead>

        <para>Back in the olden days we'd get the user's input by doing one of
        these (the more of these you remember the older you are — some date
        back to the early 00s!):</para>

        <programlisting>// Joomla 1.0
$foo = \JRequest::getCmd('foo');
// Joomla 1.5
$input = new \Joomla\CMS\Input\Input();
$foo = $input-&gt;getCmd('foo');
// Joomla 1.6
$foo = Joomla\CMS\Factory::getApplication()-&gt;input-&gt;getCmd('foo');</programlisting>

        <para>This had always been a bad idea because our Controller had to
        <emphasis>know</emphasis> about the global application object and its
        request variables. This meant, for example, that we could not reuse
        our component to display a view <link linkend="com-hmvc">using
        HMVC</link>.</para>

        <para>Since Joomla 3.0 the Controller object has an <code>input</code>
        property which holds its own <code>\Joomla\CMS\Input\Input</code>
        object. In Joomla 3 this was typically just the application's input
        object unless you were manually constructing a controller (with a lot
        of effort).</para>

        <para>In Joomla 4.0 and later the input property contains its own
        \Joomla\CMS\Input\Input object <emphasis>which comes from the DI
        Container of the component</emphasis>. Remember that when booting a
        component we get access to its <link linkend="com-extension">component
        extension object</link> which has access to the component's <link
        linkend="concepts-container">DI Container</link>. This of course means
        that we can add <link linkend="com-extension-dic-proxy">a method to
        that object to access the DI Container</link> and set a custom input
        object, thereby implementing HMVC very easily — something that Joomla
        core maintainers didn't think was possible with the core architecture
        a few years ago! This means that whenever we want to create a module
        which displays the same information an existing view of our component
        already does, albeit in a slightly different format, all we need to do
        is create a new view template or layout and use HMVC, without having
        to rewrite our business logic in the module. We can write less code to
        do more. That's awesome!</para>

        <para>That is (one of the many reasons) why you should
        <emphasis>always</emphasis> be accessing the input as
        <code>$this-&gt;input</code> in your controllers. Now you know.</para>

        <bridgehead>MVCFactory</bridgehead>

        <para>Back in Joomla 1.0 to 3.10 creating an MVC object such as a
        Model, View, Table, or even another Controller from inside our
        Controller required calling static methods in the base MVC objects or
        proxy methods in the controller, like so:</para>

        <programlisting>$someController = \Joomla\CMS\MVC\Controller\BaseController::getInstance('Some');
$someModel = \Joomla\CMS\MVC\Model\BaseDatabaseModel::getInstance('Some', 'ExampleModel');
// or
$someModel = $this-&gt;createModel('Some', 'ExampleModel');
$someView = $this-&gt;createView('Some', 'ExampleView', 'Html');
$someTable = \Joomla\CMS\Table\Table::getInstance('Some', 'ExampleTable');</programlisting>

        <para>There are two things which strike us as suboptimal:</para>

        <itemizedlist>
          <listitem>
            <para>There is no consistency in how you create MVC objects. Some
            are static calls, some are method calls to proxy functions.</para>
          </listitem>

          <listitem>
            <para>There is no consistency in the arguments you provide.
            Creating a controller only needs its name (and requires the magic
            configuration array key <code>base_path</code> if you want to get
            a controller from a component other than the current one),
            creating anything else requires us to give it the prefix of the
            MVC class name (not just the component name).</para>
          </listitem>
        </itemizedlist>

        <para>This is what we'd call “sanity came here to die”.</para>

        <para>Joomla 3.10 introduced the MVCFactory for creating models, views
        and tables and Joomla 4.0 extended it by also letting it create
        controllers. See how easier and more consistent everything is
        now:</para>

        <programlisting>// Only on Joomla 4.0 and later
$someController = $this-&gt;getMVCFactory()-&gt;createController('Some', 'Administrator');
// Joomla 3.10 and later
$someModel = $this-&gt;getMVCFactory()-&gt;createModel('Some', 'Administrator');
$someView = $this-&gt;getMVCFactory()-&gt;createView('Some', 'Administrator', 'Html');
$someTable = $this-&gt;getMVCFactory()-&gt;createTable('Some', 'Administrator');
// Inside the Controller I can still do this (4.0 and later):
$someModel = $this-&gt;getModel('Some', 'Administrator');
$someView = $this-&gt;getView('Some', 'Administrator', 'Html');</programlisting>

        <para>First of all, we see that creating MVC objects is now very
        consistent and easier.</para>

        <para>Second, we notice that the <code>$prefix</code> argument is no
        longer something component–specific (such as
        <code>ExampleModel</code>) but simply the side of the application
        (Site, Administrator or Api) that we want to get the MVC object
        from.</para>

        <note>
          <para>Tables are only available in the Administrator side of the
          application. While you can theoretically defined different Table
          classes in the frontend (Site) or JSON API (Api) side it's not a
          good idea as you will very likely run into issues where the “wrong”
          table class is being used. As a result, it's advisable to always
          call <code>createTable</code> with two parameters and set the second
          parameter to <option>Administrator</option>).</para>
        </note>

        <para>Legacy Joomla 3 components still work despite the apparent
        backwards compatibility (b/c) break in the <code>getModel</code> and
        <code>getView</code> methods. Why is that? Well, it's because Joomla 4
        uses the <code>\Joomla\CMS\MVC\Factory\LegacyFactory</code> instead of
        <code>\Joomla\CMS\MVC\Factory\MVCFactory</code> for these components.
        The LegacyFactory is aware of the b/c break and acts accordingly so
        you, the extensions developer, do not suffer. This is possible because
        each component has its own DI Container. So that's another way how
        using a DI Container allowed Joomla to create an updated, richer MVC
        API without breaking backwards compatibility with Joomla 3 — at least
        until Joomla 6.0. Neat, huh?</para>

        <para>As a developer, you should remember this when you are inside a
        Controller writing code:</para>

        <itemizedlist>
          <listitem>
            <para>If you want to get a Model or View use the controller's
            <code>getModel</code> and <code>getView</code> methods.</para>
          </listitem>

          <listitem>
            <para>If you want to get another <code>Controller</code> or a
            <code>Table</code> do not instantiate them directly! Always go
            through the MVCFactory.</para>
          </listitem>

          <listitem>
            <para>The second argument to all these methods is the application
            side you are getting an object from. Leave it empty to use the
            <emphasis>current</emphasis> application side or pass an explicit
            value. If you leave it empty keep in mind that, for example, your
            backend controller may be running in the frontend. In this case,
            do you <emphasis>really</emphasis> want to get the frontend
            model?</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="com-views">
      <title>Views</title>

      <para>Views, in Joomla 3, referred to two different things: the View
      classes and the view templates. In fact, the view templates were placed
      in a <code>tmpl</code> folder under each View's folder which was a bad
      idea: you had the output rendering in a subdirectory of the business
      logic, making it hard to discern when one ends and the other
      begins.</para>

      <para>In Joomla 4 there is a separation of these two very different
      types of code. The view classes (which we will call Views) are placed in
      the <filename>src/View</filename> folder with one subdirectory for each
      view in <code>Uppercasefirst</code> format. The view templates are
      placed in the <filename>tmpl</filename> folder in your component's
      folder with one subdirectory for each view they correspond to in
      <code>lowercase</code> format.</para>

      <warning>
        <para><emphasis role="bold">Folder and file name case
        matters</emphasis>. You may not notice it when developing on a Windows
        or macOS machine with a case–insensitive filesystem but you will
        <emphasis>definitely</emphasis> suffer if you mix it up when deploying
        your component on a Linux–based server where the filesystem is
        virtually guaranteed to be case–sensitive.</para>

        <para>Let's say you have a view which is called Foobar.</para>

        <para>Your HTML View class file path relative to your component's root
        MUST be <filename>src/View/Foobar/Html.php</filename>. It can NOT be
        <filename>src/View/FooBar/Html.php</filename> (mixed case in the
        subdirectory) or <filename>src/View/Foobar/HTML.php</filename> (wrong
        case for the filename)!</para>

        <para>Your view <filename>default.php</filename> view template file
        path relative to your component's root MUST be
        <filename>tmpl/foobar/default.php</filename>. It cannot be
        <filename>tmpl/Foobar/default.php</filename> (wrong case for the
        subdirectory)!</para>

        <para>Knowing this will save you hours of “fun” hitting your head
        against a brick wall, wondering why it works on your computer but on
        your server.</para>
      </warning>

      <para>The bulk of the implementation logic for Joomla 4 MVC Views is the
      same as in Joomla 3 MVC.</para>

      <para>The View classes extend from one of the base Joomla MVC View
      super–classes:</para>

      <variablelist>
        <varlistentry>
          <term>\Joomla\CMS\MVC\View\AbstractView</term>

          <listitem>
            <para>This is the base class all views extend from. You will have
            to implement the <code>display</code> method yourself.</para>

            <para>It is very rare that you are going to extend from this view.
            Typically, this is something you will do when you are rendering a
            non-HTML document, without using a view template file. Do note
            that if you are outputting JSON you may want to use
            <code>\Joomla\CMS\MVC\View\JsonView</code> instead.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\View\HtmlView</term>

          <listitem>
            <para>This is the most common view type, used whenever you want to
            display HTML output in the front- or backend.</para>

            <note>
              <para>Even though Joomla defines the
              <code>\Joomla\CMS\MVC\View\ListView</code> class for
              administrator list views and
              <code>\Joomla\CMS\MVC\View\FormView</code> for add/edit views,
              these view classes are no longer used in Joomla 4. Both types of
              pages use the HtmlView instead. As a result, the two more
              specialised view types will not be mentioned again in this
              book.</para>
            </note>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\View\JsonView</term>

          <listitem>
            <para>This view type is used to output a JSON document. You set
            its <code>_output</code> property and that's all there is to it.
            This is rarely used on its own.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\View\JsonApiView</term>

          <listitem>
            <para>This view type is used exclusively in the Api (JSON API)
            application. It's used to output data from the JSON API in JSON
            format (what else?).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\View\CategoriesView</term>

          <listitem>
            <para>This view type is used in the frontend (site) application to
            display a list of categories. You are supposed to use this if you
            are using Joomla's core categories in your component.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\View\CategoryView</term>

          <listitem>
            <para>This view type is used in the frontend (site) application to
            display a single category, typically with a list of its
            subcategories and items. You are supposed to use this if you are
            using Joomla's core categories in your component.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\View\CategoryFeedView</term>

          <listitem>
            <para>This view type is used in the frontend (site) application to
            display an RSS / Atom feed of a category's objects. You are
            supposed to use this if you are using Joomla's core categories in
            your component.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Since Joomla 4.2.0 you can use
      <code>$this-&gt;getCurrentUser()</code> in a view to get the Joomla User
      object for the currently logged in user.</para>

      <para>Since Joomla 4.0.0 you can get the Joomla event dispatcher with
      <code>$this-&gt;getDispatcher()</code> to run plugin events as explained
      <link linkend="com-controllers-basic-services">in the Controller
      documentation</link>.</para>
    </section>

    <section xml:id="com-tables">
      <title>Tables</title>

      <para>Tables, or rather Table classes, in Joomla's MVC are an
      abstraction to a row of an actual database table. They are used
      internally by Models to create new records, modify existing records and
      delete old records. It's not exactly an <link
      xlink:href="https://en.wikipedia.org/wiki/Active_record_pattern">Active
      Record</link> pattern as it does not really participate in the R (Read)
      of the <link
      xlink:href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</link>
      operations — Joomla's models query the database directly for listing
      multiple records and returning a single record. It also does not handle
      relationships. Like, at all.</para>

      <para>The logic of how Table classes work has not changed between Joomla
      3 and 4. They are namespaced and they have the familiar superclasses
      they extend from:</para>

      <variablelist>
        <varlistentry>
          <term>\Joomla\CMS\Table\Table</term>

          <listitem>
            <para>A plain old record in a database table.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\Table\Nested</term>

          <listitem>
            <para>A record in a database table which supports <link
            xlink:href="https://en.wikipedia.org/wiki/Nested_set_model">Nested
            Sets</link> (think how categories work, where categories can be
            placed under other categories and so on).</para>

            <para>The table MUST have the following columns:</para>

            <itemizedlist>
              <listitem>
                <para><code>parent_id</code>. The primary key of the parent
                node. Provides adjacency list data for nodes.</para>
              </listitem>

              <listitem>
                <para>level. The depth level of the node in the tree.</para>
              </listitem>

              <listitem>
                <para>lft. The left value of the node for managing its
                placement in the nested sets tree.</para>
              </listitem>

              <listitem>
                <para>rgt. The right value of the node for managing its
                placement in the nested sets tree.</para>
              </listitem>

              <listitem>
                <para>alias. The alias of this node used to construct the full
                text path, forward-slash delimited.</para>
              </listitem>
            </itemizedlist>

            <note>
              <para>Nested Sets are very slow when you need to add, remove,
              and reorder records. It's not necessary to use a Nested table to
              create a nested structure. In some use cases where writing is
              very common and the number of items in each nested structure
              rather limited (e.g. nested comments) it may actually be easier
              to only store the parent ID of each node and calculate the tree
              structure in PHP code. The read performance is comparable within
              a few dozen milliseconds but the write performance can be over
              100 times(!!!) faster when you have more than a couple thousand
              records.</para>

              <para>On that note, do remember that Joomla uses a Nested table
              for the <database>#__assets</database> records. Everything that
              has its own permissions such as categories, articles, banners,
              contacts, extensions, custom data types you add with an asset
              ID, etc also has a record in that table. That's why as a site
              grows in size operations against these records become
              increasingly slow.</para>

              <para>Unfortunately, this cannot be (easily) solved in Joomla;
              nested assets are a cornerstone of Joomla access control since
              version 1.6. The only real solution would be using a graph
              database which is impractical; neither MySQL nor PostgreSQL, the
              two database server technologies supported by Joomla and widely
              found on commercial hosting, have graph features (they are
              relational databases a.k.a. <link
              xlink:href="https://en.wikipedia.org/wiki/Relational_database#RDBMS">RDBMS</link>).</para>

              <para>So, if you find yourself in a situation where you need
              nested sets but can't afford the performance hit after adding
              thousands or millions of records and calculating the tree in
              memory using PHP code is impractical (and cannot be cached in a
              sensible manner) ask yourself: am I actually developing for the
              right database server and platform? Not all software can be
              written for Joomla and MySQL / PostgreSQL and that's alright. We
              are software engineers; our job is to find the right tool for
              the job and use it in the most efficient way possible to make
              something new and functional.</para>
            </note>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The rest of this section is mostly tips and tricks for using
      Tables the way Joomla intended — and even more efficiently!</para>

      <section xml:id="com-tables-get-object">
        <title>Getting the table object</title>

        <para>As noted in the <link linkend="com-mvcfactory">MVCFactory</link>
        section, you are no longer meant to instantiate Table objects using
        static method calls. You are meant to go through MVCFactory's
        <code>createTable</code> method.</para>

        <para>In the olden days we'd do something like this:</para>

        <programlisting>// Returns the Item table from com_example (ExampleTableItem)
$table = \Joomla\CMS\Table\Table::getInstance('Item', 'ExampleTable');</programlisting>

        <para>While this still works for old components written with the
        Joomla 3 MVC, it's part of the backwards compatibility with legacy
        component code and will eventually be removed. In fact, the
        <emphasis>only</emphasis> time you are supposed to use this in Joomla
        4 is when interfacing an old component which has not been migrated to
        the Joomla 4 architecture yet.</para>

        <para>For components based on the Joomla 4+ MVC this won't work at
        all! You need to go through the MVCFactory of the extension.</para>

        <para>If you are inside a Controller or Model and need to get a Table
        object instance for a Table class which belongs <emphasis>to your own
        component</emphasis> you must do:</para>

        <programlisting>/**
 * Gets a NEW table object for the Item table in the Administrator section of the component, e.g.
 * \Acme\Example\Administrator\Table\ItemTable
 */
$table = $this-&gt;getMVCFactory()-&gt;createTable('Item', 'Administrator');</programlisting>

        <para>In any other case you will need to boot the component through
        the application object to get its MVCFactory to create the table
        instance. For example:</para>

        <programlisting>// It's best to have the application object injected to your code instead of using this...
$app = \Joomla\CMS\Factory::getApplication();
// Get the table
$table = $app-&gt;bootComponent('com_example')
  -&gt;getMVCFactory()
  -&gt;createTable('Item', 'Administrator');</programlisting>

        <para>Going through the MVCFactory makes sure that the table is
        constructed correctly. Remember, as we saw <link
        linkend="com-models-push-service-joomla">in the Model section</link>,
        you can push custom services into any MVC object — including Tables —
        through a custom MVCFactory decorator. This means that the only
        forwards compatible method of getting a Table object which will always
        work is going through the MVCFactory of its component.</para>
      </section>

      <section xml:id="com-tables-check">
        <title>Customising the validation</title>

        <para>One of the many jobs of a Table object is to validate the data
        before it's written to the database. This is done in its
        <code>check()</code> method.</para>

        <para>You can override that method in your custom Table classes to add
        custom validation. At the very least you should validate the data type
        and that the data is within an accepted range of values. The latter is
        domain–specific, i.e. you need to know how your database table and
        component work to write that code. That's why Joomla doesn't offer
        much in the way of automatic data validation.</para>
      </section>

      <section xml:id="com-tables-events">
        <title>Using plugin events</title>

        <para>Table classes can call plugin events. For example, Joomla's
        default <code>Table::check()</code> implementation goes through the
        <code>onTableCheck</code> plugin event to let plugins perform
        additional data validation before data is written to the
        database.</para>

        <para>The Table superclasses offer a <code>getDispatcher()</code>
        method to get a reference to Joomla's Events Dispatcher object. As we
        noted in the <link
        linkend="com-controllers-basic-services">Controllers</link> section
        this is the preferred way to use plugins in Joomla 4 and
        beyond.</para>
      </section>

      <section xml:id="com-tables-docblocks">
        <title>Add type hints with phpDoc DocBlocks and @property</title>

        <para>The Table classes do NOT declare concrete public properties for
        most of the database table columns. Instead, they use implied public
        properties — and eventually the magic <code>__get()</code> and
        <code>__set()</code> PHP methods as PHP 9 will remove support for
        implied public properties in objects which do not extend directly from
        <code>\stdClass</code>.</para>

        <para>This means that when you get a Table object and type–hint it
        correctly, like the example below, your IDE will not offer any
        auto–completion suggestions or type hints for the database table
        columns supported by your table class.</para>

        <programlisting>/** @var \Acme\Example\Administrator\Table\ItemTable **/
$table = $this-&gt;getMVCFactory()-&gt;createTable('Item', 'Administrator');</programlisting>

        <para>I find this annoying. The whole reason we're using an IDE is so
        we don't have to remember a large number of little things, like how
        the table columns are named in every table of every table the core CMS
        or our component is using.</para>

        <para>Luckily, this is trivial to fix.</para>

        <para>Given the following table definition:</para>

        <programlisting>CREATE TABLE IF NOT EXISTS `#__example_items` (
    `id`          bigint(20) unsigned NOT NULL AUTO_INCREMENT,
    `catid`       bigint(20)          NOT NULL,
    `fromname`    varchar(255)        NOT NULL,
    `fromemail`   varchar(255)        NOT NULL DEFAULT '',
    `subject`     varchar(255)        NOT NULL DEFAULT '',
    `body`        mediumtext          NOT NULL,
    `enabled`     tinyint(3)          NOT NULL DEFAULT 1,
    `token`       char(32)                     DEFAULT NULL,
    `created_on`  datetime            NULL     DEFAULT NULL,
    `created_by`  bigint(20)          NOT NULL DEFAULT '0',
    `modified_on` datetime            NULL     DEFAULT NULL,
    `modified_by` bigint(20)          NOT NULL DEFAULT '0',
    `locked_on`   datetime            NULL     DEFAULT NULL,
    `locked_by`   bigint(20)          NOT NULL DEFAULT '0',
    PRIMARY KEY (`id`)
) ENGINE = InnoDB
  DEFAULT COLLATE = utf8mb4_unicode_ci;</programlisting>

        <para>You can add the following phpDoc DocBlock at the top of your
        class:</para>

        <programlisting>/**
 * @property int    $id            The primary key
 * @property int    $catid         The category ID, foreign key to #__categories
 * @property string $fromname      Name of the sender
 * @property string $fromemail     Email address of the sender
 * @property string $subject       Subject line of this contact item
 * @property string $body          Body text of this contact item
 * @property int    $enabled       Is it published?
 * @property string $token         Reply token
 * @property string $created_on    Date and time the record was created
 * @property int    $created_by    ID of the user who created the record
 * @property string $modified_on   Date and time the record was last modified
 * @property int    $modified_by   ID of the user who last modified the record
 * @property string $locked_on     Date and time the record was locked
 * @property int    $locked_by     ID of the user who locked the record
 */</programlisting>

        <para>Now you get full auto–completion, type hinting and inline
        documentation for your table columns. You're welcome!</para>
      </section>

      <section xml:id="com-tables-relations">
        <title>Basic relation management with getters and setters</title>

        <para>As noted earlier in this section, Joomla does not really offer a
        full implementation of the Active Record pattern — at least, not yet.
        One of the biggest omissions is relationships.</para>

        <para>Let's say that we have a helpdesk ticket system. Each support
        ticket has one or more posts. Conversely, each post has exactly one
        ticket. Posts and tickets are database tables with corresponding Table
        classes. I actually wrote such a component and found myself too often
        having to get the ticket a post belongs to, usually many times within
        the same request. Sure I can instantiate a TicketTable object and have
        it load the data off the database but if I'm doing that several times
        in a request it's slow and unhelpful. So, how about we “upgrade” our
        PostTable to return our ticket object? It's quite easy, really!</para>

        <programlisting>&lt;?php

use Acme\Example\Administrator\Table\TicketTable;

class PostTable extends \Joomla\CMS\Table\Table
{
	/**
	 * Ticket this post belongs to
	 *
	 * @var   TicketTable|null
	 */
	private $ticket;

	/**
	 * Get the ticket this post belongs to
	 *
	 * @return  TicketTable|null
	 */
	public function getTicket(): ?TicketTable
	{
		if (is_null($this-&gt;ticket))
		{
			$this-&gt;ticket = new TicketTable($this-&gt;getDbo(), $this-&gt;getDispatcher());

			if ($this-&gt;ticket-&gt;load($this-&gt;ticket_id) === false)
			{
				throw new RuntimeException('There is no such ticket');
			}
		}

		return $this-&gt;ticket;
	}

	/**
	 * Set the ticket this post belongs to.
	 *
	 * @param   TicketTable|null  $ticket  The ticket to set. NULL to make ATS reload the ticket on the next getTicket()
	 *                                     method call.
	 * @param   bool              $force   True to reset $this-&gt;ticket_id to the $ticket ID (or NULL, if no ticket).
	 *
	 * @return  self
	 */
	public function setTicket(?TicketTable $ticket, bool $force = false): self
	{
		$this-&gt;ticket = $ticket;

		if ($force)
		{
			$this-&gt;ticket_id = empty($ticket) ? null : $ticket-&gt;getId();

			return $this;
		}

		if (empty($ticket) &amp;&amp; $this-&gt;ticket-&gt;getId() != $this-&gt;ticket_id)
		{
			throw new InvalidArgumentException('Ticket ID does not correspond to the loaded post');
		}

		return $this;
	}

	/**
	 * Remember to remove the loaded relationship when resetting the table.
	 */
	public function reset()
	{
		$this-&gt;ticket = null;

		parent::reset();
	}
}</programlisting>

        <note>
          <para>I am instantiating the TicketTable directly because, in this
          case, I know I can safely do so. If my TicketTable had dependencies
          on other tables I should be going through the MVCFactory. I decided
          to keep it simple here because there's already a lot going
          on.</para>
        </note>

        <para>The idea can be broken down in the following steps:</para>

        <itemizedlist>
          <listitem>
            <para>Create a private property to hold our related object, in
            this case the ticket the post belongs to.</para>
          </listitem>

          <listitem>
            <para>Reset that property back to NULL in the <code>reset()</code>
            method.</para>
          </listitem>

          <listitem>
            <para>Create a setter which sets the relationship <emphasis>if and
            only if</emphasis> the TicketTable object we're passing matches
            the post table's <code>ticket_id</code> column value. The setter
            is optional; it makes it easier for us when creating both a new
            post and a new ticket i.e. when a client submits a new helpdesk
            item.</para>
          </listitem>

          <listitem>
            <para>Create a getter which returns the already saved relationship
            object. If none is specified, we load it from the database.</para>
          </listitem>
        </itemizedlist>

        <para>This is very naive, late–bound relationship handling (lazy
        loading) but it's better than nothing.</para>

        <para>If you'd like to do eager relationship loading (when loading a
        big list of posts) you'd have to implement it yourself. For starters,
        you'd need something like that in your PostTable:</para>

        <programlisting>	/**
	 * @param   self[]  $postTables
	 */
	public function eagerLoad(array &amp;$postTables): void
	{
		// Get the unique ticket IDs 
		$ticketIDs = array_map(
			function (PostTable $x) {
				return $x-&gt;ticket_id;
			},
			$postTables
		);
		$ticketIDs = array_unique($ticketIDs);

		// Get the raw ticket data, keyed by ticket ID
		$db = $this-&gt;getDbo();
		$query = $db-&gt;getQuery(true)
			-&gt;select('*')
			-&gt;from('#__example_tickets')
			-&gt;whereIn($db-&gt;quoteName('id'), $ticketIDs);
		$tickets = $db-&gt;setQuery($query)-&gt;loadObjectList('id') ?: [];

		// Convert the raw ticket data into TicketTable objects
		$tickets = array_map(
			function (object $rawData): TicketTable
			{
				$ticket = new TicketTable($this-&gt;getDbo(), $this-&gt;getDispatcher());
				$ticket-&gt;bind($rawData);

				return $ticket;
			},
			$tickets
		);
		
		// Set the TicketTable objects to each PostTable object
		foreach ($postTables as $postTable)
		{
			$postTable-&gt;setTicket($tickets[$postTable-&gt;ticket_id]);
		}
	}
</programlisting>

        <para>Now, whenever you write code which returns an array of PostTable
        objects just run the resulting through that method and it set the
        related TicketObject instances to each member of the array of
        PostTable objects.</para>

        <para>Why do eager loading? With eager loading you only need 2
        queries: one to get the list of posts data, one to get the list of
        tickets data. With lazy loading you'd need N + 1 database queries: one
        to get the list of posts data, one per post (N queries in total) to
        get each post's ticket data.</para>

        <para>Eager loading only makes sense if you are going to process a
        large number of records all at once and you are definitely going to
        need access to their related objects.</para>
      </section>

      <section xml:id="com-tables-assets">
        <title>Asset management</title>

        <para>In some cases you want your database records to have a special
        set of permissions which can override those set for the entire
        component in its Options. This is especially important if you are
        using the Joomla Categories, in which case your items may belong to a
        category, which belongs in another category, which belongs in another
        category… This cascading of permissions is made easy with Joomla's
        assets management.</para>

        <para>To enabled assets management in your table you need to have an
        <code>asset_id</code> column in your database table. This sets
        <code>$this-&gt;_trackAssets = true</code> when your table object is
        constructed (no need to do it manually).</para>

        <para>Moreover, you MAY have to override the
        _<code>getAssetParentId</code>, <code>_getAssetName</code> and
        <code>_getAssetTitle</code> methods if your items described by this
        table class belong in categories. Look at
        <code>\Joomla\CMS\Table\Content</code> to understand what is going
        on.</para>

        <para>Finally, your <code>bind()</code> method needs to be overwritten
        so you can call the <code>$this-&gt;setRules()</code> method against
        the raw, JSON–encoded permissions data stored in the database table.
        Saving rules is automatic; you don't have to handle it
        yourself.</para>
      </section>

      <section xml:id="com-tables-arrays-and-json">
        <title>Working with arrays and JSON data</title>

        <para>Sometimes you need to work with arrays of values or data which
        is stored as JSON but needs to be accessed as an object or array.
        Don't worry, this is possible with Joomla's Table class, albeit not
        immediately obvious.</para>

        <para>Let's say you want to work with array data in a column called
        <database>params</database>, stored in the database as a JSON-encoded
        string. You will need to think about three things:</para>

        <itemizedlist>
          <listitem>
            <para>Resetting a table. By default, Joomla uses the default value
            you have for the same named column in your database table. You
            want to change that to an empty array.</para>
          </listitem>

          <listitem>
            <para>Binding data. When Joomla loads a record and when we call
            the table object's <code>save()</code> method to create or modify
            a record, Joomla always calls the <code>bind()</code> method to
            set up the object's properties in way which makes sense for use in
            the code. In there we will need to convert our encoded field into
            an array.</para>
          </listitem>

          <listitem>
            <para>Storing data. The store() method needs the data in the
            record to be in a format which can be stored in the database table
            as–is. The plan here is to convert the array data to JSON before
            this method executes and convert out data back to array data right
            before this method returns.</para>
          </listitem>
        </itemizedlist>

        <programlisting>class ItemTable extends \Joomla\CMS\Table\Table
{
	public function bind($src, $ignore = [])
	{
		$src           = (array) $src;
		$src['params'] = @json_decode($src['params']);

		return parent::bind($src, $ignore);
	}

	public function store($updateNulls = false)
	{
		$this-&gt;params = @json_decode($this-&gt;params ?? '{}', true) ?? [];

		$result = parent::store($updateNulls);

		$this-&gt;params = @json_encode($this-&gt;params) ?? '{}';

		return $result;
	}

	public function reset()
	{
		parent::reset();

		$this-&gt;params = [];
	}
}</programlisting>

        <para>Nothing stops you from using a
        <code>\Joomla\Registry\Registry</code> object instead of a plain
        array; in fact, it may be easier to manage. You may also have multiple
        fields in need of this kind of conversion.</para>

        <para>Another practical example is multi-select form fields, e.g.
        selecting one or more usergroups. The resulting array of integers can
        be easily converted to a comma–separated string for saving in the
        database.</para>
      </section>
    </section>

    <section xml:id="com-html">
      <title>HTML helper service</title>

      <para>Joomla has long provided a mechanism for creating your own HTML
      helper classes. These are meant to provide relatively short methods
      which return HTML snippets based on data which requires more than a line
      or two of PHP code to be processed and/or is called frequently enough
      throughout your component that it makes no sense having to the same
      thing over and over again. For example, you could have methods which
      return item associations, format dates, load a layout for presenting
      user information in backend grid views etc.</para>

      <para>Joomla 4 continues to offer this possibility and further enhances
      it. Your key take–aways are:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Joomla 4 HTML helpers are services
          registered through your extension class</emphasis> instead of pure
          static classes which had to be registered with
          <code>\Joomla\CMS\HTML\HTMLHelper::addIncludePath</code>.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Joomla 4 HTML helpers have non–static
          methods</emphasis> whereas Joomla 3 HTML helpers had static
          methods.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">In Joomla 4 you can register whichever
          prefix you want</emphasis>, not necessarily the same as the name of
          the class(es) providing your HTML helper service(s).</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">You still call your HTML helpers through
          the <code>\Joomla\CMS\HTML\HTMLHelper::_()</code>
          method</emphasis>.</para>
        </listitem>
      </itemizedlist>

      <bridgehead>How we did things in Joomla 3</bridgehead>

      <para>Back in Joomla 3 we'd create a class file in our
      <filename>helpers/html</filename> folder, e.g.
      <filename>administrator/components/helpers/html/example.php</filename>.
      It would contain a pure static class with a name starting with
      <code>JHtml</code>, e.g <code>JHtmlExample</code>. Here's a trivial
      example:</para>

      <programlisting>&lt;?php

class JHtmlExample {
  public static function hello($who) {
    $who = htmlspecialchars($who);
    return "&lt;p&gt;Hello, {$who}!&lt;/p&gt;";
  }
}</programlisting>

      <para>Within our component the helper was automatically registered and
      we could use it like this:</para>

      <programlisting>&lt;?php echo \Joomla\CMS\HTML\HTMLHelper::_('example.hello', 'world') ?&gt;</programlisting>

      <para>This would result in</para>

      <screen>&lt;p&gt;Hello, world!&lt;/p&gt;</screen>

      <para>Outside our component we'd have to remember to register this
      helper manually:</para>

      <programlisting>\Joomla\CMS\HTML\HTMLHelper::addIncludePath(JPATH_ADMINISTRATOR . 
  '/components/com_example/helpers/html');</programlisting>

      <para>When we forgot to do that, e.g. in a module of ours? Hilarity
      ensued…</para>

      <para>This approach also had other problems. What if there are two
      helpers, one of ours and one of another component, using the same class
      name? PHP Fatal Error! What happens if we use a name for our helper
      which “shades” a name used by Joomla itself? We break things! What
      happens if the service we need to use is not available as a static
      method? Ugly workarounds! Generally speaking, it was a bad idea but,
      like most things in older versions of Joomla, was better than nothing
      which made it good enough.</para>

      <bridgehead>The way to do it in Joomla 4</bridgehead>

      <para>In Joomla 4 we will create a <emphasis>service</emphasis>. It
      sounds big and scary but... let me tell you a secret. We are just going
      to create a regular PHP class. It does not extend from anything, it does
      not have any special requirements. That's right, we are writing the
      simplest possible PHP class.</para>

      <programlisting>&lt;?php
namespace Acme\Example\Administrator\Service\Html;

class Example {
  public function hello($who) {
    $who = htmlspecialchars($who);
    return "&lt;p&gt;Hello, {$who}!&lt;/p&gt;";
  }
}</programlisting>

      <para>Now we can instantiate it in our component's extension class's
      boot method.</para>

      <programlisting>&lt;?php
namespace Acme\Example\Administrator\Extension;

class Example extends MVCComponent implements BootableExtensionInterface {
	public function boot(ContainerInterface $container)
	{
		$this-&gt;getRegistry()-&gt;register('ats', new ATS());
	}  
}</programlisting>

      <bridgehead>Pushing services</bridgehead>

      <para>In the Joomla 3 paradigm the HTML helper class was static, meaning
      that any services it needs would have to be fetched with static or
      otherwise global calls as well. For example, getting the database driver
      object would require doing <code>\Joomla\CMS\Factory::getDbo()</code>.
      In Joomla 4 this kind of static calls is deprecated. So, how do you do
      it?</para>

      <para>The trick is that you can push services using the HTML helper
      class's constructor. For example, pushing the database:</para>

      <para><programlisting>&lt;?php
namespace Acme\Example\Administrator\Service\Html;

class Example {
  <emphasis role="bold">private $db;</emphasis>

  <emphasis role="bold">public function __construct(\Joomla\Database\DatabaseDriver $dn) {
    $this-&gt;db = $db;
  }</emphasis>

  public function hello($who) {
    $who = htmlspecialchars($who);
    return "&lt;p&gt;Hello, {$who}!&lt;/p&gt;";
  }
}</programlisting>We also need to change the initialisation of our HTML
      service:</para>

      <programlisting>&lt;?php
namespace Acme\Example\Administrator\Extension;

class Example extends MVCComponent implements BootableExtensionInterface {
	public function boot(ContainerInterface $container)
	{
		<emphasis role="bold">$db = $container-&gt;get('DatabaseDriver');</emphasis>
		$this-&gt;getRegistry()-&gt;register('ats', new ATS(<emphasis role="bold">$db</emphasis>));
	}  
}</programlisting>

      <para>You can push any service, including your component's MVCFactory
      service which means that you can get instances of any Model of your
      component to retrieve database data in your HTML helper. Or, maybe,
      Joomla's UserFactory service so you can create instances of any user
      given their ID or username to get and present information about them.
      You get the idea!</para>
    </section>

    <section xml:id="com-categories">
      <title>Categories</title>

      <para>Sometimes your components may need to use Joomla's Categories
      feature. I am not talking about using content categories, where articles
      are placed in. I am talking about having Joomla manage categories for
      your own items. This is what Joomla itself is doing for its core
      components like Contacts and Banners.</para>

      <para>Using Joomla's categories instead of inventing your own
      categorisation has many benefits. The obvious benefit is that users are
      exposed to a familiar and consistent category management interface.
      Beyond the obvious, this is the only way you can have nice things such
      as <link linkend="com-fields">integration with custom
      fields</link>.</para>

      <section xml:id="com-categories-db">
        <title>Database schema changes</title>

        <para>Your table which contains the <emphasis>items</emphasis> which
        go into each category needs to have a few columns:</para>

        <programlisting>`id`          BIGINT(20)    NOT NULL AUTO_INCREMENT COMMENT 'Item unique ID',
`catid`       BIGINT(20)    NOT NULL COMMENT 'Category ID',
`state`       TINYINT(3)    NOT NULL DEFAULT '1' COMMENT 'Publish status',</programlisting>

        <para>These fields don't necessarily need to have these names; we can
        change them in the code. However, these column names are the default
        used in Joomla and it makes it easier for you to follow third party
        tutorials and for other people to follow what you are doing with your
        code.</para>
      </section>

      <section xml:id="com-categories-manifest">
        <title>Changes to your XML manifest and forms</title>

        <para>A lot of this integration is, in fact, smoke and mirrors. Users
        are taken to the core <code>com_categories</code> component to manage
        categories. <code>com_categories</code> uses a form in our component,
        in the file
        <filename>administrator/components/<replaceable>com_example</replaceable>/forms/category.xml</filename>
        where <replaceable>com_example</replaceable> is our component, to add
        sections to the category configuration beyond the standard Joomla
        stuff. The way Joomla's main menu works along with a small change in
        our XML manifest will make the user think they are still in our
        component while they are using Joomla's com_categories.</para>

        <para>For the user to have a way to manage categories and maintain the
        illusion they remain in our extension you have to add the following
        code in your XML manifest under &lt;extension&gt;,
        &lt;administration&gt;, &lt;submenu&gt;:</para>

        <programlisting>&lt;menu link="option=com_categories&amp;amp;extension=<replaceable>com_example</replaceable>"&gt;JCATEGORIES&lt;/menu&gt;</programlisting>

        <para>where <replaceable>com_example</replaceable> is the name of your
        component.</para>

        <para>By default, you'll get a rather barren category edit page with
        just the bare minimum of information Joomla needs to store about a
        category (a title, alias and description are required — you can't hide
        them or remove them in any way). The basic tabs you get in the
        category editor are Category, Options, Publishing, Fields (if any
        custom Fields are set up for the category) and Permissions.</para>

        <para>You can display additional tabs with component–specific
        configuration options by creating the file
        <filename>administrator/components/<replaceable>com_example</replaceable>/forms/category.xml</filename>
        where <replaceable>com_example</replaceable> is the name of your
        component. This is a regular Joomla XML form file. Just remember,
        every <code>&lt;fieldset&gt;</code> you add becomes a tab in the
        Category edit page. Neat, huh?</para>
      </section>

      <section xml:id="com-categories-service">
        <title>The Category service</title>

        <para>Categories are great and all, but if you need to get their
        parameters or create SEF routes for nested categories you need to
        somehow get information on categories. This is what the category
        service does for us.</para>

        <para>It is customary — or at least I have not found a concrete reason
        to not be able to do otherwise — that the Category Service is created
        in the <emphasis>frontend</emphasis> part of your site.</para>

        <para>Assuming our <code>com_example</code> component with the
        namespace prefix <code>Acme\Example</code>, you need to create the
        class <classname>Acme\Example\Site\Service\Category</classname> in the
        file
        <filename>components/com_example/src/Service/Category.php</filename>
        like this:</para>

        <programlisting>&lt;?php

namespace Acme\Example\Site\Service;

defined('_JEXEC') or die;

use Joomla\CMS\Categories\Categories;

class Category extends Categories
{
	public function __construct($options)
	{
		$options = array_merge($options, [
			'extension'  =&gt; 'com_example',
			'table'      =&gt; '#__example_items',
			'field'      =&gt; 'catid',
			'key'        =&gt; 'id',
			'statefield' =&gt; 'state',
		]);

		parent::__construct($options);
	}

}</programlisting>

        <para>The array in the <methodname>__construct</methodname> method is
        all you need to customise and it's fairly self–explanatory.</para>

        <variablelist>
          <varlistentry>
            <term>extension</term>

            <listitem>
              <para>The name of your component e.g.
              <code>com_example</code>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>table</term>

            <listitem>
              <para>The name of the table holding the category
              <emphasis>items</emphasis>. As customary in Joomla you use
              <database>#__</database> to denote the common table name
              prefix.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>field</term>

            <listitem>
              <para>The name of the database column which contains the numeric
              category ID. The default is <code>catid</code>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>key</term>

            <listitem>
              <para>The name of the database column which contains the item's
              primary key. The default is <code>id</code>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>statefield</term>

            <listitem>
              <para>The name of the database column which contains the item's
              publish state. The default is <code>state</code>.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Now you see why I told you to use the database table field names
        customarily used by Joomla; they minimise the code you need to write
        down to two array keys: <code>extension</code> and
        <code>table</code>.</para>

        <para>Unlike other services provided by your component, the category
        service is instantiated directly:</para>

        <programlisting>$catService = new Acme\Example\Site\Service\Category([]);</programlisting>

        <para>The array in the constructor arguments is not just for show. It
        can help you narrow down the list of categories to be returned with
        the following keys:</para>

        <variablelist>
          <varlistentry>
            <term>access</term>

            <listitem>
              <para>Boolean. When true, Joomla will only return the categories
              visible to the current user. It does that by only getting from
              the database the categories whole <database>access</database>
              field is one of the Joomla viewing access levels the current
              user has access to.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>published</term>

            <listitem>
              <para>Integer 0 or 1. When it's 1 it will only return categories
              which are published. When 0 it will return published,
              unpublished <emphasis>and trashed</emphasis> categories.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>countItems</term>

            <listitem>
              <para>Integer 0 or 1. Note the weird capitalisation in the
              middle of this key's name! When it's 1, Joomla will return the
              number of items contained in each category at the expense of
              performance. Use this sparingly and only when you absolutely
              need it e.g. when displaying paginated views.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Also keep in mind that Joomla tries to be smart. A bit
        <emphasis>too</emphasis> smart, maybe. When you are on a multilingual
        site it will only return categories whose language is either the
        currently selected language or “All” (denoted by a <code>*</code> in
        the language column of the <database>#__categories</database> table).
        If you want to override this behaviour you will need to change your
        Categories Service constructor like so:</para>

        <programlisting>	public function __construct($options)
	{
		$options = array_merge($options, [
			'extension'  =&gt; 'com_example',
			'table'      =&gt; '#__example_items',
			'field'      =&gt; 'catid',
			'key'        =&gt; 'id',
			'statefield' =&gt; 'state',
		]);

		parent::__construct($options);

		$this-&gt;_options['currentlang'] = $options['currentlang'] ?? $this-&gt;_options['currentlang'];
	}</programlisting>

        <para>If you want the instance of the Categories Service to return all
        categories regardless of the current language in a multilingual site
        you can now do:</para>

        <programlisting>$catService = new Acme\Example\Site\Service\Category([
  'currentlang' =&gt; 0
]);</programlisting>
      </section>
    </section>

    <section xml:id="com-router">
      <title>Router</title>

      <para>Most components have a backend and a frontend part. The backend
      part is used by the site administrators to set up the content being
      managed by the component and the frontend part is used to display said
      content to the visitors of the site.</para>

      <section xml:id="com-router-routing-overview">
        <title>The case for URL routing</title>

        <para>By default, Joomla's frontend URLs look something like
        this:</para>

        <para><uri>https://www.example.com/index.php?option=com_example&amp;view=item&amp;id=123&amp;Itemid=456</uri></para>

        <para>This is called a regular or non-SEF URL. The SEF URL — what
        other CMS may call a “permalink” or a “<emphasis>route</emphasis>” —
        could be something like</para>

        <para><uri>https://www.example.com/acme-shop/roadrunner-hunting/explosives/tnt-crate.html</uri></para>

        <note>
          <para><acronym>SEF</acronym> is an acronym which stands for Search
          Engine Friendly and is called like that for historical reasons —
          back in 2001 when Joomla's predecessor, Mambo, introduced this
          feature a human-understandable URL was also helping the primitive
          search engines of that era to get better context of what the page is
          about. This stopped being true by the time Joomla emerged as its own
          software, in 2005.</para>

          <para>Joomla co–founder Brian Teeman coined a better, if not much
          more British, term: Pub Ear Friendly. The idea being that when you
          try to give the URL of a page to your mate while downing pints at
          your local, rather lively, local it's easier to give them a few
          words they can understand than a long string of alphanumeric
          characters. For some reason this alternate term never stuck…</para>
        </note>

        <para>The transformation of the ugly, incomprehensible (at least to
        non–developers), non-SEF URL into the SEF URL and of the SEF URL back
        to the ugly non-SEF version (so Joomla can figure out which component
        to load and what to tell it to do) is called <emphasis role="bold">SEF
        routing</emphasis> in the Joomla vernacular. Most everywhere else you
        will see it being called <emphasis role="bold">URL routing</emphasis>.
        Well, the Joomla vernacular is full of certain historical quirks which
        makes it harder for newcomers to figure out what is what, but this is
        neither here nor there.</para>

        <para>URL routing in Joomla is implemented in the core. However, the
        core code cannot <emphasis>possibly</emphasis> know how your component
        is supposed to logically structure its content so as to convert this
        into a human and machine understandable URL. Therefore it delegates
        that responsibility to the component, namely to our component's
        Router.</para>
      </section>

      <section xml:id="com-router-abandon-all-hope">
        <title>Intermission: abandon all hope ye who enter here</title>

        <para>Before we go on, let's discuss a little bit how Joomla URL
        routing works. It's long, it's a bit depressing, but read to the end —
        as you'll see, all problems with the URL routing in Joomla are
        ultimately <emphasis role="bold">a user education issue</emphasis>,
        not a coding issue.</para>

        <para>You would expect web software to have have absolutely
        deterministic, clear routing for URLs. Given a set of URL parameters
        (the “non-SEF URL”) the URL router (“SEF router”) will spit out the
        same route (“SEF URL”). In this ideal world we already have nuclear
        fusion and world peace, we have solved poverty and hunger and… I
        digress.</para>

        <para>In the imperfect world we live in, web software has to choose
        one of two evils. URL routing is either extremely technical and
        inflexible but robust, or it is is user–friendly and flexible but can
        result in some very weird situations. Joomla chose the latter. It's
        what allows modules to work the way they do which is one of the many
        reasons Joomla is an insanely powerful but still user–friendly CMS.
        But which part of its soul did it have to sell to you–know–who to do
        that? Let's see…</para>

        <para>URL routing in Joomla operates in two axes. On one hand we have
        the user–defined menu structure which operates as the first pass of
        URL routing and is defined by users, who are humans and not very good
        at managing hierarchies (make that
        <emphasis>doubleplusungood</emphasis>, Winston). Then you have the SEF
        router of our component which, unlike users, works in a perfectly
        logical, orderly fashion.</para>

        <para>The thing is, they are both working at the same time to do URL
        routing and this can cause some… uh…
        <emphasis>complications</emphasis>.</para>

        <para>Let's say you have the following data hierarchy:</para>

        <itemizedlist>
          <listitem>
            <para>Category A, alias <code>alpha</code>.</para>

            <itemizedlist>
              <listitem>
                <para>Category B, alias <code>bravo</code>.</para>

                <itemizedlist>
                  <listitem>
                    <para>Article C, alias <code>charlie</code></para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>And you have the following menu structure (as to why the user
        chose this seemingly bonkers menu structure, no, they are not trying
        to sabotage your code, they have a good reason but we'll get back to
        that later):</para>

        <itemizedlist>
          <listitem>
            <para>Category item list for Category B, alias <code>bravo</code>.
            Item ID 123.</para>

            <itemizedlist>
              <listitem>
                <para>Single article view for Article C, alias
                <code>charlie</code>. Item ID 234.</para>

                <itemizedlist>
                  <listitem>
                    <para>Category A, alias <code>alpha</code>. Item ID
                    345.</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>You would expect that the URL for category A is
        https://www.example.com/alpha, category B's is
        https://www.example.com/alpha/bravo and article C's is
        https://www.example.com/alpha/bravo/charlie.</para>

        <para>Nope.</para>

        <para>The URL for category A is
        <uri>https://www.example.com/bravo/charlie/alpha</uri> per the menu
        structure.</para>

        <para>The URL for category B is
        <uri>https://www.example.com/bravo</uri> per the menu
        structure.</para>

        <para>The URL for article C is
        <uri>https://www.example.com/bravo/charlie</uri> per BOTH the menu
        structure AND the SEF router of com_content.</para>

        <para>However, it's perfectly possible to access article C as
        https://www.example.com/bravo/charlie/alpha/charlie. The first three
        parts of the route (/bravo/charlie/alpha) are the menu structure to
        category A. The rest (bravo/charlie) is handled by the SEF router of
        com_content.</para>

        <para>*record scratch*</para>

        <para>But, wait, wait a second! How does Joomla know when to use each
        URL?! I am glad you asked, the answer is the <code>Itemid</code> URL
        parameter, i.e. the menu item ID for which we are going to be
        generating a URL for our… something!</para>

        <para>If we are routing the URL to article C using a URL with
        Itemid=123 Joomla will first figure out that we have a menu item to
        Article C's parent category (Category B). It will then ask our URL
        router to route this item in this category which will make our
        com_content router return <code>charlie</code>. Therefore Joomla will
        return the relative URL <code>bravo/charlie</code>.</para>

        <para>If we are routing the URL to article C using a URL with
        Itemid=234 Joomla sees that the Itemid matches exactly what we need to
        route, therefore it will return the menu structure up to this point,
        i.e. the relative URL <code>bravo/charlie</code>.</para>

        <para>HOLD ON A SECOND! Both of these methods returned… THE SAME URL!
        Ah, keen eyed reader, you are right! I can see you despairing. Oh,
        please, not yet! It's about to get <emphasis>worse</emphasis>. You
        see, when Joomla parses the URL it prioritises the menu structure over
        the SEF router of each component. Since <code>bravo/charlie</code> is,
        indeed, a valid menu structure it will simply return the non-SEF URL
        index.php?Itemid=234 — in both cases.</para>

        <para>But, but, but… Isn't the Itemid how we tell modules when to
        display? Why, yes, it is! Oh, you had different modules displaying in
        menu items 123 and 234? Too bad! You don't get to choose.
        Sorry.</para>

        <para>Back to routing non-SEF to SEF URLs. If you route article C
        using a URL with Itemid=345 Joomla tells you that you are on category
        A. So your SEF route has to find a full path to your article which
        would be bravo/charlie and this is added to Category A, menu item
        345's URL of bravo/charlie/alpha to make the entirely confusing URL
        bravo/charlie/alpha/bravo/charlie which works perfectly.</para>

        <para>What about trying to route article C without an Itemid? Now
        things get a bit tastier and testier. Joomla will try to find the most
        relevant route using the segments returned by your SEF router and
        trying to match them with the menu structure… Which one it is?
        Frankly, I don't have the foggiest off the top of my head. I'd have to
        build that site to figure it out. I would think it's the same as using
        Itemid=345. If all else fails, Joomla will use the Home item's Itemid
        and all bets are off.</para>

        <para>Of course, this means that the same article can have three URLs,
        two of which are identical and one of them does not resolve to what
        you'd expect. But this is normal! And no, forget about getting a
        canonical URL for article C because there's none.</para>

        <para>This insanity cannot be addressed because it would require
        decoupling URL routing from Joomla's menu system. However, this would
        mean that all published modules appear in all pages as there is no
        longer a way to know which menu item you're in. Of course it's the
        solution to this problem which broke module display in our example
        above but this is what you get when the users are “crazy”.</para>

        <para>Or are they?</para>

        <para>While it sounds convoluted and problematic, this method is not
        the least bit more convoluted and problematic than any other given CMS
        <emphasis>when you take into account all the possible<footnote>
            <para>For any given, singular use case and a set of routing
            algorithms it is very easy to find the one algorithm which is most
            suitable, meaning the rest are unsuitable. However, every single
            use case has a different most suitable algorithm. Given a very
            large number of use cases, like the near infinite uses cases a CMS
            is called to address, any given routing algorithm would be just as
            unsuitable for most use cases as every other. Therefore the task
            of finding the “best” algorithm is reduced to finding an algorithm
            which fulfils some secondary or tertiary business goals such as
            making it possible for an end user to easily configure with a GUI
            or support our vision of having different modules show up in each
            page. The primary business goal of the “best” routing for the
            generic use case is, by definition, a bust unless we are willing
            to drastically reduce the use cases we are willing to
            support.</para>
          </footnote>, almost infinite use cases it's called to work
        with</emphasis>. It works great insofar the user can be trusted to not
        create psychopathic menu structures which work against the data
        structure, reusing the same aliases for a good measure of
        insanity.</para>

        <para>But why would any user even create such a menu structure to
        begin with?!</para>

        <para>As a matter of fact, the menu structure I presented <emphasis
        role="bold">is the wrong way to use Joomla</emphasis>. I confess I
        misdirected you but I did so for a noble reason. What the user most
        likely wanted was the menu item's <emphasis>visual</emphasis>
        structure to be what we presented for user experience reasons. They
        most likely don't care or not even <emphasis>want</emphasis> the crazy
        URL structure. They would very likely be spending hundreds of Euros
        every year in various SEF / SEO tools to try and fix their mistake…
        when they could just be told how to use Joomla the way Joomla was
        intended to be used to begin with.</para>

        <para>The One True Joomla Way™ is to use a “hidden” menu (a menu
        without a module to display it) to generate the URL structure in a way
        that's mostly following the data structure and a shown menu with Alias
        menu items for the visual display.</para>

        <para>So, in our example, the hidden menu would be:</para>

        <itemizedlist>
          <listitem>
            <para>Category A, alias <code>alpha</code>. Item ID 345.</para>

            <itemizedlist>
              <listitem>
                <para>Category item list for Category B, alias
                <code>bravo</code>. Item ID 123.</para>

                <itemizedlist>
                  <listitem>
                    <para>Single article view for Article C, alias
                    <code>charlie</code>. Item ID 234.</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>And the visible menu:</para>

        <itemizedlist>
          <listitem>
            <para>Category item list for Category B, alias to menu item
            123.</para>

            <itemizedlist>
              <listitem>
                <para>Single article view for Article C, alias to menu item
                234.</para>

                <itemizedlist>
                  <listitem>
                    <para>Category A, alias <code>alpha</code>, alias to menu
                    item 345.</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>That's the reason I went through this intentionally
        provocatively named section. When you are doing end user support you
        <emphasis role="bold">WILL</emphasis> come up with the atrocious menu
        structures like the one I presented above.</para>

        <para>Do NOT try to address this in your router code; you will lose
        your mind and you will never make it work for all of your users.
        Remember, there is no routing method which is suitable for every use
        case and you cannot possibly address infinite use cases. Value your
        sanity as a developer! Learn when to say “no” to users.</para>

        <para>Instead, ask your user what is their <emphasis>use
        case</emphasis> and is <emphasis>their intention</emphasis> with their
        menu structure: are they trying to shape the URL structure or just the
        way things are presented on their site? In 99 out of 100 cases the
        user intended to affect only the visual presentation of the menu; they
        have no idea they are shooting their feet by affecting the URL
        structure. Patiently explain them the trick about hidden menus. You'll
        get grateful clients for life.</para>
      </section>

      <section xml:id="com-router-j3-vs-j4">
        <title>Joomla 3 vs Joomla 4</title>

        <para>In Joomla 3 we would create a router as a
        <filename>router.php</filename> file in the root of our component's
        frontend, e.g. <filename>components/com_example/router.php</filename>.
        That file had two way to implement a router:</para>

        <itemizedlist>
          <listitem>
            <para>Two separate functions whose names consisted of the name of
            the component without the <code>com_</code> prefix and the
            suffixes <code>BuildRoute</code> and <code>ParseRoute</code>, e.g.
            <function>exampleBuildRoute</function> and
            <function>exampleParseRoute</function>. This was the very old way
            which was deprecated since Joomla 3.3 released in 2014.</para>
          </listitem>

          <listitem>
            <para>As a class extending
            <classname>JComponentRouterBase</classname> (renamed to
            <classname>Joomla\CMS\Component\Router\RouterBase</classname> in
            later Joomla versions) or, more usually,
            <classname>JComponentRouterView</classname> (introduced in Joomla
            3.5 and renamed to
            <classname>Joomla\CMS\Component\Router\RouterView</classname> in
            later Joomla versions).</para>
          </listitem>
        </itemizedlist>

        <para>If you are using the former method you have a lot of work ahead
        of you to convert it to a Joomla 4 compatible router. If you are using
        the latter method you are virtually ready, with minimal
        changes!</para>

        <para>In Joomla 4 the router is implemented as the class
        <code>Service\Router</code> in the frontend part of our component. So,
        with a component <code>com_example</code> that has a namespace prefix
        <code>Acme\Example</code> that would be the class
        <classname>Acme\Example\Site\Service\Router</classname> in the file
        <filename>components/com_example/src/Service/Router.php</filename>.
        That class needs to extend from
        <classname>Joomla\CMS\Component\Router\RouterBase</classname> or, more
        typically
        <classname>Joomla\CMS\Component\Router\RouterView</classname>, just
        like in Joomla 3.5<footnote>
            <para>The entire concept of routing using the RouterView has not
            changed since Joomla 3.5 which was released in 2016. You see, at
            this point in time development of Joomla 4 had already started and
            Joomla introduced the new routing to help developers migrate their
            extensions to the new router before Joomla 4 is released.</para>
          </footnote> and later versions.</para>

        <para>There is one more difference in Joomla 4 and later versions. By
        default, the component does not know that it needs to use a
        router.</para>

        <para>To understand what and why we need to do, let's go backwards.
        Joomla only knows it needs to use a router factory when the
        component's extension class implements the
        <interfacename>\Joomla\CMS\Component\Router\RouterServiceInterface</interfacename>.
        When this is the case, Joomla knows that it can ask the extension
        class to return a Router Factory object using the
        <methodname>createRouter</methodname> method defined in said
        interface. The component's extension class does not know how to find
        the router factory object; it is injected into it by the component
        service provider (<filename>services/provider.php</filename>). In its
        turn, it asks the component's DI Container for that Router Factory
        object. The DI Container will only know how to get a Router Factory
        object is we register a Router Factory service provider in the service
        provider (<filename>services/provider.php</filename>).</para>

        <para>Unraveling these chained dependencies we see that we need to
        make changes in just two files.</para>

        <para>Your component's extension class must implement the
        <interfacename>\Joomla\CMS\Component\Router\RouterServiceInterface</interfacename>
        interface. The easiest way to provide its implementation is having it
        use the
        <classname>\Joomla\CMS\Component\Router\RouterServiceTrait</classname>
        trait.</para>

        <para>That trait requires your component service provider (e.g.
        <filename>administrator/components/com_example/services/provider.php</filename>)
        to do two things. First, it needs to register a Router Factory service
        provider before trying to create the component object:</para>

        <programlisting>$container-&gt;registerServiceProvider(
  new \Joomla\CMS\Extension\Service\Provider\RouterFactory
  (
    '\\Acme\\Example'
  )
);</programlisting>

        <para>The
        <classname>\Joomla\CMS\Extension\Service\Provider\RouterFactory</classname>
        class is the default Joomla implementation of a component router
        factory. It needs exactly one configuration parameter in its
        constructor, the namespace of your component
        <emphasis>without</emphasis> the <code>Site</code> or
        <code>Administrator</code> suffix.</para>

        <para>Then, after having created our component extension class'
        object, we need to inject the Router Factory object into it:</para>

        <programlisting>$container-&gt;set(
  ComponentInterface::class,
  function (Container $container) {
    $component = new ExampleComponent(
      $container-&gt;get(ComponentDispatcherFactoryInterface::class)
    );

    // ... other initialisation goes here ...

    // Inject the router factory object
    <emphasis role="bold">$component-&gt;setRouterFactory(
      $container-&gt;get(
         \Joomla\CMS\Component\Router\RouterFactoryInterface::class
      )
    );</emphasis>
   }
);</programlisting>

        <para>While it looks a bit verbose, it accomplishes two things. First,
        it's not possible to be surprised by Joomla magically implementing a
        feature in your component you did not expect. Second, in the case of a
        router, it allows us to <link
        linkend="com-router-push-dependencies">push dependencies (services)
        into our router object</link>.</para>
      </section>

      <section xml:id="com-router-routerview">
        <title>Using RouterView</title>

        <para>If you are using a router class extending from
        <classname>Joomla\CMS\Component\Router\RouterView</classname> it is
        fairly easy to create a router for most components.</para>

        <para>The constructor of your class tells Joomla which views of your
        component can be routed in the frontend and the relation to each
        other. For example:</para>

        <programlisting>public function __construct(SiteApplication $app = null, AbstractMenu $menu = null)
{
  $welcome = new \Joomla\CMS\Component\Router\RouterViewConfiguration('welcome');
  $this-&gt;registerView($welcome);

  $item = (new \Joomla\CMS\Component\Router\RouterViewConfiguration('item'))
    -&gt;setKey('id')
    -&gt;addLayout('default')
    -&gt;addLayout('fancy');
  $this-&gt;registerView($item);

  $detail = (new \Joomla\CMS\Component\Router\RouterViewConfiguration('detail'))
    -&gt;setKey('id')
    -&gt;setParent($item, 'itemid');
  $this-&gt;registerView($detail);

  parent::__construct($app, $menu);

  $this-&gt;attachRule(new \Joomla\CMS\Component\Router\Rules\MenuRules($this));
  $this-&gt;attachRule(new \Joomla\CMS\Component\Router\Rules\StandardRules($this));
  $this-&gt;attachRule(new \Joomla\CMS\Component\Router\Rules\NomenuRules($this));
}</programlisting>

        <para>This tells Joomla that we have three routable views called
        <code>welcome</code>, <code>item</code> and <code>detail</code>. The
        <code>detail</code> view is a child of <code>item</code>.</para>

        <para>How would Joomla know about which detail is under a specific
        item? We told it that the <code>detail</code>'s <code>itemid</code>
        property must match the key of the <code>item</code> and the key of
        the <code>item</code> is called <code>id</code>.</para>

        <para>The last three lines tell Joomla which routing rules to
        register:</para>

        <itemizedlist>
          <listitem>
            <para><classname>MenuRules</classname>. Tries to detect the
            correct Itemid for a view if none was provided in the non-SEF URL.
            You should keep that unless you want to implement the
            <methodname>preprocess</methodname> method yourself.</para>

            <note>
              <para>The <methodname>preprocess</methodname> method is called
              before the SEF URL is built and, crucially, before Joomla tries
              to figure out the <code>format</code> and <code>Itemid</code>
              URL parameters to send to your component's Router's build
              method.</para>

              <para>In Joomla 3 you could get away with trying to figure out
              and change the <code>format</code> and <code>Itemid</code>
              parameters in your router's <methodname>build</methodname>
              method. While this was necessary for compatibility with legacy
              <filename>router.php</filename> files (those using the two
              distinct functions), <emphasis>this “hack” will no longer work
              in Joomla 4</emphasis>. You must move that code into the
              <methodname>preprocess</methodname> method. If you fail to do
              so, your SEF URLs will not work properly; from your perspective,
              it will be as if your <code>format</code> and
              <code>Itemid</code> values overridden in the built method were
              never taken into account. That's <emphasis>exactly</emphasis>
              what happens.</para>

              <para>This is actually a good change. It makes the core routing
              code more efficient and keeps us third party developers in the
              habit of applying separation of concerns in our code.</para>
            </note>
          </listitem>

          <listitem>
            <para><classname>StandardRules</classname>. Standard non-SEF to
            SEF URL (and vice-versa) routing. If you omit this you will not
            get any SEF URL routing which beats the purpose of having a
            router.</para>
          </listitem>

          <listitem>
            <para><classname>NomenuRules</classname>. Process URLs when no
            Itemid exists for the component. This is necessary to route URLs
            when no published menu items exist for your component and Joomla
            needs to create or parse URLs in the format
            <uri>/component/example/foo/bar.html</uri>.</para>
          </listitem>
        </itemizedlist>

        <para>At this point Joomla knows the logical hierarchy of our
        component's views but it does not know how to convert an id in the
        non-SEF URL to a SEF URL segment when building the SEF URL (e.g.
        convert an item ID to its alias) or how to convert a SEF URL segment
        back to a non-SEF URL's numeric ID when it's parsing the SEF URL (e.g.
        convert an item alias to its ID). This is up to us.</para>

        <para>We need to provide two methods for each
        <classname>RouterViewConfiguration</classname> objects we created:
        <methodname>get<replaceable>Something</replaceable>Segment</methodname>
        and <methodname>get<replaceable>Something</replaceable>Id</methodname>
        where <replaceable>Something</replaceable> is the name of the view
        with its first letter capitalised. Here's what the code for the Item
        view would look like in our example:</para>

        <programlisting>public function getItemId(string $segment, array $query): bool|int
{
  $db = \Joomla\CMS\Factory::getContainer()-&gt;get('DatabaseDriver');
  $dbQuery = $db-&gt;getQuery(true)
    -&gt;select($db-&gt;quoteName('id'))
    -&gt;from($db-&gt;quoteName('#__example_items'))
    -&gt;where($db-&gt;quoteName('alias') . ' = :alias')
    -&gt;bind(':alias', $segment);

  return  $db-&gt;setQuery($dbQuery)-&gt;loadResult() ?: false;
}

public function getItemSegment(int $id, array $query): array
{
  $db = \Joomla\CMS\Factory::getContainer()-&gt;get('DatabaseDriver');
  $dbQuery = $db-&gt;getQuery(true)
    -&gt;select($db-&gt;quoteName('alias'))
    -&gt;from($db-&gt;quoteName('#__example_items'))
    -&gt;where($db-&gt;quoteName('id') . ' = :id')
    -&gt;bind(':id', $id);
  
  $segment = $db-&gt;setQuery($dbQuery)-&gt;loadResult() ?: null;

  if ($segment === null) {
    return [];
  }

  return [$segment];
}</programlisting>

        <para>There is something worth noting here. The
        <methodname>get<replaceable>Something</replaceable>Segment</methodname>
        method can return an array with more than one segments. This is useful
        if you want to somehow return a more complex structure e.g.
        <uri>item/foo/detail/bar</uri> where <code>item</code> and
        <code>detail</code> are fixed strings. However, if you do that, you
        will need to override the <methodname>parse</methodname> method to
        handle multi–segment views. The default implementation in
        <classname>StandardRules</classname> assumes that you are using
        exactly one segment per view and that's why
        <methodname>get<replaceable>Something</replaceable>Id</methodname>
        accepts a string, not an array, as its first argument.</para>

        <para>You may wonder, what about our <code>welcome</code> view? Don't
        we need to create methods for it? No, we don't. Views which do not
        have a key set for them use the name of the view as the (only) segment
        for SEF URLs. If there is a naming clash between such a view and an
        alias of a top–level view (or category, as we will see below) the
        first <classname>RouterViewConfiguration</classname> object registered
        “wins” in determining how that segment should be parsed. As a result,
        you should keep this kind of top–level views to a minimum and either
        inform users that they cannot use these aliases or actively prevent
        them with validation rules whenever possible.</para>
      </section>

      <section xml:id="com-router-push-dependencies">
        <title>Pushing dependencies to the Router</title>

        <para>You may have noticed that in the sample code above I got the
        database driver object using the
        <methodname>Factory::getContainer</methodname> static method. This is
        not ideal. It's even worse if I'd need to get access to MVC objects
        such as Models and Tables — having to boot the entire component just
        to get its MVCFactory is something to use only if there is no other
        way, not something to do by default.</para>

        <para>Fortunately, Joomla gives us the option to push any services we
        need — such as the database driver object and the component's
        MVCFactory — into the router. Unfortunately, it's a bit
        non-obvious.</para>

        <para>To inject services into the Router service object they need to
        be injected into the object after it is created by the Router Factory
        object. The Router Factory object needs to have access to these
        services to inject them. This means injecting these services to the
        Router Factory object from the Router Factory Service Provider. The
        Router Factory Service Provider can get any of the dependencies
        (services) it needs since it has access to the component's service
        provider.</para>

        <para>Therefore we need to create the two missing pieces of the puzzle
        (Router Factory and its service provider) and register the latter with
        our component's service provider.</para>

        <important>
          <para>The component's service provider
          (<filename>services/provider.php</filename>) lives in the backend
          portion of your component. Therefore. it makes sense that the Router
          Factory and the Router Factory Service Provider also live in the
          backend of your component <emphasis>even though the Router is only
          used in the frontend of the site</emphasis>.</para>

          <para>Yup. It sounds backwards. You can definitely create them in
          the frontend but, if you do, <emphasis>you</emphasis> and everyone
          else reading your code might get confused. Don't over-think it, just
          do what I tell you to do. There's method in this madness, I
          promise.</para>
        </important>

        <para>First, let's make our router MVCFactory-aware (it's already
        database–aware).</para>

        <programlisting>&lt;?php
namespace Acme\Example\Site\Service;

use Joomla\CMS\Component\Router\RouterView;
use Joomla\CMS\MVC\Factory\MVCFactoryAwareTrait;

class Router extends RouterView
{<emphasis role="bold">
	use MVCFactoryAwareTrait;
</emphasis>	
	// ... the rest of the router implementation goes here ...
}</programlisting>

        <para>Now, let's create a Router Factory
        (<classname>\Acme\Example\Administrator\Service\RouterFactory</classname>).
        The default Joomla implementation is already database-aware. I am just
        extending it to also know about the MVCFactory so we can inject it to
        our router.</para>

        <programlisting>&lt;?php
namespace Acme\Example\Administrator\Service;

use Joomla\CMS\Application\CMSApplicationInterface;
use Joomla\CMS\Component\Router\RouterInterface;
use Joomla\CMS\Menu\AbstractMenu;
use Joomla\CMS\MVC\Factory\MVCFactoryAwareTrait;

class RouterFactory extends \Joomla\CMS\Component\Router\RouterFactory
{
	use MVCFactoryAwareTrait;

	public function createRouter(CMSApplicationInterface $application, AbstractMenu $menu): RouterInterface
	{
		$router = parent::createRouter($application, $menu);

		$router-&gt;setMVCFactory($this-&gt;getMVCFactory());

		return $router;
	}
}</programlisting>

        <para>Now, we need to create a RouterFactory service provider.
        Unfortunately, Joomla has a bad habit of registering factory objects
        in the DI container even though they are only going to return exactly
        one object with no initialisation, like a router. This complicates
        thing because we cannot extend the DI container definition. We have to
        do something stupid: copy Joomla's default implementation of the
        Router Factory Service Provider just so we can change the returned
        object type and register dependencies on it. Well... I guess it could
        be worse?</para>

        <para>Anyway. Let's create our router factory service provider
        <classname>\Acme\Example\Administrator\Service\Provider\RouterFactoryProvider</classname>.</para>

        <programlisting>&lt;?php

namespace \Acme\Example\Administrator\Service\Provider;

<emphasis role="bold">use Acme\Example\Administrator\Service\RouterFactory;</emphasis>
use Joomla\CMS\Categories\CategoryFactoryInterface;
use Joomla\CMS\Component\Router\RouterFactoryInterface;
use Joomla\CMS\MVC\Factory\MVCFactoryInterface;
use Joomla\Database\DatabaseInterface;
use Joomla\DI\Container;
use Joomla\DI\ServiceProviderInterface;

class RouterFactoryProvider implements ServiceProviderInterface
{
/**
	 * The module namespace
	 *
	 * @since   4.0.0
	 * @var  string
	 *
	 */
	private $namespace;

	/**
	 * DispatcherFactory constructor.
	 *
	 * @param   string  $namespace  The namespace
	 *
	 * @since   4.0.0
	 */
	public function __construct(string $namespace)
	{
		$this-&gt;namespace = $namespace;
	}

	/**
	 * Registers the service provider with a DI container.
	 *
	 * @param   Container  $container  The DI container.
	 *
	 * @return  void
	 *
	 * @since   4.0.0
	 */
	public function register(Container $container)
	{
		$container-&gt;set(
			RouterFactoryInterface::class,
			function (Container $container) {
				$categoryFactory = null;

				if ($container-&gt;has(CategoryFactoryInterface::class))
				{
					$categoryFactory = $container-&gt;get(CategoryFactoryInterface::class);
				}

				$routerFactory = new <emphasis role="bold">RouterFactory</emphasis>(
					$this-&gt;namespace,
					$categoryFactory,
					$container-&gt;get(DatabaseInterface::class)
				);

				<emphasis role="bold">$routerFactory-&gt;setMVCFactory($container-&gt;get(MVCFactoryInterface::class));</emphasis>

				return $routerFactory;
			}
		);
	}
}
</programlisting>

        <para>Our changes to the core code in Joomla are highlighted in bold
        type.</para>

        <para>Finally, we need to register this router factory service
        provider in our component's <code>services/provider.php</code>
        file.</para>

        <programlisting>$container-&gt;registerServiceProvider(
  new \Acme\Example\Administrator\Service\Provider\RouterFactoryProvider(
    '\\Acme\\Example'
  )
);</programlisting>
      </section>
    </section>

    <section xml:id="com-dashboard">
      <title>Dashboard</title>

      <para>There is a new feature starting with Joomla 4: Dashboards.</para>

      <para>Dashboards are sort of virtual pages, displayed by means of the
      com_cpanel core component, <link
      xlink:href="https://magazine.joomla.org/all-issues/april-2021/joomla-4-customising-admin-dashboards">which
      allow the developer and the site owners to publish modules to customise
      them</link>.</para>

      <bridgehead>Define a dashboard</bridgehead>

      <para>You can define one or more dashboards in your component's XML
      manifest file:</para>

      <programlisting>&lt;dashboards&gt;
  &lt;dashboard title="COM_EXAMPLE_DASHBOARD_TITLE" icon="none fa fa-beer"&gt;com_example.something&lt;/dashboard&gt;
&lt;/dashboards&gt;</programlisting>

      <note>
        <para><code>&lt;dashboards&gt;</code> is a top–level tag, directly
        under the <code>&lt;extension&gt;</code> root tag. Yes, even though it
        only applies in the component's administration (backend) section. If
        your Dashboard does not work first check that you have not
        accidentally put that tag under <code>&lt;administration&gt;</code>.
        It's the most common mistake!</para>
      </note>

      <para>The <code>title</code> attribute's value is a language string
      defined in your extension's backend INI language file. It's customary
      for its string to end with the word “Dashboard”, e.g.</para>

      <programlisting>COM_EXAMPLE_DASHBOARD_TITLE="Example Dashboard"</programlisting>

      <para>The value of the <code>icon</code> attribute is a CSS class which
      gives the dashboard page its icon. Joomla 4 loads FontAwesome 5 Free so
      you can use <link
      xlink:href="https://fontawesome.com/v5/search?o=r&amp;m=free">any of its
      icons</link>. Please remember that Joomla prefixes the value of the
      <code>icon</code> attribute with the string literal <code>icon-</code>.
      This does not let you use all FontAwesome icons. To work around that I
      use the value <code>none fa fa-beer</code> which results in the HTML
      attribute and value <code>class="icon-none fa fa-beer"</code>. Since
      <code>icon-none</code> does not display anything, the browser falls back
      to the next two CSS classes which render FontAwesome's beer mug
      icon.</para>

      <warning>
        <para>The Dashboard is not part of your component. It does not load
        any custom backend CSS you may have. As a result, you cannot display
        your logo or any custom image in the Dashboard. While you could do
        that by loading custom CSS in a module you set up in the dashboard, do
        keep in mind that the user can easily disable (unpublish) that module
        and then your CSS won't load anymore. If you opt for this trick it's a
        good idea to provide a fallback to a Joomla system icon class or a
        FontAwesome icon class to make sure that
        <emphasis>something</emphasis> is displayed as the Dashboard's title
        icon.</para>
      </warning>

      <para>The value inside the tag <emphasis>must</emphasis> be in the
      format <code>component.something</code> where component is the name of
      your component (e.g. <code>com_example</code>) and something is a unique
      identifier for the dashboard among all dashboards defined in your
      component. For example, we could have the dashboard
      <code>com_example.something</code>.</para>

      <important>
        <para>Your component manifest MUST ALSO follow the naming convention
        <filename>bareComponent.xml</filename> and be placed in the backend
        folder of your component. For example, <code>com_example</code>'s XML
        manifest MUST be called <filename>example.xml</filename> and be found
        in
        administrator/components/com_example/<filename>example.xml</filename>.</para>

        <para>Keep in mind that Joomla automatically copies your component's
        XML manifest to the backend of your site when installing the
        component. You will only ever have to do it manually — if ever — when
        developing a component locally.</para>
      </important>

      <para>The value of the tag after the dot is also important. All modules
      published to the module position
      <code>cpanel-<replaceable>com_example</replaceable>-<replaceable>something</replaceable></code>
      will appear in this dashboard <code>com_example.something</code>.</para>

      <bridgehead>Display a link to your dashboard in the component's
      submenu</bridgehead>

      <para>The dashboard is cool… but how do you even display it? As it turns
      out there are exactly two ways:</para>

      <itemizedlist>
        <listitem>
          <para>Put a link (e.g. a Toolbar link button) in your extension
          pointing the browser to
          <uri>index.php?index.php?option=com_cpanel&amp;view=cpanel&amp;dashboard=<replaceable>com_example.something</replaceable></uri>
          where <replaceable>com_example.something</replaceable> is your
          custom dashboard.</para>
        </listitem>

        <listitem>
          <para>Add a submenu item in your XML manifest, e.g.</para>

          <programlisting>&lt;menu&gt;COM_EXAMPLE&lt;/menu&gt;

&lt;submenu&gt;
  <emphasis role="bold">&lt;menu
    link="index.php?option=com_cpanel&amp;amp;view=cpanel&amp;amp;dashboard=<replaceable>com_example.something</replaceable>"&gt;
<replaceable>    COM_EXAMPLE_MENU_TITLE_DASHBOARD</replaceable>
  &lt;/menu&gt;</emphasis>

  &lt;!-- more submenu items --&gt;
&lt;/submenu&gt;</programlisting>

          <important>
            <para>Remember that the
            <replaceable>COM_EXAMPLE_MENU_TITLE_DASHBOARD</replaceable>
            language string must be defined in your component's
            <filename>.sys.ini</filename> language file.</para>
          </important>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Super ultra secret stuff!</emphasis>
          Tell Joomla to display a Dashboard link next to your component's
          top-level menu entry. In your XML manifest you need to modify your
          top level menu item like so:</para>

          <programlisting>&lt;menu <emphasis role="bold">params="{&amp;quot;dashboard&amp;quot;: &amp;quot;com_example.example&amp;quot;}"</emphasis>&gt;COM_EXAMPLE&lt;/menu&gt;

&lt;submenu&gt;
  &lt;!-- your submenu items here… --&gt;
&lt;/submenu&gt;</programlisting>

          <para>The value of the <code>params</code> attribute in the XML
          manifest ends up in the <database>#__menu</database> table record's
          <database>params</database> column. The <code>dashboard</code>
          parameter key tells Joomla to display a dashboard link next to the
          menu item's text. The value of the dashboard parameter key tells
          Joomla <emphasis>which</emphasis> dashboard to link to.</para>
        </listitem>
      </itemizedlist>

      <para>It is actually a good idea using a combination of the methods
      above. The toolbar link can help lost users find their way back to the
      dashboard. While the <code>params</code> trick is cool, it only works in
      the default components side menu. If the user has customised the menu,
      uses an alternative presentation or simply visits the Components
      Dashboard they won't see the link to your component's custom dashboard,
      therefore you may need the second method (the submenu link to your
      dashboard) to cater for these use cases. What can I say? Joomla is
      customisable. Maybe even a bit <emphasis>too</emphasis>
      customisable.</para>

      <bridgehead>A custom menu preset for your dashboard</bridgehead>

      <para>You may have noticed that all core dashboards seem to have an
      “immutable” area at the top. This is not immutable; it's just a plain
      old module of the type <code>mod_submenu</code> set to display in the
      module style <code>none</code> (that's why you don't see the cogs button
      to edit it in the dashboard). You can of course edit this module like
      any other module in Content, Administrator Modules.</para>

      <para>It's useful that we can also do the same for our own component and
      its dashboard. However, you may notice that mod_submenu only has presets
      for core components. What about our custom component? Well, as it turns
      out, there are no hardcoded presets! Everything you see available in
      mod_submenu is, in fact, file on your site and yes, we can do the same
      thing for our own component!</para>

      <para>We need to create a custom menu preset for our component by
      creating an XML file under the
      <filename>administrator/components/com_example/presets</filename>
      folder. To get an idea of what you can do, take a look at a core preset
      such as
      <filename>administrator/componetns/com_users/presets/users.xml</filename>.</para>

      <para>The name of your menu preset XML file MUST be unique across all
      components installed in Joomla. For this reason it's recommended to name
      it after your extension. For example, com_example's menu preset would be
      <filename>administrator/components/com_example/presets/example.xml</filename>.</para>

      <para>If you need multiple presets in your component it's strongly
      recommended that their file names follow the pattern
      <filename>component_something.xml</filename>, e.g.
      <filename>administrator/components/com_example/presets/example_alternate.xml</filename>.</para>

      <tip>
        <para>Per-component menu presets can be overridden in the same way as
        view templates. For example, if you want to override the default core
        Users menu preset
        (<filename>administrator/componetns/com_users/presets/users.xml</filename>),
        copy it to
        <filename>administrator/templates/atum/html/com_menus/presets/users.xml</filename>
        and edit away!</para>

        <para>Since all overrides live under the same
        <filename>com_menus/presets</filename> override folder you now
        understand why their name needs to be unique across all components
        installed on your site.</para>
      </tip>

      <para>Here is a sample preset, let's say it's
      <filename>administrator/components/com_example/presets/example.xml</filename>
      (this means the preset name is <code>example</code>) .</para>

      <programlisting>&lt;?xml version="1.0"?&gt;
&lt;menu
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="urn:joomla.org"
        xsi:schemaLocation="urn:joomla.org menu.xsd"
&gt;
    &lt;menuitem
            title="COM_EXAMPLE_MENUS_CONTENT"
            type="heading"
            icon="none fa-feather-alt"
    &gt;
        &lt;menuitem
                title="JCATEGORIES"
                type="component"
                element="com_categories"
                link="index.php?option=com_categories&amp;amp;view=categories&amp;amp;extension=com_example"
                quicktask="index.php?option=com_categories&amp;amp;extension=com_example&amp;amp;task=category.add"
                quicktask-title="COM_EXAMPLE_MENUS_NEW_CATEGORY"
        /&gt;

        &lt;menuitem
                title="COM_EXAMPLE_MENUS_ITEMS"
                type="component"
                element="com_example"
                link="index.php?option=com_example&amp;amp;view=items"
                quicktask="index.php?option=com_example&amp;amp;task=item.add"
                quicktask-title="COM_EXAMPLE_MENUS_NEW_ITEM"
        /&gt;
    &lt;/menuitem&gt;
&lt;/menu&gt;</programlisting>

      <para>Here are some <emphasis role="bold">practical</emphasis>
      tips:</para>

      <itemizedlist>
        <listitem>
          <para>The icon attribute sets the CSS class for the heading by
          combining the literal string <code>icon-</code> with the value of
          the attribute. The number of icons available that way is minuscule
          compared to the plethora of icons available in FontAwesome 5 Free.
          This is why I use values for this attribute in the form <code>none
          fa-something</code>. This results in the CSS class being set to
          <code>icon-none fa-something</code>. There is no such thing as an
          <code>icon-none</code> CSS class, so that part does nothing. The
          next part, the <code>fa-something</code>, is where I tell the
          browser to use one of the available FontAwesome icons.</para>
        </listitem>

        <listitem>
          <para>The <code>quicktask</code> and <code>quicktask-title</code>
          attributes set up the little quick action icon next to the menu item
          text. By default, this is a plus icon, implying that you can add an
          item. You can customise that icon using the attribute
          <code>menu-quicktask-icon</code> which works in the exact same way
          as a heading's <code>icon</code> attribute.</para>

          <para>Why would you want to customise it? Well, let's say you have a
          security component with a view called Automatically Blocked IP
          Addresses. It would not make sense to manually add a new entry —
          since they are <emphasis>automatically</emphasis> blocked — but it
          would totally make sense to have a quick action to
          <emphasis>unblock</emphasis> an accidentally blocked IP address. In
          this case a more appropriate icon would be
          <code>fa-unlock</code>.</para>
        </listitem>
      </itemizedlist>

      <bridgehead>Creating and publishing the custom dashboard menu module,
      automatically</bridgehead>

      <para>All right. We have a dashboard. We have a menu item to access it.
      We have a custom menu to display in a mod_submenu module inside the
      dashboard. But how exactly do we get to create this kind of module? We
      can't possibly ask our users to create it manually, that would
      suck!</para>

      <para>The answer is that Joomla gives us ALMOST everything we need to
      create that module in our component's installation script.</para>

      <para>First, let's make sure our component does use an installation
      script. In the XML manifest we need to add a line like this, as we're
      familiar from Joomla 3:</para>

      <programlisting>&lt;scriptfile&gt;script.example.php&lt;/scriptfile&gt;</programlisting>

      <para>The <code>script.example.php</code> will contain our component
      installation script. You are familiar with that; it's been around since
      Joomla 1.0.</para>

      <para>What you may not have picked up is that since Joomla 3.6 there's a
      superclass our installation script can extend from. In Joomla 3 it was
      called <classname>JInstallerScript</classname>, in Joomla 4 it's
      <classname>Joomla\CMS\Installer\InstallerScript</classname> (the old
      name will work up to and including Joomla 5.3). We'll get into more
      detail on it <link linkend="com-installation-script">in the installation
      script section</link>.</para>

      <para>Joomla's InstallerScript provides a handy method called
      <methodname>addDashboardMenu</methodname> which creates a
      <code>mod_submenu</code> module to a specific dashboard using a specific
      menu preset. However, the way it is written it assumes that it will only
      ever be executed once, the first time you install a component. What
      about hundreds of third party components which have been around long
      before Joomla 4? Don't worry, we have a solution! We will install the
      module if and only if it's missing, regardless of whether this is a new
      installation or an update.</para>

      <para>Here's how to do that:</para>

      <programlisting>&lt;?php
defined('_JEXEC') || die;

use Joomla\CMS\Factory;
use Joomla\CMS\Installer\Adapter\PackageAdapter;
use Joomla\CMS\Installer\InstallerScript;

class <emphasis role="bold">Com_ExampleInstallerScript</emphasis> extends InstallerScript
{
	/**
	 * Called after any type of installation / uninstallation action.
	 *
	 * @param   string          $type    Which action is happening (install|uninstall|discover_install|update)
	 * @param   PackageAdapter  $parent  The object responsible for running this script
	 *
	 * @return  bool
	 * @since   1.0.0
	 */
	public function postflight(string $type, PackageAdapter $parent): bool
	{
		// Do not run on uninstall.
		if ($type === 'uninstall')
		{
			return true;
		}

		// Install the dashboard module if necessary
		$this-&gt;conditionalInstallDashboard(<emphasis role="bold">'com_example-example', 'example'</emphasis>);

		return true;
	}

	private function conditionalInstallDashboard(string $dashboard, string $preset): void
	{
		$position = 'cpanel-' . $dashboard;

		/** @var \Joomla\Database\DatabaseDriver $db */
		$db = Factory::getContainer()-&gt;get('DatabaseDriver');
		$query = $db-&gt;getQuery(true)
		            -&gt;select('COUNT(*)')
		            -&gt;from($db-&gt;quoteName('#__modules'))
		            -&gt;where([
			            $db-&gt;quoteName('module') . ' = ' . $db-&gt;quote('mod_submenu'),
			            $db-&gt;quoteName('client_id') . ' = ' . $db-&gt;quote(1),
			            $db-&gt;quoteName('position') . ' = :position',
		            ])
		            -&gt;bind(':position', $position);

		$modules = $db-&gt;setQuery($query)-&gt;loadResult() ?: 0;

		if ($modules == 0)
		{
			$this-&gt;addDashboardMenu($dashboard, $preset);
		}
	}

}</programlisting>

      <para>The <methodname>postflight</methodname> method is called whenever
      Joomla has finished trying to install <emphasis>or uninstall</emphasis>
      (in Joomla 3 it was only after installation!) our component and before
      it cleans up. At this point we can check if there is a module already
      installed. If not, we let Joomla's code install it.</para>

      <para>The only two things you need to change above are the parts in bold
      type: the class name to match your component's name and the parameters
      to the <methodname>conditionalInstallDashboard</methodname> method. The
      parameters are fairly obvious: the name of the dashboard (replacing the
      dot with a dash!) and the name of your menu preset which typically is
      the same as your component's name without the <code>com_</code>
      prefix.</para>
    </section>

    <section xml:id="com-installation-script">
      <title>The installation script</title>

      <para/>
    </section>

    <section xml:id="com-events">
      <title>Dispatching events (calling plugins)</title>

      <para/>
    </section>

    <section xml:id="com-data-to-frontend">
      <title>Passing data from the backend to the JavaScript on the
      page</title>

      <para/>
    </section>

    <section xml:id="com-lang">
      <title>Language files</title>

      <para/>
    </section>

    <section xml:id="com-mailtemplates">
      <title>Mail Templates</title>

      <para/>
    </section>

    <section xml:id="com-layouts">
      <title>Layouts</title>

      <para/>
    </section>

    <section xml:id="com-cli">
      <title>The CLI application</title>

      <para/>
    </section>

    <section xml:id="com-api">
      <title>The API application</title>

      <para/>
    </section>

    <section xml:id="com-scheduled-tasks">
      <title>Integration with Scheduled Tasks</title>

      <para/>
    </section>

    <section xml:id="com-fields">
      <title>Custom fields</title>

      <para/>
    </section>

    <section xml:id="tags">
      <title>Tags</title>

      <para/>
    </section>

    <section xml:id="com-hmvc">
      <title>HMVC (sort of)</title>

      <para/>
    </section>

    <section xml:id="com-rector">
      <title>Using Rector</title>

      <para/>
    </section>

    <section xml:id="com-migration">
      <title>Migration strategy</title>

      <para/>
    </section>
  </chapter>

  <chapter xml:id="plg">
    <title>Plugins</title>

    <para/>

    <section xml:id="plg-forms">
      <title>The many forms of a Joomla plugin</title>

      <para/>

      <section xml:id="plg-forms-legacy">
        <title>Legacy (Joomla 1.x to 3.x)</title>

        <para/>
      </section>

      <section xml:id="plg-forms-j4-classic">
        <title>Joomla 4 classic</title>

        <para/>
      </section>

      <section xml:id="plg-forms-j4-subscriberinterface">
        <title>Joomla 4 with SubscriberInterface</title>

        <para/>
      </section>
    </section>

    <section xml:id="plg-namespaces">
      <title>Namespaces</title>

      <para/>
    </section>

    <section xml:id="plg-services">
      <title>Service Locator</title>

      <para/>
    </section>

    <section xml:id="plg-extension">
      <title>Extension class (plugin)</title>

      <para/>
    </section>

    <section xml:id="plg-lang">
      <title>Language files</title>

      <para/>
    </section>

    <section xml:id="plg-dont-break-joomla">
      <title>How NOT to break Joomla with your plugin</title>

      <para/>
    </section>

    <section xml:id="plg-concrete-events">
      <title>Generic versus Concrete events</title>

      <para/>
    </section>

    <section xml:id="plg-view-templates">
      <title>Using view templates</title>

      <para/>
    </section>

    <section xml:id="plg-interfacing-com">
      <title>Interfacing with your component</title>

      <para/>
    </section>

    <section xml:id="plg-migration">
      <title>Migration strategy</title>

      <para/>
    </section>
  </chapter>

  <chapter xml:id="mod">
    <title>Modules</title>

    <para/>

    <section xml:id="mod-legacy-vs-j4">
      <title>Legacy vs Joomla 4 modules</title>

      <para/>

      <section xml:id="mod-legacy">
        <title>Legacy modules (Joomla 1.x to 3.x)</title>

        <para/>
      </section>

      <section xml:id="mod-j4">
        <title>Joomla 4 modules</title>

        <para/>
      </section>
    </section>

    <section xml:id="mod-services">
      <title>Service Locator</title>

      <para/>
    </section>

    <section xml:id="mod-extension">
      <title>Extension class</title>

      <para/>
    </section>

    <section xml:id="mod-lang">
      <title>Language files</title>

      <para/>
    </section>

    <section xml:id="mod-helper">
      <title>The Helper</title>

      <para/>
    </section>

    <section xml:id="mod-view-templates">
      <title>View templates</title>

      <para/>
    </section>

    <section xml:id="mod-interfacing-com">
      <title>Interfacing with your component</title>

      <para/>
    </section>

    <section xml:id="mod-migration">
      <title>Migration strategy</title>

      <para/>
    </section>
  </chapter>

  <chapter xml:id="tpl">
    <title>Templates</title>

    <para/>

    <section xml:id="tpl-j4-changes">
      <title>Major changes in Joomla 4</title>

      <para/>
    </section>

    <section xml:id="tpl-subtemplates">
      <title>Sub-templates</title>

      <para/>
    </section>

    <section xml:id="tpl-custom-cassiopeia">
      <title>Using Cassiopeia to create a custom template</title>

      <para/>
    </section>

    <section xml:id="tpl-custom-from-scratch">
      <title>Custom template from scratch</title>

      <para/>
    </section>

    <section xml:id="tpl-fields">
      <title>Custom fields in your templates</title>

      <para/>
    </section>

    <section xml:id="tpl-category-content-templates">
      <title>Per-category view templates in com_content</title>

      <para/>
    </section>

    <section xml:id="tpl-migration">
      <title>Migration strategy</title>

      <para/>
    </section>
  </chapter>

  <appendix>
    <title>GNU Free Documentation License</title>

    <simpara>Version 1.3, 3 November 2008</simpara>

    <simpara>Copyright © 2000, 2001, 2002, 2007, 2008 <link
    xlink:href="https://www.fsf.org/">Free Software Foundation,
    Inc.</link></simpara>

    <simpara>Everyone is permitted to copy and distribute verbatim copies of
    this license document, but changing it is not allowed.</simpara>

    <bridgehead renderas="sect2" xml:id="section0">0. PREAMBLE</bridgehead>

    <simpara>The purpose of this License is to make a manual, textbook, or
    other functional and useful document “free” in the sense of freedom: to
    assure everyone the effective freedom to copy and redistribute it, with or
    without modifying it, either commercially or noncommercially. Secondarily,
    this License preserves for the author and publisher a way to get credit
    for their work, while not being considered responsible for modifications
    made by others.</simpara>

    <simpara>This License is a kind of “copyleft”, which means that derivative
    works of the document must themselves be free in the same sense. It
    complements the GNU General Public License, which is a copyleft license
    designed for free software.</simpara>

    <simpara>We have designed this License in order to use it for manuals for
    free software, because free software needs free documentation: a free
    program should come with manuals providing the same freedoms that the
    software does. But this License is not limited to software manuals; it can
    be used for any textual work, regardless of subject matter or whether it
    is published as a printed book. We recommend this License principally for
    works whose purpose is instruction or reference.</simpara>

    <bridgehead renderas="sect2" xml:id="section1">1. APPLICABILITY AND
    DEFINITIONS</bridgehead>

    <simpara>This License applies to any manual or other work, in any medium,
    that contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License. Such a notice grants a
    world-wide, royalty-free license, unlimited in duration, to use that work
    under the conditions stated herein. The “Document”, below, refers to any
    such manual or work. Any member of the public is a licensee, and is
    addressed as “you”. You accept the license if you copy, modify or
    distribute the work in a way requiring permission under copyright
    law.</simpara>

    <simpara>A “Modified Version” of the Document means any work containing
    the Document or a portion of it, either copied verbatim, or with
    modifications and/or translated into another language.</simpara>

    <simpara>A “Secondary Section” is a named appendix or a front-matter
    section of the Document that deals exclusively with the relationship of
    the publishers or authors of the Document to the Document's overall
    subject (or to related matters) and contains nothing that could fall
    directly within that overall subject. (Thus, if the Document is in part a
    textbook of mathematics, a Secondary Section may not explain any
    mathematics.) The relationship could be a matter of historical connection
    with the subject or with related matters, or of legal, commercial,
    philosophical, ethical or political position regarding them.</simpara>

    <simpara>The “Invariant Sections” are certain Secondary Sections whose
    titles are designated, as being those of Invariant Sections, in the notice
    that says that the Document is released under this License. If a section
    does not fit the above definition of Secondary then it is not allowed to
    be designated as Invariant. The Document may contain zero Invariant
    Sections. If the Document does not identify any Invariant Sections then
    there are none.</simpara>

    <simpara>The “Cover Texts” are certain short passages of text that are
    listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says
    that the Document is released under this License. A Front-Cover Text may
    be at most 5 words, and a Back-Cover Text may be at most 25
    words.</simpara>

    <simpara>A “Transparent” copy of the Document means a machine-readable
    copy, represented in a format whose specification is available to the
    general public, that is suitable for revising the document
    straightforwardly with generic text editors or (for images composed of
    pixels) generic paint programs or (for drawings) some widely available
    drawing editor, and that is suitable for input to text formatters or for
    automatic translation to a variety of formats suitable for input to text
    formatters. A copy made in an otherwise Transparent file format whose
    markup, or absence of markup, has been arranged to thwart or discourage
    subsequent modification by readers is not Transparent. An image format is
    not Transparent if used for any substantial amount of text. A copy that is
    not “Transparent” is called “Opaque”.</simpara>

    <simpara>Examples of suitable formats for Transparent copies include plain
    ASCII without markup, Texinfo input format, LaTeX input format, SGML or
    XML using a publicly available DTD, and standard-conforming simple HTML,
    PostScript or PDF designed for human modification. Examples of transparent
    image formats include PNG, XCF and JPG. Opaque formats include proprietary
    formats that can be read and edited only by proprietary word processors,
    SGML or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML, PostScript or PDF produced by
    some word processors for output purposes only.</simpara>

    <simpara>The “Title Page” means, for a printed book, the title page
    itself, plus such following pages as are needed to hold, legibly, the
    material this License requires to appear in the title page. For works in
    formats which do not have any title page as such, “Title Page” means the
    text near the most prominent appearance of the work's title, preceding the
    beginning of the body of the text.</simpara>

    <simpara>The “publisher” means any person or entity that distributes
    copies of the Document to the public.</simpara>

    <simpara>A section “Entitled XYZ” means a named subunit of the Document
    whose title either is precisely XYZ or contains XYZ in parentheses
    following text that translates XYZ in another language. (Here XYZ stands
    for a specific section name mentioned below, such as “Acknowledgements”,
    “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of
    such a section when you modify the Document means that it remains a
    section “Entitled XYZ” according to this definition.</simpara>

    <simpara>The Document may include Warranty Disclaimers next to the notice
    which states that this License applies to the Document. These Warranty
    Disclaimers are considered to be included by reference in this License,
    but only as regards disclaiming warranties: any other implication that
    these Warranty Disclaimers may have is void and has no effect on the
    meaning of this License.</simpara>

    <bridgehead renderas="sect2" xml:id="section2">2. VERBATIM
    COPYING</bridgehead>

    <simpara>You may copy and distribute the Document in any medium, either
    commercially or noncommercially, provided that this License, the copyright
    notices, and the license notice saying this License applies to the
    Document are reproduced in all copies, and that you add no other
    conditions whatsoever to those of this License. You may not use technical
    measures to obstruct or control the reading or further copying of the
    copies you make or distribute. However, you may accept compensation in
    exchange for copies. If you distribute a large enough number of copies you
    must also follow the conditions in section 3.</simpara>

    <simpara>You may also lend copies, under the same conditions stated above,
    and you may publicly display copies.</simpara>

    <bridgehead renderas="sect2" xml:id="section3">3. COPYING IN
    QUANTITY</bridgehead>

    <simpara>If you publish printed copies (or copies in media that commonly
    have printed covers) of the Document, numbering more than 100, and the
    Document's license notice requires Cover Texts, you must enclose the
    copies in covers that carry, clearly and legibly, all these Cover Texts:
    Front-Cover Texts on the front cover, and Back-Cover Texts on the back
    cover. Both covers must also clearly and legibly identify you as the
    publisher of these copies. The front cover must present the full title
    with all words of the title equally prominent and visible. You may add
    other material on the covers in addition. Copying with changes limited to
    the covers, as long as they preserve the title of the Document and satisfy
    these conditions, can be treated as verbatim copying in other
    respects.</simpara>

    <simpara>If the required texts for either cover are too voluminous to fit
    legibly, you should put the first ones listed (as many as fit reasonably)
    on the actual cover, and continue the rest onto adjacent pages.</simpara>

    <simpara>If you publish or distribute Opaque copies of the Document
    numbering more than 100, you must either include a machine-readable
    Transparent copy along with each Opaque copy, or state in or with each
    Opaque copy a computer-network location from which the general
    network-using public has access to download using public-standard network
    protocols a complete Transparent copy of the Document, free of added
    material. If you use the latter option, you must take reasonably prudent
    steps, when you begin distribution of Opaque copies in quantity, to ensure
    that this Transparent copy will remain thus accessible at the stated
    location until at least one year after the last time you distribute an
    Opaque copy (directly or through your agents or retailers) of that edition
    to the public.</simpara>

    <simpara>It is requested, but not required, that you contact the authors
    of the Document well before redistributing any large number of copies, to
    give them a chance to provide you with an updated version of the
    Document.</simpara>

    <bridgehead renderas="sect2" xml:id="section4">4.
    MODIFICATIONS</bridgehead>

    <simpara>You may copy and distribute a Modified Version of the Document
    under the conditions of sections 2 and 3 above, provided that you release
    the Modified Version under precisely this License, with the Modified
    Version filling the role of the Document, thus licensing distribution and
    modification of the Modified Version to whoever possesses a copy of it. In
    addition, you must do these things in the Modified Version:</simpara>

    <orderedlist numeration="upperalpha">
      <listitem>
        <simpara>Use in the Title Page (and on the covers, if any) a title
        distinct from that of the Document, and from those of previous
        versions (which should, if there were any, be listed in the History
        section of the Document). You may use the same title as a previous
        version if the original publisher of that version gives
        permission.</simpara>
      </listitem>

      <listitem>
        <simpara>List on the Title Page, as authors, one or more persons or
        entities responsible for authorship of the modifications in the
        Modified Version, together with at least five of the principal authors
        of the Document (all of its principal authors, if it has fewer than
        five), unless they release you from this requirement.</simpara>
      </listitem>

      <listitem>
        <simpara>State on the Title page the name of the publisher of the
        Modified Version, as the publisher.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve all the copyright notices of the Document.</simpara>
      </listitem>

      <listitem>
        <simpara>Add an appropriate copyright notice for your modifications
        adjacent to the other copyright notices.</simpara>
      </listitem>

      <listitem>
        <simpara>Include, immediately after the copyright notices, a license
        notice giving the public permission to use the Modified Version under
        the terms of this License, in the form shown in the Addendum
        below.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve in that license notice the full lists of Invariant
        Sections and required Cover Texts given in the Document's license
        notice.</simpara>
      </listitem>

      <listitem>
        <simpara>Include an unaltered copy of this License.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve the section Entitled “History”, Preserve its Title,
        and add to it an item stating at least the title, year, new authors,
        and publisher of the Modified Version as given on the Title Page. If
        there is no section Entitled “History” in the Document, create one
        stating the title, year, authors, and publisher of the Document as
        given on its Title Page, then add an item describing the Modified
        Version as stated in the previous sentence.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve the network location, if any, given in the Document
        for public access to a Transparent copy of the Document, and likewise
        the network locations given in the Document for previous versions it
        was based on. These may be placed in the “History” section. You may
        omit a network location for a work that was published at least four
        years before the Document itself, or if the original publisher of the
        version it refers to gives permission.</simpara>
      </listitem>

      <listitem>
        <simpara>For any section Entitled “Acknowledgements” or “Dedications”,
        Preserve the Title of the section, and preserve in the section all the
        substance and tone of each of the contributor acknowledgements and/or
        dedications given therein.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve all the Invariant Sections of the Document,
        unaltered in their text and in their titles. Section numbers or the
        equivalent are not considered part of the section titles.</simpara>
      </listitem>

      <listitem>
        <simpara>Delete any section Entitled “Endorsements”. Such a section
        may not be included in the Modified Version.</simpara>
      </listitem>

      <listitem>
        <simpara>Do not retitle any existing section to be Entitled
        “Endorsements” or to conflict in title with any Invariant
        Section.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve any Warranty Disclaimers.</simpara>
      </listitem>
    </orderedlist>

    <simpara>If the Modified Version includes new front-matter sections or
    appendices that qualify as Secondary Sections and contain no material
    copied from the Document, you may at your option designate some or all of
    these sections as invariant. To do this, add their titles to the list of
    Invariant Sections in the Modified Version's license notice. These titles
    must be distinct from any other section titles.</simpara>

    <simpara>You may add a section Entitled “Endorsements”, provided it
    contains nothing but endorsements of your Modified Version by various
    parties — for example, statements of peer review or that the text has been
    approved by an organization as the authoritative definition of a
    standard.</simpara>

    <simpara>You may add a passage of up to five words as a Front-Cover Text,
    and a passage of up to 25 words as a Back-Cover Text, to the end of the
    list of Cover Texts in the Modified Version. Only one passage of
    Front-Cover Text and one of Back-Cover Text may be added by (or through
    arrangements made by) any one entity. If the Document already includes a
    cover text for the same cover, previously added by you or by arrangement
    made by the same entity you are acting on behalf of, you may not add
    another; but you may replace the old one, on explicit permission from the
    previous publisher that added the old one.</simpara>

    <simpara>The author(s) and publisher(s) of the Document do not by this
    License give permission to use their names for publicity for or to assert
    or imply endorsement of any Modified Version.</simpara>

    <bridgehead renderas="sect2" xml:id="section5">5. COMBINING
    DOCUMENTS</bridgehead>

    <simpara>You may combine the Document with other documents released under
    this License, under the terms defined in section 4 above for modified
    versions, provided that you include in the combination all of the
    Invariant Sections of all of the original documents, unmodified, and list
    them all as Invariant Sections of your combined work in its license
    notice, and that you preserve all their Warranty Disclaimers.</simpara>

    <simpara>The combined work need only contain one copy of this License, and
    multiple identical Invariant Sections may be replaced with a single copy.
    If there are multiple Invariant Sections with the same name but different
    contents, make the title of each such section unique by adding at the end
    of it, in parentheses, the name of the original author or publisher of
    that section if known, or else a unique number. Make the same adjustment
    to the section titles in the list of Invariant Sections in the license
    notice of the combined work.</simpara>

    <simpara>In the combination, you must combine any sections Entitled
    “History” in the various original documents, forming one section Entitled
    “History”; likewise combine any sections Entitled “Acknowledgements”, and
    any sections Entitled “Dedications”. You must delete all sections Entitled
    “Endorsements”.</simpara>

    <bridgehead renderas="sect2" xml:id="section6">6. COLLECTIONS OF
    DOCUMENTS</bridgehead>

    <simpara>You may make a collection consisting of the Document and other
    documents released under this License, and replace the individual copies
    of this License in the various documents with a single copy that is
    included in the collection, provided that you follow the rules of this
    License for verbatim copying of each of the documents in all other
    respects.</simpara>

    <simpara>You may extract a single document from such a collection, and
    distribute it individually under this License, provided you insert a copy
    of this License into the extracted document, and follow this License in
    all other respects regarding verbatim copying of that document.</simpara>

    <bridgehead renderas="sect2" xml:id="section7">7. AGGREGATION WITH
    INDEPENDENT WORKS</bridgehead>

    <simpara>A compilation of the Document or its derivatives with other
    separate and independent documents or works, in or on a volume of a
    storage or distribution medium, is called an “aggregate” if the copyright
    resulting from the compilation is not used to limit the legal rights of
    the compilation's users beyond what the individual works permit. When the
    Document is included in an aggregate, this License does not apply to the
    other works in the aggregate which are not themselves derivative works of
    the Document.</simpara>

    <simpara>If the Cover Text requirement of section 3 is applicable to these
    copies of the Document, then if the Document is less than one half of the
    entire aggregate, the Document's Cover Texts may be placed on covers that
    bracket the Document within the aggregate, or the electronic equivalent of
    covers if the Document is in electronic form. Otherwise they must appear
    on printed covers that bracket the whole aggregate.</simpara>

    <bridgehead renderas="sect2" xml:id="section8">8. TRANSLATION</bridgehead>

    <simpara>Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section 4.
    Replacing Invariant Sections with translations requires special permission
    from their copyright holders, but you may include translations of some or
    all Invariant Sections in addition to the original versions of these
    Invariant Sections. You may include a translation of this License, and all
    the license notices in the Document, and any Warranty Disclaimers,
    provided that you also include the original English version of this
    License and the original versions of those notices and disclaimers. In
    case of a disagreement between the translation and the original version of
    this License or a notice or disclaimer, the original version will
    prevail.</simpara>

    <simpara>If a section in the Document is Entitled “Acknowledgements”,
    “Dedications”, or “History”, the requirement (section 4) to Preserve its
    Title (section 1) will typically require changing the actual
    title.</simpara>

    <bridgehead renderas="sect2" xml:id="section9">9. TERMINATION</bridgehead>

    <simpara>You may not copy, modify, sublicense, or distribute the Document
    except as expressly provided under this License. Any attempt otherwise to
    copy, modify, sublicense, or distribute it is void, and will automatically
    terminate your rights under this License.</simpara>

    <simpara>However, if you cease all violation of this License, then your
    license from a particular copyright holder is reinstated (a)
    provisionally, unless and until the copyright holder explicitly and
    finally terminates your license, and (b) permanently, if the copyright
    holder fails to notify you of the violation by some reasonable means prior
    to 60 days after the cessation.</simpara>

    <simpara>Moreover, your license from a particular copyright holder is
    reinstated permanently if the copyright holder notifies you of the
    violation by some reasonable means, this is the first time you have
    received notice of violation of this License (for any work) from that
    copyright holder, and you cure the violation prior to 30 days after your
    receipt of the notice.</simpara>

    <simpara>Termination of your rights under this section does not terminate
    the licenses of parties who have received copies or rights from you under
    this License. If your rights have been terminated and not permanently
    reinstated, receipt of a copy of some or all of the same material does not
    give you any rights to use it.</simpara>

    <bridgehead renderas="sect2" xml:id="section10">10. FUTURE REVISIONS OF
    THIS LICENSE</bridgehead>

    <simpara>The Free Software Foundation may publish new, revised versions of
    the GNU Free Documentation License from time to time. Such new versions
    will be similar in spirit to the present version, but may differ in detail
    to address new problems or concerns. See <link
    xlink:href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</link>.</simpara>

    <simpara>Each version of the License is given a distinguishing version
    number. If the Document specifies that a particular numbered version of
    this License “or any later version” applies to it, you have the option of
    following the terms and conditions either of that specified version or of
    any later version that has been published (not as a draft) by the Free
    Software Foundation. If the Document does not specify a version number of
    this License, you may choose any version ever published (not as a draft)
    by the Free Software Foundation. If the Document specifies that a proxy
    can decide which future versions of this License can be used, that proxy's
    public statement of acceptance of a version permanently authorizes you to
    choose that version for the Document.</simpara>

    <bridgehead renderas="sect2" xml:id="section11">11.
    RELICENSING</bridgehead>

    <simpara>“Massive Multiauthor Collaboration Site” (or “MMC Site”) means
    any World Wide Web server that publishes copyrightable works and also
    provides prominent facilities for anybody to edit those works. A public
    wiki that anybody can edit is an example of such a server. A “Massive
    Multiauthor Collaboration” (or “MMC”) contained in the site means any set
    of copyrightable works thus published on the MMC site.</simpara>

    <simpara>“CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
    license published by Creative Commons Corporation, a not-for-profit
    corporation with a principal place of business in San Francisco,
    California, as well as future copyleft versions of that license published
    by that same organization.</simpara>

    <simpara>“Incorporate” means to publish or republish a Document, in whole
    or in part, as part of another Document.</simpara>

    <simpara>An MMC is “eligible for relicensing” if it is licensed under this
    License, and if all works that were first published under this License
    somewhere other than this MMC, and subsequently incorporated in whole or
    in part into the MMC, (1) had no cover texts or invariant sections, and
    (2) were thus incorporated prior to November 1, 2008.</simpara>

    <simpara>The operator of an MMC Site may republish an MMC contained in the
    site under CC-BY-SA on the same site at any time before August 1, 2009,
    provided the MMC is eligible for relicensing.</simpara>

    <bridgehead renderas="sect2" xml:id="addendum">ADDENDUM: How to use this
    License for your documents</bridgehead>

    <simpara>To use this License in a document you have written, include a
    copy of the License in the document and put the following copyright and
    license notices just after the title page:</simpara>

    <screen>Copyright © YEAR YOUR NAME

Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.3 or any later version
published by the Free Software Foundation; with no Invariant Sections, no
Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in
the section entitled “GNU Free Documentation License”.</screen>

    <simpara>If you have Invariant Sections, Front-Cover Texts and Back-Cover
    Texts, replace the “with… Texts.” line with this:</simpara>

    <screen>with the Invariant Sections being LIST THEIR TITLES, with the Front-Cover Texts
being LIST, and with the Back-Cover Texts being LIST.</screen>

    <simpara>If you have Invariant Sections without Cover Texts, or some other
    combination of the three, merge those two alternatives to suit the
    situation.</simpara>

    <simpara>If your document contains nontrivial examples of program code, we
    recommend releasing these examples in parallel under your choice of free
    software license, such as the GNU General Public License, to permit their
    use in free software.</simpara>
  </appendix>
</book>
