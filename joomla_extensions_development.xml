<?xml version="1.0" encoding="UTF-8"?>
<book version="5.1" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xila="http://www.w3.org/2001/XInclude/local-attributes"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:trans="http://docbook.org/ns/transclusion"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Joomla Extensions Development</title>

    <author>
      <personname><firstname>Nicholas</firstname><othername>K.</othername><surname>Dionysopoulos</surname></personname>

      <affiliation>
        <orgname>Akeeba Ltd</orgname>
      </affiliation>
    </author>

    <pubdate>August 2022</pubdate>

    <copyright>
      <year>2022</year>

      <holder>Nicholas K. Dionysopoulos</holder>
    </copyright>

    <legalnotice>
      <para>Permission is granted to copy, distribute and/or modify this
      document under the terms of the GNU Free Documentation License, Version
      1.3 or any later version published by the Free Software Foundation; with
      no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
      copy of the license is included in the section entitled "GNU Free
      Documentation License".</para>
    </legalnotice>
  </info>

  <chapter xml:id="intro">
    <title>Introduction</title>

    <section xml:id="intro-about">
      <title>About this book</title>

      <para>I started writing this book in August 2022 as a quick reference
      for myself and other third party developers writing Joomla 4 extensions,
      or migrating our extensions to Joomla 4's native MVC.</para>

      <para>While Joomla 4 has an amazing, rich and powerful architecture and
      API it does not have any real developer-facing documentation. The
      documentation you will find is outdated, chaotic and leaves you running
      for your life.</para>

      <para>I am making every effort to make this book approachable to all
      levels of developers, from the novice who's barely hacked together their
      first plugin to the seasoned expert with dozens of extensions under
      their belt. However, to keep things relatively simple and because I am
      doing this unpaid, on my limited free time, I decided to take a few
      shortcuts here and there. I do not explain every concept in great
      detail, I try to explain it in practical detail.</para>

      <para>If you want to see what a real world Joomla extension looks like I
      urge you to take a look at and dissect the Joomla 4 extensions my
      company, Akeeba Ltd, has published free of charge. The simplest
      component to start with is Akeeba ContactUs. The most complete
      combination of a component, plugins and several modules we have
      published is Akeeba Ticket System — even the free of charge version uses
      most of the features I am describing in this book.</para>

      <para>Hopefully, you will find my approach pragmatic and result–driven
      instead of a dry, technical document. If you have suggestions for
      improvement or would like to sponsor this work feel free to contact me
      through the Contact Us page on <link
      xlink:href="https://www.akeeba.com">akeeba.com</link> or the Contact Me
      page on <link
      xlink:href="https://www.dionysopoulos.me">dionysopoulos.me</link>.</para>
    </section>

    <section xml:id="about-me">
      <title>About the author</title>

      <para>Hi, I am Nicholas. I am a Mechanical Engineer turned Software
      Engineer. I am from and still live in Greece with my wife, daughter and
      our two naughty cats.</para>

      <para>I've been into computers since I was 11 years olds, at the dawn of
      the 1990s. Back then dinosaurs were still walking among us, haircuts
      were <emphasis>weird</emphasis>, personal computers were the size of a
      small backpack and had <emphasis>far less</emphasis> computing power
      than your average smart lightbulb. Only one of the previous statements
      is false. I immediately took to programming for, as I said to my parents
      at the time, “I want to learn how to make this machine do things for me
      so I don't have to do them”. LIttle did I know what I was getting myself
      into…</para>

      <para>I've been using Joomla as a site integrator and extensions
      developer since it was called Mambo, back in 2004. I wrote my first
      mass–distributed extension called JoomlaPack in October 2006 while
      taking a two week break from my day job at the time as a business
      consultant. One thing led to another, JoomlaPack became Akeeba Backup
      and I gave up on business consultancy and mechanical engineering to
      become a full time software engineer.</para>

      <para>I've been actively participating in the Joomla community since
      2009. I am a regular Joomla contributor and not just writting code. I've
      been involved in community outreach efforts and instigated the events
      leading to the beginning of the Joomla 4 effort. I still contribute to
      Joomla and, if I want to be honest with myself, I will continue doing
      that until Joomla or myself is no more, whichever comes first.</para>

      <para>I am neurodivergent (ADHD) and have a particular sense of humour.
      I firmly believe that life's too short to take it seriously. You'll see
      that a lot in this book. I don't care about writing a dry, boring book,
      especially on a subject as dry and boring as writing software.</para>
    </section>

    <section xml:id="intro-j4-features">
      <title>New Joomla 4 features at a glance</title>

      <para>Joomla 4 is a smorgasbord of new features, improvements and much
      needed changes. Unfortunately, a year into its release you'd be hard
      pressed to find any kind of documentation of what these are and how they
      can impact your software development practices. I will try to give you
      the 30,000–feet overview of what <emphasis>I</emphasis> found to be the
      most important changes.</para>

      <para><link linkend="concepts-namespaces"><emphasis
      role="bold">Namespaces</emphasis></link>. As you may remember, ever
      since Joomla 3.3 the legacy class names (e.g. <code>JUri</code>) changed
      to a namespaced equivalent (e.g. <code>Joomla\CMS\Uri\Uri</code>). In
      Joomla 4 a lot of the legacy classes stopped working. You can find out
      these changes neatly codified along with tools to mass convert your
      extensions in my <link
      xlink:href="http://github.com/nikosdion/joomlatypehints">Joomla Type
      Hints</link> repository. In Joomla 4 the namespacing work went even
      deeper, having all classes in components, modules, plugins and templates
      also support namespaces — if you use the new, Joomla 4 API for
      developing extensions. This is a game-changer concept! Namespaced
      classes follow the <link
      xlink:href="https://www.php-fig.org/psr/psr-4/">PSR-4</link>
      specification. Joomla caches and registers the PSR-4 mappings between
      namespace prefixes and directories on your site which means that
      <emphasis>you can safely use any class of any extension anywhere without
      having to use <code>include</code> or <code>require</code> ever
      again</emphasis>. This greatly reduces the possibility for bugs and
      massively improves the performance of Joomla and its extensions.</para>

      <para><emphasis role="bold"><link
      linkend="concepts-container">Dependency Injection Container / Service
      Locator</link></emphasis>. Joomla 1.x to 3.x inclusive had this annoying
      <link xlink:href="https://en.wikipedia.org/wiki/God_object">God
      Object</link> called the Joomla Factory (<code>JFactory</code> or
      <code>\Joomla\CMS\Factory</code>). It had a very opinionated approach on
      instantiating all sorts of globally used services, from the application
      itself, to the database, to the user objects, to the mailer object. If
      you wanted to write Unit Tests for your extension — or Joomla itself —
      it was the bane of your existence. In Joomla 4 we instead have a
      Container. It is not a real <link
      xlink:href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency
      Injection Container</link> as much as it is a <link
      xlink:href="https://en.wikipedia.org/wiki/Service_locator_pattern">Service
      Locator</link>, meaning that it won't magically instantiate an object
      based on the type definitions in its class' constructor but it will let
      you retrieve the services you need to inject to your objects. Each
      extension — component, module, plugin and template — gets its own
      service locator and its own extension object which uses it. This makes
      it far easier to write unit tests for your code, especially your Models
      (which is where most of your business logic, therefore your code that
      needs testing, should already be).</para>

      <para><link linkend="concepts-webassetmanager"><emphasis role="bold">Web
      Asset Manager</emphasis></link>. In the past, whenever we wanted to load
      a JavaScript or CSS file we'd have to load its dependencies and finally
      our file. For example we might want to load jQuery, then load some
      Bootstrap core JavaScript files, then our JavaScript file. Each
      extension would do that and it lead to several chicken and egg problems.
      What if file A from extension X depends on files B and C and file B from
      extension Y depends on files C and D but D must be loaded before C?
      Bummer. The Web Asset Manager codifies the dependencies in a way which
      lets Joomla resolve them. It also lets you define alternative
      dependencies,e.g. a different JavaScript file to load depending on
      whether the user's browser supports <link
      xlink:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript
      modules</link> or not, and asset groups, e.g. a collection of CSS and
      JavaScript which are meant to be loaded together. This lets you split
      your CSS and JavaScript into smaller files which load in the correct
      order and improve the performance of your user's site.</para>

      <para><emphasis role="bold"><link linkend="com-j3-vs-j4-mvc">A new
      MVC</link></emphasis>. The MVC in Joomla 1.5 to 3.10 inclusive had
      changed very little. Previous attempts to modernise it failed
      ignominiously because they simultaneously failed to go far enough and
      maintain <acronym>b/c</acronym> (backwards compatibility). Joomla 4 has
      a new MVC model which is based on Dependency Injection and namespaces,
      it is more prescriptive, more flexible and more powerful than its
      predecessors. You can very easily extend a frontend model from a backend
      model instead of writing the same code twice or doing a contortionist
      act with PHP Traits. You can easily create custom HTML helpers without
      calling static functions, use categories without writing precarious
      database code, create object-oriented URL routers and much more which we
      will explore in this book.</para>

      <para><emphasis role="bold">Hide-able inline help</emphasis>. Remember
      how Joomla 3 XML Forms looked like a word vomit with all the inline help
      text (field descriptions) being always visible? This was a bad interface
      for experienced users. At the same time, Joomla 4.0 removing all inline
      help text made the interface inapproachable for newcomers and end
      clients meant to use the site. With Joomla 4.1 it is now possible to
      have hide-able inline help text in your forms and your component
      configuration. The field descriptions are hidden by default and the user
      can show them by clicking on the <guibutton>Show Inline Help</guibutton>
      button in the interface. Now your extensions' interface can be
      simultaneously approachable for both new and experienced users.</para>

      <para><emphasis role="bold">Prepared statements</emphasis>. SQL
      injection vulnerabilities have been almost <emphasis>de
      rigueur</emphasis> for any web software, Joomla extensions being no
      exception to that. Sure, Joomla does have some very nifty tools to get
      filtered input and escape it when placed inside database queries but not
      all input can be escaped sufficiently if you do not know its
      <emphasis>type</emphasis> (integer, string, array of one or the other).
      Moreover, despite best intentions, accidents can and do happen, e.g.
      forgetting to escape one piece of input you assumed it's an integer but
      it came through a path which never did check the input type nor did it
      try to typecast it to an integer! Joomla 4 introduced <link
      xlink:href="https://en.wikipedia.org/wiki/Prepared_statement">prepared
      statements</link> which make these oversights and corner cases a thing
      of the past. You tell the query builder where you expect potentially
      user-originating data in your query, which data to use in there and what
      type this data is. You are guaranteed safe execution without worrying
      about SQL injection <emphasis>unless you try really hard</emphasis> to
      NOT let Joomla use a prepared statement. On the flip side, there are a
      few types of SQL queries which cannot execute in the context of prepared
      statements and required some code contortion to execute.</para>

      <para><link linkend="com-mailtemplates"><emphasis role="bold">Mail
      templates</emphasis></link>. In the past there were two ways to handle
      email for your extension. You could send plain text only email using
      language strings OR you would have to invent your own email template
      management. The former led to ugly email messages. The latter required
      reinventing a very complex device on each and every of your components.
      If you did not have a component, tough luck. Darn! Joomla 4's mail
      templates feature allows your users to use the Joomla WYSIWYG editor to
      create rich email templates with placeholders to be replaced by data
      provided by your extension. This feature looks half-finished in Joomla 4
      as it has no obvious way to register or update email templates. Don't
      worry, though, we do have a way to work around its shortcomings,
      complete with example code.</para>

      <para><link linkend="com-scheduled-tasks"><emphasis
      role="bold">Scheduled Tasks</emphasis></link>. Many extensions need to
      periodically execute some kind of code. For example, sending email
      newsletters, updating the prices of thousands of SKUs in an online shop
      from an Excel or XML file, running backups, you name it! In the past we
      had to reinvent the wheel on each extension we built. For example, we
      created ‘special’ URLs in our components or through com_ajax to be
      accessed with wget, cURL or a service like WebCRON.org periodically; or
      we created CLI scripts to be used with CRON jobs. We almost always
      offered more than one way to do things which led to a certain degree of
      code duplication. In all cases, the user was responsible for setting up
      CRON jobs or the equivalent on a third party service for every single
      task they needed to be executed periodically. This was a tall ask!
      Joomla 4.1 and later offers a new Scheduled Tasks feature which allows
      users to select which tasks they want to be executed, when to execute
      them and even configure their execution parameters — all within the
      familiar Joomla user interface. It even lets the task scheduler to be
      executed three ways: with a command line CRON job, a URL–based CRON job
      or automatically based on visitor traffic (lazy scheduling). The end
      user has to set up just the one CRON job or, if they are using lazy
      scheduling, just flip a switch.</para>

      <para><link linkend="com-cli"><emphasis role="bold">CLI
      Application</emphasis></link>. In the past we had to create bespoke CLI
      scripts for every task each of our extensions needed to allow to be
      executed from a command line context, be it a CRON job or a manually
      executed CLI helper tool. This required creating a new application and
      contend with the two facts that a) the base class changed at least twice
      in the last ten years and b) it lacked a lot of methods several core and
      third party classes were expecting to be present. This led to a lot of
      reinventing the wheel. The Joomla CLI Application is like a built-in
      version of WordPress' WP-CLI or Drupal's Drush in that it's based on the
      Symfony Console Components and can be easily extended using plugins
      which register command classes. Used wisely, it can enhance your
      extensions and help your advanced users who can use the CLI to automate
      things around their site.</para>

      <para><link linkend="com-api"><emphasis role="bold">API
      Application</emphasis></link>. Joomla has historically been an HTML–only
      application. Yes, sure, you can have JSON, XML, Feed and Raw views but
      they feel bolted onto the HTML application; they are not a real API to
      your component. Joomla 4 introduced a brand-new application, the
      ApiApplication which lives in the <filename>api</filename> directory of
      your site. For now it's only accessible to Super Users but it provides a
      real RESTful JSON-based API to components which integrate with it.
      Integrating your component with the API application is as easy as
      creating a Web Services plugin and adding a few easy to create
      controllers and views in the API part of your component. That is to say,
      your component now has a backend, a frontend and an API side. You don't
      <emphasis>have</emphasis> to integrate with the API application but if
      you have something which could benefit from automation it is strongly
      encouraged to do so.</para>

      <para><emphasis role="bold">Dashboards</emphasis>. Between Joomla 1.0
      and 3.10 inclusive Joomla only ever offered one dashboard, the main
      Control Panel page which loaded when you logged into your site's
      backend. In Joomla 1.0 to 1.6 it was hard–coded and inflexible. I added
      the ability to use plugins to render custom action buttons in Joomla
      1.7, based on my experience with my software. Starting with Joomla 3.0
      you could now publish <emphasis>modules</emphasis> to add information
      panes to the Control Panel dashboard. If you wanted the same experience
      in your extension… tough luck. You would have to reinvent the wheel.
      Joomla 4.0 and later allow you to set up <emphasis>one or more dashboard
      pages for your own component</emphasis> which appear in the Joomla menu
      structure, under your component's menu item, and where you and your end
      users can publish any number of modules.</para>

      <para><emphasis role="bold">Layouts everywhere</emphasis>. A lot of the
      HTML generated by Joomla, even throughout version 3, was statically
      coded in the PHP files implementing the business logic, making any kind
      of customisation impossible (or, at the very least, requiring a very
      judicious application of in-memory code editing, buffer stream wrappers
      and Reflection). Let's just say that if you disagreed with how a certain
      form field or HTML helper rendered its HTML you were out of luck.
      Layouts were introduced in Joomla 3.4 and later versions did make better
      use of them in various places but you still had to contend with several
      of the same issues. Not anymore! Joomla 4 uses layouts for every kind of
      HTML output. If you want to override how some core code renders in your
      component or your template you can easily do that by overriding the
      layout. Likewise, you are encouraged to use Layouts everywhere you have
      reusable HTML output in your extensions to make it easier for end users
      to override them in their template.</para>

      <para><emphasis role="bold">Media options per component</emphasis>.
      Joomla 3.4 introduced an upload checker for all uploaded files based on
      the work I had done in Admin Tools. This was a massive leap in security
      as we codified the basic upload checks and encapsulated them in a way
      that made them run automatically whenever you were handling uploads.
      However, this was controlled by the Media component's
      (<code>com_media</code>) settings. This was great if your extension only
      ever needed static media files to be uploaded. If you wanted to allow
      your users to upload non–media files, or files otherwise not acceptable
      anywhere else <code>com_media</code> was exposed, such as ZIP, 7Z, and
      RAR files in a helpdesk component, you had to modify the Media options,
      allowing these files <emphasis>everywhere</emphasis>. The unfortunate
      solution to that was that third party component developers chose to
      <emphasis>disable</emphasis> the upload checks, undoing the security
      improvements we added in Joomla 3.4. This is no longer the case! Joomla
      4 allows each component to have its own, private copy of Media settings
      for its own uploads. Any upload being handled by your component (not
      <code>com_media</code>!) will have these private settings applied. It's
      a bit of a chore BUT it lets you provide a much safer option for
      uploading files through your extension.</para>

      <para>There are many more improvements which I will not cover in this
      book. If you found out something cool and you'd like me to write a
      section for it, please do let me know. I can't promise it will
      definitely make it into the book but I will at least promise to give it
      a good thought and most likely a good try.</para>
    </section>
  </chapter>

  <chapter xml:id="concepts">
    <title>Basic concepts</title>

    <para>As mentioned in the <link linkend="intro-j4-features">previous
    chapter</link>, Joomla 4 introduced a lot of new features. Some of these
    features introduce new fundamental concepts or refine existing ones.
    Before delving deeper into Joomla extension development let's take a look
    at these basic concepts to make sure we are all on the same page.</para>

    <section xml:id="concepts-namespaces">
      <title>Namespaces</title>

      <para>The single most defining change in Joomla 4 is that Joomla
      embraces <link
      xlink:href="https://www.php.net/manual/en/language.namespaces.php">PHP
      namespaces</link> everywhere: core, core extensions, third party
      extensions and everything in between.</para>

      <bridgehead>The core</bridgehead>

      <para>The work on namespacing core Joomla API classes had started since
      Joomla 3.3. If you have not updated your code the last few years you may
      have found that it no longer works on Joomla 4. Do not despair! The vast
      majority of issues comes from your using outdated, non-namespaced
      versions of core classes in your code. Replacing them with their
      namespaced versions will let most Joomla 3–only extensions to run well
      enough in Joomla 4 for a migration to be practical.</para>

      <para>I have collected the old, non-namespaced core classes and the new,
      namespaced names of them along with the Joomla version the namespaced
      versions appeared and the Joomla version the non-namespaced versions are
      or will be removed in <link
      xlink:href="https://github.com/nikosdion/joomlatypehints/blob/main/JoomlaObsoleteClasses.md">my
      Joomla Type Hints</link> repository. The repository also includes <link
      xlink:href="https://getrector.org">Rector</link> configurations which
      allow you to do most of the heavy lifting using an automated tool. For
      everything else you need some good old search and replace across your
      source trees.</para>

      <bridgehead>The extensions</bridgehead>

      <para>The story of Joomla 4 began on the last day of May 2015 in Prague,
      Czech Republic at a round table discussion about the future of Joomla. A
      dozen or so leadership members, core contributors and third party
      developers sat down to figure out why Joomla “sucks” and how to improve
      it.</para>

      <para>Beyond the user-facing issues, we found out that the core MVC and
      architecture were extremely dated. The core MVC started being developed
      in 2005 and made its first appearance in 2007, with Joomla 1.5. It had
      not changed much, despite some moderate improvements in Joomla 1.6 which
      was released in 2010 (e.g. XML Forms) and a few disparate things added
      here and there (e.g. Tags in 3.2, Layouts in 3.4 and so on). You could
      not reference frontend code from the backend or vice-versa. For third
      party extensions this was an annoyance which led to duplicated code and
      bugs. For using core code, like creating articles <emphasis>the right
      way</emphasis> using <code>com_content</code>'s Article model, it was
      nearly impossible: if you tried doing that on a page which had already
      loaded the front-end ContentModelArticle class you could no longer load
      the same–named but entirely differently operating backend class.</para>

      <para>The way to solve that would be to <emphasis>namespace</emphasis>
      the extensions' code. A com_example extension could have the namespace
      prefix \MyCompany\Example\Administrator for its backend classes and
      \MyCompany\Example\Site for its frontend classes. This way you could
      have something like:</para>

      <programlisting>namespace \MyCompany\Example\Site\Model;

class ItemModel extends \MyCompany\Example\Administrator\Model\ItemModel
{
   // ...
}</programlisting>

      <para>By being able to extend classes across application sides you would
      finally be able to get rid of duplicate code and obliterate bugs coming
      from that bad practice.</para>

      <para>By following the <link
      xlink:href="https://www.php-fig.org/psr/psr-4/">PSR-4</link> standard we
      could also have a very efficient autoloader which allows us to load any
      extension's classes from anywhere, without having to know where on the
      filesystem the class file lives and without having to use the ugly
      static methods of the core MVC classes (which, by the way, would NOT
      work predictably across extensions because of their dependence on the
      <code>JPATH_COMPONENT_ADMINISTRATOR</code> and
      <code>JPATH_COMPONENT</code> constants which cannot, of course, be
      redefined).</para>

      <para>Each extension's namespace is declared in the XML manifest of the
      extension using a new XML element under the
      <code>&lt;extension&gt;</code> root element:</para>

      <programlisting>&lt;namespace path="src"&gt;My\Namespace\Prefix&lt;/namespace&gt;</programlisting>

      <para>The <code>path</code> attribute tells Joomla which subdirectory of
      your extension holds the PSR-4 of your extension's PHP files. It is best
      practice to name it <filename>src</filename> but <emphasis>you don't
      have to</emphasis>. In the rest of this section I assume you are using
      <filename>src</filename>.</para>

      <para>The text inside the XML element, <code>My\Namespace\Prefix</code>
      in our example, is the namespace prefix you will be using.</para>

      <para>Here is how namespace prefixes work across different types of
      extensions:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Component, frontend</emphasis>. Each
          component can register its own namespace prefix without any
          restrictions. It is <emphasis>recommended</emphasis> to use the
          convention <code>\Company\Something</code> where
          <code>Company</code> is your company name (or a shortened version
          thereof) and <code>Something</code> corresponds to the
          <code>com_something</code> extension name of your component. For
          example, the component <code>com_example</code> by Acme, Inc could
          have a namespace prefix of <code>\Acme\Example</code> set up in its
          XML manifest. In this case its frontend classes MUST be under the
          namespace <code>\Acme\Example\Site</code>. The folder
          <filename>components/com_example/src</filename> is the root of the
          <code>\Acme\Example\Site</code> namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Component, backend</emphasis>. Let's say
          we have the component <code>com_example</code> by Acme, Inc which
          has a namespace prefix of <code>\Acme\Example</code>. In this case
          its backend classes MUST be under the namespace
          <code>\Acme\Example\Administrator</code>. The folder
          <filename>administrator/components/com_example/src</filename> is the
          root of the <code>\Acme\Example\Administrator</code>
          namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Component, API application</emphasis>.
          The API application is the third Joomla application (the other two
          being Site the frontend, and Administrator the backend). We'll talk
          about it <link linkend="com-api">later in this book</link>. Let's
          say we have the component <code>com_example</code> by Acme, Inc
          which has a namespace prefix of <code>\Acme\Example</code>. In this
          case its API application classes MUST be under the namespace
          <code>\Acme\Example\Api</code>. The folder
          <filename>api/components/com_example/src</filename> is the root of
          the <code>\Acme\Example\Api</code> namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Module, frontend</emphasis>. A frontend
          module mod_example MUST have its classes under the namespace
          <code>Joomla\Module\Example\Site</code>. The namespace you MUST
          declare in the XML manifest is <code>Joomla\Module\Example</code>.
          Even though you are severely restricted in the namespace prefix you
          can use, you MUST provide it in your XML manifest or your module
          won't work! The folder <filename>modules/mod_example/src</filename>
          is the root of the <code>Joomla\Module\Example\Site</code>
          namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Module, backend</emphasis>. A backend
          module mod_example MUST have its classes under the namespace
          <code>Joomla\Module\Example\Administrator</code>. The namespace you
          MUST declare in the XML manifest is
          <code>Joomla\Module\Example</code>. Even though you are severely
          restricted in the namespace prefix you can use, you MUST provide it
          in your XML manifest or your module won't work! The folder
          <filename>administrator/modules/mod_example/src</filename> is the
          root of the <code>Joomla\Module\Example\Administrator</code>
          namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Plugin</emphasis>. The plugin
          <code>plg_system_example</code> MUST have its classes under the
          namespace <code>Joomla\Plugin\System\Example</code>. The namespace
          you MUST declare in the XML manifest is
          <code>Joomla\Plugin\System\Example</code>. Even though you are
          severely restricted in the namespace prefix you can use, you MUST
          provide it in your XML manifest or your plugin won't work! The
          folder <filename>plugins/system/example/src</filename> is the root
          of the <code>Joomla\Plugin\System\Example</code> namespace.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Template</emphasis>. Well, Joomla does
          NOT register a namespace for templates. You are encouraged to use
          namespaces for any template–specific code (you certainly have some
          helpers, don't you?) BUT Joomla won't facilitate you with any
          autoloading. You will have to register your template's namespace
          directly with the <code>JLoader::registerPrefix</code> method. It is
          a good practice putting your namespaced PHP files in the
          <filename>src</filename> directory and use the namespace
          <code>\Joomla\Template\Site\Something</code> for frontend templates
          and <code>\Joomla\Template\Administrator\Something</code> for
          backend templates. Please note that there is no real guidance for
          the template names BUT we can infer what any future change adding
          namespace support to templates will most likely be based on how
          modules are namespaced and Joomla trying to have a modicum of
          consistency.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="concepts-container">
      <title>Dependency Injection Container / Service Locator</title>

      <para>Joomla had historically been quite a mess, architecturally
      speaking. Its saving grace was that it was a far smaller mess than
      WordPress and much more approachable to non–expert coders than Drupal.
      This let it carve a niche for itself: people who wanted a very powerful
      site without having to first acquire a PhD in Computer Science and/or
      have a team of dozens of developers under them. In short, Joomla's
      bad–but–not–too–bad architecture let it be used by small web design
      firms, freelance site integrators and small but serious software
      development firms.</para>

      <para>That said, Joomla 1.x to 3.x inclusive had a <link
      xlink:href="https://en.wikipedia.org/wiki/God_object">God Object</link>
      called the Joomla Factory (<code>JFactory</code> or
      <code>\Joomla\CMS\Factory</code>) with a very opinionated approach on
      instantiating all sorts of globally used services, from the application
      itself, to the database, to the user objects, to the mailer
      object.</para>

      <para>While this is a better approach to using global variables (like
      WordPress' infamous <code>$wpdb</code> for accessing the database), this
      architecture caused a lot of pain when you wanted to write Unit Tests
      for your code. Your code gets user instances? You need to create a mock
      for the entire Factory object returning mock user objects. Your code
      uses the database? You need to create a mock database object and inject
      it to an uninitialised Factory instance using static class variables.
      Your code sends email? Not only you need a mock mailer object, you need
      to mock the Factory too. Want to write tests which mock different things
      in different tests? You can either forget about running your tests as a
      suite OR you need to create an extremely over-reaching and hard to
      configure mock Factory. Your tests must run in a different order? Good
      luck figuring out the bugs in your Factory mock object and why running
      tests in one order works but fails when run in a different order, or on
      their lonesome. Been there, done that, still paying for therapy…</para>

      <para>In Joomla 4 we no longer have a God Object. Well, to be fair, the
      Factory is still there but it is no longer a God Object; it is an
      interface to a <link
      xlink:href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency
      Injection Container</link> (<acronym>DIC</acronym> for short, pronounced
      like Dee Eye See, not the nickname for a Richard, thank you very much).
      So, Factory is still a God Object but with lesser powers. A minor deity
      object, perhaps? In any case, the Container is initialised before
      Factory is used and it can also be replaced. Therefore you only need to
      get a copy of the DIC and replace one or more of its services with a
      mock object when writing Unit Tests. Much easier, much more robust, no
      more therapy necessary after writing Unit Tests.</para>

      <para>The Container is now the preferred way to get access to several
      services previously available only through the Factory (they are still
      available through the Factory in Joomla 4 but will very likely disappear
      in Joomla 5). Let's see a few practical examples:</para>

      <programlisting>use \Joomla\CMS\Factory;

// Instead of Factory::getDbo();
$db = Factory::getContainer()-&gt;get('DatabaseDriver');

// Instead of Factory::getLanguage(); WARNING! STILL DOES NOT WORK EXACTLY AS INTENDED!
$language = Factory::getContainer()-&gt;get(LanguageFactoryInterface::class)-&gt;createLanguage(
  Factory::getApplication()-&gt;get('language'),
  Factory::getApplication()-&gt;get('debug_lang'),
);

// Instead of Factory::getUser($id)
$user = Factory::getContainer()-&gt;get(UserFactoryInterface::class)-&gt;loadUserById($id);

// Instead of Factory::getUser() with no arguments; note that this does NOT go through the DIC!
$currentUser = Factory::getApplication()-&gt;getIdentity();</programlisting>

      <para>That said, Joomla's DIC is not a real DIC; it is in fact a <link
      xlink:href="https://en.wikipedia.org/wiki/Service_locator_pattern">Service
      Locator</link>. That is to say, you don't ask the DIC to construct an
      object and expect it to inject the appropriate dependencies based on the
      class type hints of the constructor's arguments. In theory it can (kind
      of), but in practice this is NOT how the Joomla core API classes are
      written. If you came here expecting a DIC like what you find in Laravel,
      sorry, I have to disappoint you.</para>

      <para>Now, you are thinking, does this not make the DIC kinda useless?
      No, not really. You see, being a Service Locator you get a
      <emphasis>copy</emphasis> of it when your extension is initialised. In
      fact, each native Joomla 4 extension needs to have a Service Provider
      which takes the DIC copy as input and registers services to it. At the
      very least you will be registering your extension service which is used
      by Joomla to instantiate your extension's object and run its code. You
      can also register any number of services you might need, even custom
      ones only to be used by your extension.</para>

      <para>At some point in the future Joomla will MAYBE remove the Factory,
      if not altogether then at least insofar it can only return the main
      application's DIC. In such a future Joomla will VERY PROBABLY make it
      much easier for an extension's internal classes to have access to its
      own DIC / Service Locator instead of only ever making it available to
      the Extension class. In this potential future Joomla extensions will be
      self-contained and perfectly testable. Even better, they can be sure
      that whatever happens in an extension stays in the extension, without
      leaking to the global application scope (and poison other
      extensions).</para>
    </section>

    <section xml:id="concepts-webassetmanager">
      <title>Web Asset Management</title>

      <para>A large part of our work as Joomla extension developers is to load
      static assets, CSS and JavaScript files, in the user-facing HTML output
      of our extensions.</para>

      <para>In older Joomla versions we did that through the HTML document and
      using HTMLHelper static methods to load dependencies. For
      example:</para>

      <programlisting>$doc = \Joomla\CMS\Factory::getApplication()-&gt;getDocument();
Joomla\CMS\HTML\HTMLHelper::_('bootstrap.tooltip', '.hasTooltip');
Joomla\CMS\HTML\HTMLHelper::_('script', 'com_example/something.js', [
	'version'       =&gt; 'auto',
	'relative'      =&gt; true,
	'detectDebug'   =&gt; false,
	'framework'     =&gt; false,
	'pathOnly'      =&gt; false,
	'detectBrowser' =&gt; false,
], [
	'defer' =&gt; true,
	'async' =&gt; false,
]);
</programlisting>

      <para>This has a few shortcomings, as we have all discovered to our
      despair.</para>

      <para>First of all, we need to remember to load all dependencies in the
      correct order before our own CSS or JavaScript file. In the above
      example, the something.js file depends on Bootstrap's Tooltip helper. If
      we forget the first call to HTMLHelper our JavaScript file will be
      broken.</para>

      <para>However, our extension is not the only thing running on the page,
      right? Now, see the second parameter in that first HTMLHelper call? It
      tells Joomla's Bootstrap HTML helper to initialise the Tooltip helper so
      that anything with the class hasTooltip will have a Bootstrap tooltip.
      Since this is a component we are confident that this will always be the
      case. Oh, really? If a plugin ran before us and it also loaded its own
      JavaScript which also depends on Bootstrap's tooltip BUT had no second
      argument (or a different second argument) do you care to guess what our
      code above will do? If you guessed “sod all” you'd be right and a Joomla
      extensions development veteran! So, yup, a third party extension having
      a JavaScript file with the same dependency as ours running before us
      breaks our perfectly working JavaScript. This could even happen within
      the same extension if the aforementioned code appeared in a layout and
      your page just happens to load two layout which both call
      <code>Joomla\CMS\HTML\HTMLHelper::_('bootstrap.tooltip')</code> with a
      different second parameter. Great!</para>

      <para>Beyond that, what happens if our something.js gains another
      dependency and we are loading this file in six different places… but
      missed updating one of them? Why, yes, that sixth page will be broken!
      Even worse, we might only update our code with the additional dependency
      in one place (let's say a layout), another four places not updated work
      because they are loading that changed layout and the sixth and final
      place does not work because it was neither updated nor trying to load
      something else which loads the dependency for us.</para>

      <para>Let's put it this way. If you do manual dependency management you
      will be in a world of pain, sooner rather than later.</para>

      <para>Joomla 4 addresses this problem by introducing the Web Asset
      Manager (WAM). The WAM is responsible for loading our CSS and JavaScript
      files <emphasis>and their dependencies</emphasis>. It can figure out
      simple dependency chains even across multiple extensions and make sure
      that things are loaded in an order that makes sense and will do what we
      wanted it to do.</para>

      <para>For that to work we need two things:</para>

      <orderedlist>
        <listitem>
          <para>Using Joomla's media directory the way it was intended ever
          since its introduction in Joomla 1.5.0, back in 2007.</para>
        </listitem>

        <listitem>
          <para>A <filename>joomla.assets.json</filename> file which describes
          our static assets and their dependencies.</para>
        </listitem>
      </orderedlist>

      <para>On the first point please let me remind you how the media folder
      works. If you have any static assets which must be web accessible they
      <emphasis role="bold">MUST</emphasis> be placed in a subdirectory of the
      <filename>media</filename> folder named after your extension (as Joomla
      names it internally). Don't put them in your extension's directory,
      don't put them in <filename>cache</filename> or <filename>tmp</filename>
      (they are NOT web accessible, they CAN be moved around even outside the
      web root AND their contents can and will be removed anytime).</para>

      <para>You have a component named <code>com_foobar</code>? Put your
      static assets in <filename>media/com_foobar</filename>. You have a
      module named <code>mod_example</code>? Put your static assets in
      <filename>media/mod_example</filename>. You have a plugin named
      <code>example</code> in the <filename>folder</filename> system? Put your
      static assets in <filename>media/plg_system_example</filename>. You have
      a template named <code>beauty</code>? Put your static assets in
      <filename>media/tpl_beauty</filename>. Its subdirectories are
      <filename>css</filename> for CSS files and <filename>js</filename> for
      JavaScript files. It's simple, it's efficient, it's how Joomla is meant
      to work.</para>

      <para>The second point, the <filename>joomla.assets.json</filename>
      file, tells Joomla where to find what, what depends on what else and how
      it all fits together. This file is placed in the extension's media
      subdirectory.</para>

      <para>For example, a component <code>com_example</code> could have a
      <filename>media/com_example/joomla.asset.json</filename> file which
      looks like this:</para>

      <programlisting>{
  "$schema": "https://developer.joomla.org/schemas/json-schema/web_assets.json",
  "name": "com_example",
  "version": "1.0.0",
  "description": "This file contains details of the assets used by the Example component by Acme, Inc.",
  "license": "GPL-2.0-or-later",
  "assets": [
    {
      "name": "com_example.backend",
      "description": "Backend styling.",
      "type": "style",
      "uri": "backend.min.css",
      "dependencies": [
        "com_example.typography"
      ]
    },
    {
      "name": "com_example.typography",
      "description": "Fancy typography.",
      "type": "style",
      "uri": "typography.min.css",
      "dependencies": [
        "fontawesome"
      ]
    },
    {
      "name": "com_example.backend.items",
      "description": "JavaScript for the backend Items page.",
      "type": "script",
      "uri": "backend_items.js",
      "attributes" : {
        "defer": true
      },
      "dependencies": [
        "core"
      ]
    },
    {
      "name": "com_example.backend.items",
      "type": "preset",
      "dependencies": [
        "com_example.backend#style",
        "com_example.backend.items#script"
      ]
    }
  ]
}
</programlisting>

      <para>We declare various named assets. The
      <code>com_example.backend</code> style asset loads the
      <filename>backend.min.css</filename> file. However, that file depends on
      the <code>com_example.typography</code> asset which loads the
      <filename>typography.min.css</filename> file. In its turn, this asset
      depends on the core <code>fontawesome</code> asset which loads the
      FontAwesome icon font in any way Joomla figures out is
      appropriate.</para>

      <para>When we tell Joomla to load the <code>com_example.backend</code>
      style asset it will first load the CSS files for FontAwesome (if our
      backend template has not already loaded it), then our
      <filename>typography.min.css</filename> file and finally our
      <filename>backend.min.css</filename> file. This all happens
      automatically. All we have to do in our extension's template layout code
      is</para>

      <programlisting>$this-&gt;document-&gt;getWebAssetManager()-&gt;useStyle('com_example.backend');</programlisting>

      <para>If at a later point we decide that the backend style needs to
      depends on yet another CSS asset we will add it to its dependencies
      array in the <filename>joomla.asset.json</filename> file <emphasis>and
      we are done</emphasis>. We do not have to touch our view templates. We
      do not have to think about anything else. Joomla will figure it out. No
      more hard to track down bugs!</para>

      <para>You may have noticed that we also declared a script asset called
      <code>com_example.backend.items</code> which loads the file
      <filename>backend_items.js</filename> deferred. Deferred means that we
      tell the browser to load it after it has finished initialising the DOM.
      This means that we do not need to add any special code to execute
      something after the DOM is initialised which saves us a lot of
      frustration and bugs. We use the script resource like this:</para>

      <programlisting>$this-&gt;document-&gt;getWebAssetManager()-&gt;useScript('com_example.backend.items');</programlisting>

      <para>We have told Joomla that our script only depends on
      <code>core</code>, i.e. the Joomla core JavaScript. This is not
      mandatory, but something you will see plenty of times because you'll be
      using <code>Joomla.getOptions</code> in your JavaScript code to retrieve
      settings <link linkend="com-data-to-frontend">passed from the backend to
      the frontend</link>. This is the recommended method instead of setting
      arbitrary JavaScript variables in inline JavaScript code. In fact, using
      inline JavaScript code is discouraged (but not forbidden) in Joomla 4
      and later.</para>

      <para>If at a later point we modify our JavaScript to also depend on
      Bootstrap's Modal dialog helper we will just update its
      dependencies:</para>

      <programlisting>    {
      "name": "com_example.backend.items",
      "description": "JavaScript for the backend Items page.",
      "type": "script",
      "uri": "backend_items.js",
      "attributes" : {
        "defer": true
      },
      "dependencies": [
        "core",
        "bootstrap.modal"
      ]
    }</programlisting>

      <para>That's it! No more hunting down usages of this JavaScript file and
      updating our view template code.</para>

      <para>You can of course tell Joomla to load both CSS and JavaScript
      assets. The simplest way is being descriptive in our view
      template:</para>

      <programlisting>$this-&gt;document-&gt;getWebAssetManager()
  -&gt;useStyle('com_example.backend')
  -&gt;useScript('com_example.backend.items');</programlisting>

      <para>(note that useStyle and useScript return the WAM object which
      means they can be chain–called)</para>

      <para>However, this runs the same risk as loading assets the
      old-fashioned way. What happens if we decide that the Items page needs
      some extra CSS which does not apply to the rest of our component's
      backend? We'd have to edit the template layout file. Enter bugs.</para>

      <para>Instead of being descriptive we can be
      <emphasis>prescriptive</emphasis> using another WAM feature called
      <emphasis role="bold">presets</emphasis>. A preset consists entirely of
      dependencies. We declared it in our JSON file like this:</para>

      <programlisting>    {
      "name": "com_example.backend.items",
      "type": "preset",
      "dependencies": [
        "com_example.backend#style",
        "com_example.backend.items#script"
      ]
    }
</programlisting>

      <para>and we can load it in our view template very easily like
      this:</para>

      <programlisting>$this-&gt;document-&gt;getWebAssetManager()-&gt;usePreset('com_example.backend.items');</programlisting>

      <para>Note that the preset asset's key is the same as our script asset's
      key. Script, style and preset assets are separate collections which
      means we <emphasis>can</emphasis> reuse the same key across them. Joomla
      will not be confused. We tell it which collection to look into by using
      a different WAM method: <code>useScript</code>, <code>useStyle</code> or
      <code>usePreset</code>.</para>

      <para>Now let's see why presets are the bee's knees. Let's say we
      decided that Items also needs some special styling in a separate CSS
      file called <filename>items.min.css</filename>. We will just add this
      asset to our JSON file and update the preset:</para>

      <programlisting>    {
      "name": "com_example.backend.items",
      "description": "Backend styling just for the Items page.",
      "type": "style",
      "uri": "items.min.css",
      "dependencies": [
        "com_example.backend"
      ]
    },
    {
      "name": "com_example.backend.items",
      "type": "preset",
      "dependencies": [
        "com_example.backend#style",
        "com_example.backend.items#style",
        "com_example.backend.items#script"
      ]
    }
</programlisting>

      <para>(You may notice that our <code>com_example.backend.items</code>
      asset depends on <code>com_example.backend</code>. I didn't have to do
      that, but I like to be explicit about dependencies to avoid any stupid
      bugs if I remove any intermediate dependencies in a dependency
      chain.)</para>

      <para>We do NOT have to touch our view template file. Since we are
      telling it to load a preset, changing the preset is enough for Joomla to
      figure out what it needs to do.</para>

      <para>Using the Web Asset Manager correctly can be a massive asset (no
      pun intended!) in your extensions' public frontend. Your view templates
      can load your prescriptive presets. If you decide you want to change
      something you can change the preset. Your clients who have created
      template overrides will NOT need to update their overrides. This means
      far fewer “bug” reports and more time for you to work on your
      code.</para>

      <para>The Web Asset Manager has changed the way I write extensions and
      has solved a lot of my headaches. You can use the WAM on any component
      running on Joomla 4, regardless of whether you are using the “old”
      (Joomla 3) MVC or the “new” (Joomla 4) MVC. In fact, since it is a part
      of the Joomla document object, you can use it in modules, even plugins —
      however, if you are using it in a plugin you MUST tell the WAM to load
      your JSON file since Joomla will not do that by default for
      plugins.</para>

      <para>Finally, the WAM is a much less error–prone method to injecting
      static assets to Joomla. All Joomla document classes have a WAM, even
      when they are not HTML; it just follows that if it's a non–HTML document
      adding an asset through WAM does nothing. Compare that with what happens
      if you try to use the HTMLHelper or the addScript / addStyle document
      methods when your document is not HTML. Yup, these old ways of adding
      static assets cause Joomla to error out. Again, WAM is safe, the methods
      of yesteryear are not. One more reason to migrate your extensions to WAM
      today.</para>
    </section>
  </chapter>

  <chapter xml:id="com">
    <title>Components</title>

    <para>The Joomla component is arguably the most important extension type.
    It's not just the sheer fact that it is an application inside an
    application, letting us create custom experiences otherwise nearly
    impossible with just core code, it is also that Joomla embraces the need
    for this kind of custom experiences and has heavily invested in making
    component development relatively easy. This is in stark contrast with
    WordPress where your experience is far and foremost defined by its core
    code, custom experiences outside custom content types are actively
    discouraged and there is no sensible API for creating an equivalent
    extension type without a lot of reinventing the wheel, bending over
    backwards and judicious application of the Dark Arts.</para>

    <section xml:id="com-mvc">
      <title>The Joomla MVC: an introduction</title>

      <para>Joomla came with a strong legacy of modular architecture in
      version 1.0, when it was a little more than a fork of and improvement
      upon Mambo 4, its predecessor. Joomla 1.5 introduced extension
      developers to the concept of <link
      xlink:href="https://en.wikipedia.org/wiki/Model–view–controller">MVC</link>
      (Model-View-Controller) where each component has defined and logical
      structure, separating business logic from presentation. Joomla 4
      improves upon this legacy, by further polishing the MVC and embracing
      concepts introduced to the PHP developer's arsenal over the last decade
      and a half.</para>

      <para>Before delving into improvements and changes in Joomla 4 I think a
      little Joomla MVC refresher is in order. This is especially useful if
      you are used to the MVC definition from a college Computer Science class
      or have used real MVC in other programming languages or even PHP
      frameworks (e.g. in Laravel the typical Model is Eloquent which works
      completely differently, the View is your Blade files and the Controller
      is more of a collection of middleware rather than a single class — it's
      still MVC but a different dialect in the same way Spanish, Italian and
      French are all Romance languages).</para>

      <para>Joomla follows the MVC model typically called “skinny controller -
      fat model”. This puts most of the business logic into the Model and
      keeps the Controller a relatively nimble affair. Further to that, Joomla
      also uses another class called a Table to abstract our interaction with
      the persistence layer objects (that's a fancy, pretentious way of saying
      “database table”). So, it's really an MVCT approach.</para>

      <para>But what are these Controllers, Models and Views anyway?</para>

      <para>The Controller consists of one or more <emphasis>tasks</emphasis>
      implemented as public methods. Each one of them tells the controller to
      <emphasis>do</emphasis> something. For example display an article,
      publish or unpublish an article, delete an article, log in the user,
      check the Multi-factor Authentication provided by the user, create a
      user data deletion request and so on and so forth. Controllers are
      orchestrators; they know what work needs to be done but they do not do
      it themselves. The Controller handles requests: it reads the user input
      and decides what needs to happen next which is invariably one of two
      things. For simple tasks with no output like publishing an article,
      deleting an article, logging in a user etc it will get the Model, tell
      it what to do and then issue a redirection to a different page, possibly
      setting a (very short!) message to show to the user. Most of the time it
      will need to create a document, e.g. an HTML page, a JSON document, an
      RSS feed etc. In this case it will get the appropriate View, push the
      Model to it and ask it to render itself. It then takes the rendered
      document and echoes it; Joomla will intercept that and decide what to do
      with the document effectively returned by the Controller. If an error
      occurred the Controller will catch it and decide what to do with it:
      swallow it or push it up the stack so that it ends up becoming an error
      page for the user.</para>

      <para><emphasis>Note that unlike the normative Controller of the MVC
      pattern the Joomla component's Controller DOES NOT normally push data to
      the Model. Yes, this is a violation of the separation of concerns.
      However, addressing that would be a massive backwards compatibility
      break which would necessitate the rethinking and rewriting of all Joomla
      components, core and third party. As a result we are unlikely to ever
      see this changing.</emphasis></para>

      <para>The Model is the workhorse of the component. It has the
      <emphasis>business logic</emphasis>, i.e. it knows how to get things
      done. In most cases it is a data–aware model which means that it knows
      how to get stuff from the database, put stuff back to the database and
      perform other auxiliary functions with the database data. It does NOT
      handle any presentation logic, i.e. it will NOT output any HTML. It
      returns raw data whenever it is asked to. Therefore you can use a Model
      in any context: inside the component, in a CLI script, in the API
      application (which only handles and returns JSON data), a Scheduled
      Task, a module, a plugin, even a template (though that would be a bit of
      an architectural violation; I won't judge you harshly if you do that
      because you're on a deadline and/or a shoestring budget).</para>

      <para><emphasis>Note that unlike the normative Model of the MVC pattern
      the Joomla component's Model will seek data from the user session and if
      it's not found there it will try to get it from the request. This makes
      it a pain in the posterior to use outside the frontend, backend and API
      applications, e.g. in a CLI application. Yes, there's a trick to that
      (and probably a section I will have to write at some point): set its
      state manually and it will no longer try to get data from the
      request.</emphasis></para>

      <para>As I said, Joomla also has a Table class which, architecturally
      speaking, is somewhere between a Model and a Persistence Layer. But
      we're not CS majors, we're Joomla extension developers. What we need to
      know is that the Table class is an abstraction which represents exactly
      one record of a database table. Table classes only exist in the backend
      of your component but can be used anywhere. They are used either inside
      a Model or directly on their own.</para>

      <para><emphasis>Tables are used by Models but not when returning
      multiple rows. When you run getItems on a ListModel you get an array of
      stdClass objects. This sounds odd at first but it makes sense; Models
      can join multiple tables and return embellished data in lists. For
      example, you may not just get a user ID but also the user's name and
      email address as separate fields. In most (but not all!) cases you could
      instantiate a Table object and call its bind() method with one of the
      aforementioned stdClass objects as its argument to get a Table object
      representation of your data. Just remember in this case that
      instantiating a Table object is computationally expensive as it needs to
      parse the database table's column definitions. Create an instance of the
      Table object. Then clone it for each row you are processing and bind the
      data to the Table object's clone. When processing a few dozen or more
      rows it can save you hundreds of milliseconds of page load
      time.</emphasis></para>

      <para>Then, we have Views. Now, this is the biggest departure of the
      normative MVC pattern. In Computer Science the View only renders
      information in a suitable way for the user to understand. A Joomla
      component's View is actually part controller and part ViewModel. Which
      means that Joomla's MVC is neither MVC nor MVVM, it's its own thing.
      But, as we said before, we are not CS majors, we are Joomla extension
      developers. So let's see what our View does.</para>

      <para>Our View gets data from the Model. It does a bit of error checking
      to make sure nothing is amiss — if it is, it will show an appropriate
      error state be it the new in Joomla 4 Empty State (guiding the user to
      please create some data when we have nothing to show them) or an error
      page if something has gone so bad we don't know what to do. It is also
      responsible for setting up the page metadata (frontend) or the page's
      Title and Toolbar (backend) which is View–related stuff in the same way
      that making coffee is related to hosting an in-person meeting: not
      really your job but people would be really upset if nobody did
      it.</para>

      <para>In the end, the View renders the information in an appropriate
      format for the user — which is what a View is really supposed to do if
      it wants to be called a View! For HTML pages it calls one or more View
      Template files to render some HTML. For other view types such as JSON,
      Raw, XML, Feed and so on a view template file may be used but it's
      neither necessary nor does it always make sense. If you're returning a
      JSON document or a CSV it makes far more sense to construct it directly
      in your View code and return it than going through an unnecessary
      round-trip through a view template file.</para>

      <para>Finally, we need to talk about the View Template files. These are
      the real View of the MVC pattern: they convert the raw data we got from
      our Model to the HTML which will be displayed to the user. Why not have
      the View return the HTML directly? Well, we <emphasis>could</emphasis>
      but we'd have two problems. First, the View itself is also part
      Controller and part ViewModel therefore we'd have an issue with the
      separation of concerns, mixing business logic with presentation logic
      (bad idea; we are using MVC to avoid this bad practice). Second,
      Joomla's raw, unadulterated power comes from the fact that our end users
      can <emphasis>override</emphasis> View Templates in their sites, thereby
      changing the presentation of our component in ways we can neither think
      of nor support in any meaningful way across our entire user base.</para>

      <para>This is the overview of Joomla's MVC and you'll be happy to know
      that it has not actually changed ever since Joomla 1.5. Some
      implementation details have changed but the core concepts — the good,
      the bad and the ugly parts alike — have remained unchanged in Joomla 4.
      In other words, if you already have a perfectly serviceable component
      written for Joomla 3 you <emphasis>can</emphasis> migrate it to Joomla
      4. It's not a different language (like Italian to Spanish), it's a
      different <emphasis>dialect</emphasis>. Yes, you'll need to learn the
      vernacular of the new dialect but it's much, much easier than learning a
      new language. I am saying that as someone who had to learn three foreign
      (human) languages and more programming languages than I care to
      list.</para>
    </section>

    <section xml:id="com-j3-vs-j4-mvc">
      <title>Joomla 3 MVC vs Joomla 4 MVC</title>

      <para>As we already said, the basic functionality of Joomla's MVC has
      remained the same throughout Joomla 3 and 4. If you know how to make a
      Joomla 3 component you know most of what you need to make a Joomla 4
      component. The differences are a few minor, but salient, points.</para>

      <para><link linkend="com-namespaces"><emphasis
      role="bold">Namespaces</emphasis></link>. All native Joomla 4 component
      use <link
      xlink:href="https://www.php.net/manual/en/language.namespaces.php">PHP
      namespaces</link> for their PHP code. This is a very simple change in
      thinking for models, views and controllers. For example, instead of your
      frontend model being called <code>ExampleModelItem</code> it will now be
      the class <code>ItemModel</code> in the namespace <modifier><replaceable>\My\Prefix</replaceable>\Site\Model</modifier>
      where <code>\My\Prefix</code> is something you can define, and has no
      restrictions other than it needs to be a valid PHP namespace, unique to
      your component and should not start with <code>\Joomla</code> (component
      namespaces starting withIn <code>\Joomla</code> are reserved for core
      components). This also applies to custom form fields you may need to
      create in your component — and there <emphasis>is</emphasis> a way to
      tell Joomla which namespace to look custom form fields in with new
      attributes in XML forms.</para>

      <para><link linkend="com-services"><emphasis role="bold">Service
      provider</emphasis></link>. All Joomla components are passed a
      Dependency Injection Container (DIC) which is, in fact, a Service
      Locator. This even applies to components written with the Joomla 3 MVC
      as we'll see in <link linkend="com-lifetime">the lifetime of a
      component</link>. You can register services specific to your component
      in your service locator. At the very least, Joomla expects you to set up
      the <link linkend="com-extension">extension class</link> of your
      component. Unfortunately, even simple components need to have a service
      provider as there is no convention–over–configuration in Joomla 4's
      component DIC.</para>

      <para><link linkend="com-extension"><emphasis role="bold">Extension
      class</emphasis></link>. The extension class
      <emphasis>replaces</emphasis> the entry point file (e.g.
      <filename>administrator/components/com_example/example.php</filename>)
      you had in Joomla 3 MVC. All components written with the Joomla 4 MVC
      have an extension class which extends from
      <code>Joomla\CMS\Extension\MVCComponent</code>. It is used to register
      special services used when working with your component such as the
      <code>MVCFactory</code> service (responsible for creating model, view
      and controller object instances), an <link linkend="com-html">HTML
      helper service</link> which extends Joomla's HTMLHelper, a <link
      linkend="com-router">Router service</link> for frontend search engine
      friendly (SEF) URL routing, and a <link
      linkend="com-categories">Category service</link> if your component uses
      core Categories. It also returns your component's <link
      linkend="com-dispatcher">Dispatcher</link> which is where the execution
      of your component starts. For very simple components you can even use
      the core MVCComponent class as your extension class, without
      sub–classing. See, for example, what the core
      <code>com_actionlogs</code> component does.</para>

      <para><emphasis role="bold"><link
      linkend="com-dispatcher">Dispatcher</link> instead of a front
      controller</emphasis>. In the Joomla 3 MVC paradigm you had a
      <filename>controller.php</filename> file in the root of your component's
      directory structure. This was a front-controller, supposed to figure out
      which controller to use to handle the specified view and task in the
      request. This was a bit gimmicky and error–prone, especially if you had
      components capable of displaying more than one discrete types of
      information, e.g. a downloads repository would be able to display
      categories, releases in a category and files in a release which made for
      three discrete content types which had to be handled by the same front
      controller. The new Dispatcher does the same job, it works without
      sub–classing it for most simple extensions and benefits greatly the more
      complex extensions which need more involved request processing.</para>

      <para><emphasis role="bold"><link linkend="com-html">HTML helper</link>
      is a service</emphasis>. If you had ever registered an HTMLHelper class
      with static calls this is no longer the recommended method. If you need
      an HTML helper for your extension you need to register it through the
      extension class and its methods are no longer static. Since it's a real
      object instantiated by the extension object it has access to the
      component's DIC, therefore to any service you registered in your service
      provider or you were given by Joomla in the DIC. This makes helpers
      testable and means that they can access custom services (e.g. a shipping
      cost calculation service if you are writing an e-commerce component)
      without trying to contort your code.</para>

      <para><emphasis role="bold">New format for </emphasis><link
      linkend="com-router"><emphasis role="bold">Router</emphasis></link>.
      Joomla 4 comes with a new Router which is instantiated through a
      service. The new component router superclass allows you to write
      efficient routers without a lot of boilerplate, duplicated and
      convoluted code.</para>
    </section>

    <section xml:id="com-lifetime">
      <title>The lifetime of a component</title>

      <para>In the previous section we talked about the new concepts in the
      Joomla 4 MVC but it's really hard to understand how they all work
      together. It's best if we talk about the lifetime of a component, i.e.
      what happens when you try to access a Joomla URL in the form
      <uri>index.php?option=com_example&amp;view=foo</uri>.</para>

      <para>The lifetime of our component starts in the application object
      (<code>SiteApplication</code>, <code>AdministratorApplication</code> or
      <code>ApiApplication</code>), namely its <code>dispatch()</code> method.
      All these methods do some initialisation and call
      <code>Joomla\CMS\Component::renderComponent()</code>. This method runs
      this line where things get interesting for our component:</para>

      <programlisting>$app-&gt;bootComponent($option)-&gt;getDispatcher($app)-&gt;dispatch();</programlisting>

      <para>Let's rewrite it so it's more readable:</para>

      <para><programlisting>$componentExtension = $app-&gt;bootComponent($option)
$componentDispatcher = $componentExtension-&gt;getDispatcher($app)
$componentDispatcher-&gt;dispatch();</programlisting>What Joomla does is ask
      the application object to <emphasis>somehow</emphasis> get a component
      extension object — even if it is a legacy component using the Joomla 3
      MVC. Then it asks the component extension object to get it the
      component's Dispatcher object. Finally, it tells the component's
      Dispatcher to dispatch (execute) the component.</para>

      <para>These three steps are crucial to understanding the difference
      between legacy Joomla 3 MVC components, modern Joomla 4 MVC components
      and how Joomla 4 makes them all work.</para>

      <section xml:id="com-lifetime-booting">
        <title>Booting the component</title>

        <para>The <code>bootComponent</code> method is implemented by
        <code>Joomla\CMS\Extension\ExtensionManagerTrait</code>. The first
        thing it does, by calling its <code>loadExtension</code> method, is to
        figure out if this is a Joomla 4 MVC or Joomla 3 MVC component. It
        does that by looking for the
        <filename>services/provider.php</filename> file under the component's
        root. As you may have guessed this is our component's <link
        linkend="com-services">service provider</link> and the reason why all
        Joomla 4 MVC components, even the simplest ones for which we could
        infer their service provider, really do need to have a service
        provider file.</para>

        <para>If the file exists it's loaded and its services are registered
        into the copy of the Joomla DIC which is used as our component's
        DIC.</para>

        <note>
          <para>This means that our component only sees a frozen in time copy
          of the global application services. You cannot register any services
          in the component's DIC and expect them to be available in the global
          application.</para>
        </note>

        <para>If the file does not exist, Joomla creates an instance of the
        <code>Joomla\CMS\Extension\LegacyComponent</code>. As you can see,
        this extension object uses a legacy MVC factory object which "speaks"
        the Joomla 3 non-namespaced MVC class names and a legacy component
        dispatcher which looks for the <filename>componentName.php</filename>
        (in our example: <filename>example.php</filename>) component entry
        point file and loads it. This is exactly how Joomla 4 can render
        components using Joomla 3 MVC.</para>

        <para>The rest of this section will talk about a Joomla 4 MVC
        component.</para>

        <para>Finally, Joomla returns <link linkend="com-extension">the
        component's extension object</link> as the result of the
        <code>bootComponent</code> method.</para>

        <tip>
          <para>You can call
          <code>\Joomla\CMS\Factory::getApplication()-&gt;bootComponent('com_example')</code>
          to get the <code>com_example</code> component's extension object
          anytime, anywhere — <emphasis role="bold">including in modules and
          plugins</emphasis>. If you subclass the
          <code>Joomla\CMS\Extension\MVCExtension</code> class in your own
          component you can create your own methods to return <emphasis>ANY
          OBJECT KNOWN TO THE COMPONENT AND ITS CONTAINER</emphasis>.</para>

          <para>This is of enormous importance.</para>

          <para>You can instantiate any MVC class of the component. You have
          access to your HTML helper, categories service and router service.
          You can get an instance of any of the custom services you created in
          your component. All of that WITHOUT any static helpers in your
          extension, WITHOUT worrying that something might break if you call
          your code outside your component. Your Models can provide a public
          API for third party developers communicating with your
          component.</para>

          <para>Joomla core components already do that. For example, you can
          get the backend <code>ArticleModel</code> of
          <code>com_content</code> in a frontend component or plugin to create
          a new Joomla article <emphasis>the right way</emphasis>:</para>

          <programlisting>$articleModel = \Joomla\CMS\Factory::getApplication()
  -&gt;bootComponent('com_content')
  -&gt;getMVCFactory()
  -&gt;createModel('Article', 'Administrator');</programlisting>
        </tip>
      </section>

      <section xml:id="com-lifetime-dispatcher">
        <title>Getting the Dispatcher</title>

        <para>The extension object is responsible for returning a number of
        interesting objects through its methods. These objects are meant to be
        used for interacting with the component. One of these is
        <code>getDispatcher</code> which lets us retrieve the component's
        <link linkend="com-dispatcher">Dispatcher</link> object.</para>

        <para>Your extension can have a custom dispatcher class,
        <code>\My\Prefix\Dispatcher\Dispatcher</code>, where
        <code>\My\Prefix</code> is your component's prefix. If this class
        exists, an object instance of it is returned.</para>

        <para>If your extension does not have a dispatcher an instance of the
        default <code>Joomla\CMS\Dispatcher\ComponentDispatcher</code> (site
        and administrator applications) or
        <code>Joomla\CMS\Dispatcher\ApiDispatcher</code> (API application)
        will be created and returned instead.</para>
      </section>

      <section xml:id="com-lifetime-dispatching">
        <title>Dispatching the component</title>

        <para>The dispatcher object has a <code>dispatch()</code> method. This
        method looks in the request data to figure out which controller it
        needs to instantiate and which task it should execute on it. The
        controller object is instantiated through your component's
        <code>MVCFactory</code> service and its <code>execute</code> and
        <code>redirect</code> methods are called on it. So, yes, this is
        basically what your old Joomla 3 MVC
        <filename>controller.php</filename> file was doing.</para>

        <tip>
          <para>Having a custom dispatcher means that you can manipulate the
          <emphasis>controller and task</emphasis> based on other request
          variables.</para>

          <para>This is very important when your component is accessed
          <emphasis>outside of a Joomla menu item (no Itemid in the request
          variables)</emphasis>. In this case Joomla always uses the default
          (Home) menu item for the current language. This means that you may
          be getting a <uri>controller</uri>, <uri>view</uri> or
          <uri>task</uri> request variable — as well as other variables which
          might mess with your component, like <uri>id</uri> — from the Home
          menu item.</para>

          <para>Your Dispatcher is responsible for figuring out if this is the
          case and fix the input variables to prevent weird bugs / showing the
          wrong page of your component when it's accessed without a menu item
          id, e.g. a URL like <uri>/component/example?view=foobar</uri>. This
          is something which has happened a lot when I converted my own
          extensions to Joomla 4, including LoginGuard (the extension
          contributed as Joomla's Multi-factor Authentication feature in
          Joomla 4.2).</para>
        </tip>
      </section>
    </section>

    <section xml:id="com-dirs">
      <title>Directory structure</title>

      <para>The directory structure of a typical Joomla 4 MVC component is as
      follows, assuming it's called <code>com_example</code> and has the
      namespace prefix <code>\Acme\Example</code>. Directories are suffixed
      with <filename>/</filename>. Please note that capitalisation matters
      (directory and file names are case–sensitive).</para>

      <itemizedlist>
        <listitem>
          <para><filename>administrator/components/com_example/</filename> The
          component's backend directory</para>

          <itemizedlist>
            <listitem>
              <para><filename>forms/</filename> Optional. List view forms and
              search tools forms (formerly in models/forms)</para>

              <itemizedlist>
                <listitem>
                  <para><filename>items.xml</filename> An example form for the
                  Items list view.</para>
                </listitem>

                <listitem>
                  <para><filename>filter_items.xml</filename> An example
                  search tools form for the Items list view.</para>
                </listitem>

                <listitem>
                  <para><filename>item.xml</filename> An example form for the
                  Item edit view.</para>
                </listitem>

                <listitem>
                  <para>…</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>language/</filename> Not required but you should
              always somehow provide language files with your extension. The
              language files of your component (typically installed in
              <filename>administrator/languages/en-GB</filename>)</para>

              <itemizedlist>
                <listitem>
                  <para><filename>en-GB/</filename> The English (Great
                  Britain) language files. That's the default Joomla
                  language.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>com_example.ini</filename> The main
                      language file for your component's views. Note that
                      there is no longer an <filename>en-GB.</filename>
                      prefix; it's implied by the directory the language file
                      is in.</para>
                    </listitem>

                    <listitem>
                      <para><filename>com_example.sys.ini</filename> The
                      language file used by Joomla to display backend menu
                      items, permissions, the component's Options page, core
                      categories used by your component, select menu item
                      types in the menu manager, and render each menu item
                      type's configuration parameters.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>layouts/</filename> Optional. Any Joomla Layouts
              you want to ship with your extension for use in its
              backend.</para>
            </listitem>

            <listitem>
              <para><filename>services/</filename> Required. Here lives the
              <link linkend="com-services">Service Provider</link> of your
              component.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>provider.php</filename> The service provider
                  file.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>sql/</filename> Optional, unless your extension
              makes changes to database structure or content.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>updates/</filename> Required. Your
                  component's schema (database) files applied on each
                  update.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>mysql/</filename> Optional. Indicates
                      updates for sites running on the MySQL database.</para>

                      <itemizedlist>
                        <listitem>
                          <para><filename>1.0.0-20220815-0000.sql</filename> A
                          database update file. You should name them
                          <filename>version-date-time.sql</filename>. The
                          version part is mandatory.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>install.mysql.utf8.sql</filename> The SQL
                  executed on your component's first installation. Update
                  files are not executed in this case.</para>
                </listitem>

                <listitem>
                  <para><filename>uninstall.mysql.utf8.sql</filename> The SQL
                  executed on your component's uninstallation. Remove any
                  tables or database data you created.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>src/ Required. The root of your extension's PHP files and
              the root of the PSR-4 <code>\Acme\Example\Administrator</code>
              namespace prefix.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>Controller/</filename> Required. Your
                  component's controllers</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ItemsController.php</filename> An
                      example controller for a ListView</para>
                    </listitem>

                    <listitem>
                      <para><filename>ItemController.php</filename> An example
                      controller for an AdminView</para>
                    </listitem>

                    <listitem>
                      <para>…</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Dispatcher/</filename> Optional. Holds your
                  custom component dispatcher.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Dispatcher.php</filename> Your custom
                      component dispatcher.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Extension/</filename> Optional. Holds your
                  custom extension class.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ExampleExtension.php</filename> Your
                      custom extension class.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Field/</filename> Optional. Custom form
                  fields. Use them in your XML forms using the attribute
                  <code>addfieldprefix="Acme\Example\Administrator\Field"</code>.</para>
                </listitem>

                <listitem>
                  <para><filename>Model/</filename> Required. Your component's
                  Models.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ItemsModel.php</filename> An example
                      model for the Items list view.</para>
                    </listitem>

                    <listitem>
                      <para><filename>ItemModel.php</filename> An example
                      model for the Item view. Handles editing and adding
                      records.</para>
                    </listitem>

                    <listitem>
                      <para>…</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Provider/</filename> Optional. Custom
                  service providers.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>RouterFactory.php</filename> Example of
                      a RouterFactory provider, if you need a frontend SEF URL
                      router.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Router/</filename> Optional. The recommended
                  place to put your custom RouterFactory, if you need a
                  frontend SEF URL router.</para>
                </listitem>

                <listitem>
                  <para><filename>Service/</filename> Optional. Custom
                  services.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Html/</filename> Optional. Where your
                      custom HTML services (which are made available through
                      Joomla's HTMLHelper) live.</para>

                      <itemizedlist>
                        <listitem>
                          <para><filename>Example.php</filename> An example
                          HTML service.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Table/</filename> Required. Your Table
                  classes.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ItemTable.php</filename> An example
                      table class for the items of this component (which
                      should ideally live in the
                      <database>#__example_items</database> table if you want
                      to follow Joomla best practices).</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>View/</filename> Required. Your view
                  classes. All subdirectories must be in Uppercasefirst format
                  and match the controller's name before the
                  <code>Controller</code> word.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Items/</filename> The directory for the
                      Items list view.</para>

                      <itemizedlist>
                        <listitem>
                          <para><filename>HtmlView.php</filename> The HTML
                          view class for rendering this backend view.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>

                    <listitem>
                      <para><filename>Item/</filename> The directory for the
                      Item add/edit view.</para>

                      <itemizedlist>
                        <listitem>
                          <para><filename>HtmlView.php</filename> The HTML
                          view class for rendering this backend view.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>tmpl/</filename> Required. The view templates
              for your backend views.</para>

              <important>
                <para>All the sub–directories are in <emphasis role="bold">all
                lowercase</emphasis>. This is VERY important!</para>

                <para>Be careful if you are developing on Windows or macOS
                (which use case–insensitive filesystems). You might
                accidentally use MixedCase or Uppercasefirst folder names.
                While this will work fine on Windows and macOS it will
                <emphasis>fail</emphasis> on the Linux servers most sites run
                on. That's because Linux primarily uses case-sensitive
                filesystems.</para>
              </important>

              <itemizedlist>
                <listitem>
                  <para><filename>items/</filename></para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>default.php</filename> The view template
                      for the Items view.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>item/</filename></para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>edit.php</filename> The view template
                      for the Item view.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>access.xml</filename> The component's
              permissions configuration file</para>
            </listitem>

            <listitem>
              <para><filename>config.xml</filename> The component;s Options
              page form file</para>
            </listitem>

            <listitem>
              <para><filename>example.xml</filename> The component's XML
              manifest</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><filename>components/com_example/</filename> The component's
          frontend directory</para>

          <itemizedlist>
            <listitem>
              <para><filename>forms/</filename> Optional. Any forms for
              frontend views (formerly in models/forms).</para>
            </listitem>

            <listitem>
              <para><filename>language/</filename> Not required but you should
              always somehow provide language files with your extension. The
              language files of your component (typically installed in
              <filename>languages/en-GB</filename>)</para>

              <itemizedlist>
                <listitem>
                  <para><filename>en-GB/</filename> The English (Great
                  Britain) language files. That's the default Joomla
                  language.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>com_example.ini</filename> The main
                      language file for your component's frontend
                      views.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>layouts/</filename> Optional. Any Joomla Layouts
              you want to ship with your extension for use in its
              frontend.</para>
            </listitem>

            <listitem>
              <para>src/ Required. The root of your extension's PHP files and
              the root of the PSR-4 <code>\Acme\Example\Site</code> namespace
              prefix.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>Controller/</filename> Required. Your
                  component's controllers</para>
                </listitem>

                <listitem>
                  <para><filename>Dispatcher/</filename> Optional. Holds your
                  custom component dispatcher for the frontend only.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Dispatcher.php</filename> Your custom
                      component frontend dispatcher.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Model/</filename> Required. Your component's
                  Models.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>ItemsModel.php</filename> An example
                      model for the Items list view.</para>
                    </listitem>

                    <listitem>
                      <para><filename>ItemModel.php</filename> An example
                      model for the Item view. Handles editing and adding
                      records.</para>
                    </listitem>

                    <listitem>
                      <para>…</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>Service/</filename> Optional. Custom
                  services.</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>Category.php</filename> Optional. Your
                      site's category service.</para>
                    </listitem>

                    <listitem>
                      <para><filename>Router.php</filename> Optional. Your
                      site's SEF router.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>

                <listitem>
                  <para><filename>View/</filename> Required. Your frontend
                  view classes. All subdirectories must be in Uppercasefirst
                  format and match the controller's name before the
                  <code>Controller</code> word.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><filename>tmpl/</filename> Required. The view templates
              for your backend views. All the sub–directories are in <emphasis
              role="bold">all lowercase</emphasis>.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><filename>api/components/com_example/</filename> Optional.
          Your Joomla API application integration. Just having this directory
          is not enough, you will also need a published plugin for your
          application in the <filename>webservices</filename> folder.</para>

          <itemizedlist>
            <listitem>
              <para>src/ Required. The root of your extension's PHP files and
              the root of the PSR-4 <code>\Acme\Example\Api</code> namespace
              prefix.</para>

              <itemizedlist>
                <listitem>
                  <para><filename>Controller/</filename> Required. Your
                  component's controllers</para>
                </listitem>

                <listitem>
                  <para><filename>View/</filename> Required. Your API view
                  classes. All subdirectories must be in Uppercasefirst format
                  and match the controller's name before the
                  <code>Controller</code> word. Note that these views DO NOT
                  use view template files; they return JSON data
                  directly.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><filename>media/com_example/</filename> Optional. Your
          component's static assets.</para>

          <itemizedlist>
            <listitem>
              <para><filename>css/</filename> Optional. Custom CSS files for
              your component.</para>
            </listitem>

            <listitem>
              <para><filename>js/</filename> Optional. Custom JavaScript files
              for your component.</para>
            </listitem>

            <listitem>
              <para><filename>joomla.asset.json</filename> The <link
              linkend="concepts-webassetmanager">WebAssetManager configuration
              file</link> for your static assets.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="com-services">
      <title>Service provider</title>

      <para>As discussed in the previous section, the service provider file is
      mandatory for Joomla 4 MVC components and lives in the component's
      <filename>services</filename> folder and always named
      <filename>provider.php</filename>.</para>

      <para>The absolutely minimal minimal service provider file looks like
      the following:</para>

      <programlisting>&lt;?php
defined('_JEXEC') || die;

use Acme\Example\Administrator\Extension\ExampleComponent;
use Joomla\CMS\Dispatcher\ComponentDispatcherFactoryInterface;
use Joomla\CMS\Extension\ComponentInterface;
use Joomla\CMS\Extension\Service\Provider\MVCFactory;
use Joomla\CMS\MVC\Factory\MVCFactoryInterface;
use Joomla\DI\Container;
use Joomla\DI\ServiceProviderInterface;

return new class implements ServiceProviderInterface {
	public function register(Container $container)
	{
		// PART 1: Register service providers to the component's container
		$container-&gt;registerServiceProvider(new MVCFactory('Acme\\Example'));

		// PART 2: Instantiate and set up your extension object
		$container-&gt;set(
			ComponentInterface::class,
			function (Container $container) {
				/**
				 * PART 2.a: Instantiate the extension object
				 *
				 * If you do not have a custom extension class use \Joomla\CMS\Extension\MVCComponent instead.
				 */
				$component = new \Acme\Example\Administrator\Extension\ExampleComponent(
					$container-&gt;get(ComponentDispatcherFactoryInterface::class)
				);

				// PART 2.b: Set up the extension object
				$component-&gt;setMVCFactory($container-&gt;get(MVCFactoryInterface::class));

				// PART 2.c: return the extension object
				return $component;
			}
		);
	}
};
</programlisting>

      <para>As you can see the service provider returns an <link
      xlink:href="https://www.php.net/manual/en/language.oop5.anonymous.php">anonymous
      PHP class</link> which implements the
      <code>Joomla\DI\ServiceProviderInterface</code>. That's the standard way
      to extend Joomla's DIC. Remember, as we learned in <link
      linkend="com-lifetime">the lifetime of a component</link>, Joomla
      creates a <emphasis>copy</emphasis> of its DIC and uses it as our
      component's own DIC. The service providers we set up in our component
      stay with our component, they do not leak out to the global application
      scope (the global Joomla DIC you get through the
      <code>Joomla\CMS\Factory::getContainer()</code> static method).</para>

      <para>Part 1 of that file lets us register service providers to our
      component's DIC. At the bare minimum we need to register a
      <code>Joomla\CMS\Extension\Service\Provider\MVCFactory</code> provider.
      This returns an object implementing
      <code>Joomla\CMS\MVC\Factory\MVCFactoryInterface</code> which is used by
      our component's code (and Joomla's core code) to get the MVC objects of
      our component (Controllers, Models, Views, Tables). If we want to use
      more core Joomla features with out component we may have to register
      more service providers as we'll see in the <link
      linkend="com-extension">Extension class</link> section and the rest of
      the sections of this chapter.</para>

      <para>Part 2 sets up a service provider returning an object implementing
      the <code>Joomla\CMS\Extension\ComponentInterface</code>, i.e. our
      component's extension object.</para>

      <para>Part 2.a is where we create an instance of our <link
      linkend="com-extension">extension class</link>. If you have a dead
      simple component which does not use a custom extension class you can use
      Joomla's built-in <code>\Joomla\CMS\Extension\MVCComponent</code> class
      instead. Most components will need a custom extension class so we
      instantiate it here.</para>

      <para>Part 2.b is where we set up the extension object we created in
      Part 2.a. Remember when I told you that <link
      linkend="concepts-container">Joomla's DIC is not really a Dependency
      Injection Container</link> but more of a Service Locator? Because of
      that fact, when we create the extension object it does not know of any
      service objects it needs to use. Therefore we have to push them
      manually.</para>

      <para><emphasis>Sidebar: In my opinion, the three biggest shortcomings
      of the Joomla 4 MVC are the lack of convention over configuration, the
      lack of abstracted configuration and the lack of a real Dependency
      Injection container. These three shortcomings are, respectively, why we
      need to have a service provider file, why we need Part 1 and Part 2.b
      and why we need Part 2.a. Most other PHP frameworks have already solved
      these shortcomings. This means that any complaints that Joomla is moving
      to a very abstracted approach just to compete with other PHP frameworks
      are entirely unfounded; Joomla's architecture is still a good 10 or so
      years behind the PHP state of the art. This is not a bad thing! Too much
      abstraction may be a good thing for experienced, hardcore developers
      like yours truly but not necessarily the easiest thing to get your head
      around if you're a newcomer to Joomla or PHP in
      general.</emphasis></para>

      <para>Finally, we have Part 3 where we return the configured extension
      object, necessary for our custom service provider to <emphasis>actually
      work</emphasis>.</para>

      <warning>
        <para>You may be tempted to think that the service provider is only
        ever called when Joomla is about to render your component. <emphasis
        role="bold">This is not the case</emphasis>. Joomla will load a
        component's service provider any time it needs to interact with any of
        its services including the Router, or because another extension (such
        as a plugin, or module) wants to get access to your component's Models
        or some other service or object.</para>

        <para>Just because your service provider's code is running DOES NOT
        mean you are about to render an HTML page with your component, it DOES
        NOT mean that you necessarily have access to the JPATH_COMPONENT and
        JPATH_COMPONENT_ADMINISTRATOR constants and absolutely DOES NOT mean
        that you should ever, <emphasis>ever</emphasis>, try to push CSS,
        JavaScript or run any other code which assumes that Joomla is in an
        HTML output state.</para>

        <para>If you have such code (which is generally a bad idea) you should
        run it in your component's <link
        linkend="com-dispatcher">Dispatcher</link> and only after checking
        that you are indeed running in an HTML application (check the type of
        the object returned from calling
        <code>\Joomla\CMS\Factory::getApplication()-&gt;getDocument()</code>).</para>
      </warning>
    </section>

    <section xml:id="com-extension">
      <title>Extension class</title>

      <para>As we saw earlier in <link linkend="com-lifetime">the lifetime of
      a component</link>, the Extension class of a component is <emphasis>sort
      of</emphasis> a service locator for our component. Joomla checks if that
      objects implements a PHP Interface it knows about and uses the service
      communicated via the Interface implementation (typically one of the
      corresponding PHP Traits provided by Joomla) to do something useful,
      e.g. register an HTMLHelper helper, integrate with Tags, create SEF URLs
      by using a Router and so on and so forth.</para>

      <para>If your component does not make use of any of these features you
      do not need to create a custom extension class for your component.
      Joomla gives you the perfectly serviceable
      <code>Joomla\CMS\Extension\MVCComponent</code> class which implements a
      minimal Joomla 4 component: it can run because it returns a Dispatcher
      and it can create MVC objects using the Joomla 4 MVC because it returns
      an MVCFactory object. This is enough for a component which only runs in
      the backend or runs in both the frontend and the backend but has no way
      of letting Joomla create SEF URLs for it. You may think this is useless
      but I'd contest you're not thinking simple enough. Case in point, some
      core Joomla components doing exactly that. For example the
      <code>com_actionlogs</code> component which only has a backend user
      interface.</para>

      <para>That said, there wouldn't be much to write if all or even most
      components didn't need a custom extension class. You see, most
      components need one or more of the following features. I am documenting
      the features I discovered that need customisations in the extension
      class and give you an overview of the required changes in your
      component's code to make them work.</para>

      <itemizedlist>
        <listitem>
          <para>Use a custom <link linkend="com-html">HTML
          Helper</link>.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\HTML\HTMLRegistryAwareTrait</code> and use the
          <code>Joomla\CMS\HTML\HTMLRegistryAwareTrait</code>. The extension
          class must override the <code>boot</code> method and have a line
          similar to <code>$this-&gt;getRegistry()-&gt;register('something',
          new MyHTMLHelper())</code>. We'll see what that means in the section
          covering the HTML helper.</para>
        </listitem>

        <listitem>
          <para>Use <link linkend="com-categories">core
          categories</link>.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\Categories\CategoryServiceInterface</code> and use
          the <code>Joomla\CMS\Categories\CategoryServiceTrait</code>. Your
          service provider (<filename>provider.php</filename>) needs to
          register a
          <code>Joomla\CMS\Extension\Service\Provider\CategoryFactory</code>
          service provider and use the extension object's
          <code>setCategoryFactory</code> method to pass this factory to the
          extension object. The extension class must override the
          <code>getTableNameForSection</code> and
          <code>getStateColumnForSection</code> methods defined in the
          aforementioned trait and interface.</para>
        </listitem>

        <listitem>
          <para>Integrate with Joomla's Tags feature.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\Tag\TagServiceInterface</code> and use the
          <code>Joomla\CMS\Tag\TagServiceTrait</code>. The extension class
          must override the <code>getTableNameForSection</code> and
          <code>getStateColumnForSection</code> methods defined in the
          aforementioned trait and interface.</para>
        </listitem>

        <listitem>
          <para>Integrate with <link linkend="com-fields">Joomla's Custom
          Fields feature</link>.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\Fields\FieldsServiceInterface</code>. The extension
          class must implement the <code>validateSection</code> and
          <code>getContext</code> methods defined in the aforementioned
          interface.</para>
        </listitem>

        <listitem>
          <para>Provide a <link linkend="com-router">Router</link> for
          meaningful, human-readable SEF URLs in the frontend.</para>

          <para>Your component must have a class implementing the
          <code>Joomla\CMS\Component\Router\RouterFactoryInterface</code>
          (Router factory) and a class implementing the
          <code>Joomla\DI\ServiceProviderInterface</code> (Router factory
          provider). Your extension class must implement the
          <code>Joomla\CMS\Component\Router\RouterServiceInterface</code> and
          use the <code>Joomla\CMS\Component\Router\RouterServiceTrait</code>.
          Your service provider (<filename>provider.php</filename>) needs to
          register your Router factory provider and use the extension object's
          <code>setRouterFactory</code> method to pass the resulting Router
          factory to the extension object.</para>
        </listitem>

        <listitem>
          <para>Let Joomla associate items between languages on multi–language
          sites.</para>

          <para>Your component must have a class extending the
          <code>Joomla\CMS\Association\AssociationExtensionHelper</code>. Your
          service provider (<filename>provider.php</filename>) must register
          this class with the
          <code>Joomla\CMS\Association\AssociationExtensionInterface::class</code>
          key and use the extension object's
          <code>setAssociationExtension</code> method to assign the object
          resulting from that service to the extension object. Your extension
          object needs to implement the
          <code>Joomla\CMS\Association\AssociationServiceInterface</code> and
          use the
          <code>Joomla\CMS\Association\AssociationServiceTrait</code>.</para>
        </listitem>

        <listitem>
          <para>Integrate with Joomla's Workflows feature.</para>

          <para>Your extension class must implement the
          <code>Joomla\CMS\Workflow\WorkflowServiceInterface</code> and use
          the <code>Joomla\CMS\Workflow\WorkflowServiceTrait</code>. The
          extension class must override the <code>getModelName</code>,
          <code>filterTransitions</code>,
          <code>getWorkflowTableBySection</code>,
          <code>getWorkflowContexts</code> and
          <code>getCategoryWorkflowContext</code> methods defined in the
          aforementioned trait and interface.</para>
        </listitem>
      </itemizedlist>

      <para>As you can see, trying to do pretty much anything useful does
      require a custom extension class.</para>

      <section xml:id="com-extension-naming">
        <title>Naming your extension class</title>

        <para>There are no hard rules for naming your component's extension
        class. That said, to help anyone reading your code — including
        yourself six or so months later — retain a modicum of their sanity it
        is advisable to use the convention
        <code><replaceable>\My\Prefix</replaceable>\Administrator\Extension\<replaceable>Name</replaceable>Component</code>
        where \My\Prefix is the namespace prefix of your component and
        <code>Name</code> is the name of your component without the
        <code>com_</code> prefix.</para>

        <para>For example, if you have a component named
        <code>com_example</code> with the namespace prefix
        <code>\Acme\Example</code> your extension class should be
        <code>\Acme\Example\Administrator\Extension\ExampleComponent</code>
        and placed in the file
        <filename>administrator/components/com_example/src/Extension/ExampleComponent.php</filename>.</para>
      </section>

      <section xml:id="com-extension-provider">
        <title>Using your extension class in the service provider</title>

        <para>As you remember from the service provider section, in Part 2.a
        you need to instantiate the extension class. These lines would look
        like this:</para>

        <programlisting>$component = new \Acme\Example\Administrator\Extension\ExampleComponent(
	$container-&gt;get(ComponentDispatcherFactoryInterface::class)
);</programlisting>

        <para>Simple, isn't it?</para>
      </section>

      <section xml:id="com-extension-outside-com">
        <title>Using your extension class from outside the component</title>

        <para>Now we are finally able to answer the question which you had in
        mind coming to this section: why in the name of Cthulu do I have to
        have an extension class and what does it accomplish beyond adding yet
        another layer of complexity to my extension writing problems?</para>

        <para>For that, let's consider this. Let's say we have a news site and
        we are building a system plugin which checks every day for newly
        published articles, auto–generating a daily summary blog post using
        the intro text of these articles and some preset template (maybe even
        some judicious use of a GPT-3–based AI). This plugin would need to
        publish an article. You could of course just instantiate the
        <code>ArticleTable</code> class of <code>com_content</code> directly
        to do that but this would not run any content plugins or create the
        right entries in the #__assets table, breaking your site. You need to
        use the com_content Article backend model of
        <code>com_content</code>.</para>

        <para>Back in the Joomla 3 days you would do that by directly
        instantiating the <code>ContentModelArticle</code> class. Okay, first
        problem: Joomla didn't know where to find it so you have to
        <code>require_once()</code> the file. Second problem: what if that
        model changes over time and has dependencies to other classes you have
        failed to require the files of? Believe me, I've been there, done that
        and it was about as enjoyable as using a rusty fork to pull my eyes
        out of their sockets.</para>

        <para>In Joomla 4 you don't have to care about the class autoloading,
        but the <code>ArticleModel</code> will actually need access to other
        services provided by the <code>com_content</code> component for things
        like tagging, custom fields and workflows. If you try to instantiate
        the model class directly you will get a lot of errors as well. So, who
        are you gonna call? No, not Ghostbusters; they are Hollywood fiction.
        You're gonna call the very real and very useful
        <code>bootComponent</code> method of the application!</para>

        <programlisting>$contentExtension = \Joomla\CMS\Factory::getApplication()
  -&gt;bootComponent('com_content');
$articleModel = $contentExtension
  -&gt;getMVCFactory()
  -&gt;createModel('Article', 'Administrator');</programlisting>

        <para>The first two lines told Joomla to “boot” the
        <code>com_content</code> component, returning its <emphasis>extension
        object</emphasis>. Now we have have access to all services known to
        this object through its various getters (method whose name start with
        <code>get</code>).</para>

        <para>This works for any component, anywhere, anytime. You can be in
        the frontend, backend, API application or CLI application or in an
        execution context you don't care to know about in a Scheduled Tasks
        plugin. No problem! You can boot any components — yours, core, or
        third party — to get its extension object and Bob's your uncle.</para>
      </section>

      <section xml:id="com-extension-dic-proxy">
        <title>Getting access to the component's DIC anytime, anywhere</title>

        <para>I see that some of you are <emphasis>still</emphasis> not
        convinced that the extension object is a cool concept.</para>

        <para>Remember when I told you that the Joomla DIC — therefore the
        component's DIC which is a customised copy of it — is not a real
        Dependency Injection Container but a Service Locator and lamented the
        fact that you cannot get a reference to it from anywhere in your
        component, unlike modern PHP frameworks like Laravel?</para>

        <para>Well, it turns out that you can get access to your component's
        DIC anywhere, anytime. You just need to add the following handy code
        to your extension's class:</para>

        <programlisting>	protected static $dic;

	public function boot(ContainerInterface $container)
	{
		self::$dic = $container;
	}
	
	public static function getContainer()
	{
		if (empty(self::$dic))
		{
			Factory::getApplication()
			       -&gt;bootComponent('com_example');
		}
		
		return self::$dic;
	}
</programlisting>

        <para>This code is very simple. We declare a protected static variable
        holding our component's DIC. This is initialised by the boot method
        which is called whenever the component is booted. The static method
        getContainer returns the component's DIC; if the DIC was undefined at
        this point it boots the component first.</para>

        <para>So now you can simply do:</para>

        <programlisting>$exampleDIC = \Acme\Example\Administrator\Extension\ExampleComponent::getContainer();</programlisting>

        <para>The component's DIC gives you access to all of the application's
        services and your component's service. Using the MVCFactory to get an
        MVC object you can be sure that it will work as intended.</para>
      </section>
    </section>

    <section xml:id="com-dispatcher">
      <title>Dispatcher</title>

      <para>As we said <link linkend="com-j3-vs-j4-mvc">when comparing the
      Joomla 3 to the Joomla 4 MVC</link>, the Dispatcher takes the place of
      the front controller (<filename>controller.php</filename>) in the legacy
      Joomla 3 MVC. In some ways it also takes the place of the entry point
      file (e.g. <filename>example.php</filename> for a component named
      <code>com_example</code>) as it's the first code which is executed when
      our component is loaded with the explicit intent of rendering
      output.</para>

      <para>Most components do not need a custom Dispatcher. The default
      Dispatcher provided by Joomla is just fine.</para>

      <para>If you do decide to create a custom Dispatcher its class name
      <emphasis role="bold">MUST</emphasis> be
      <code><replaceable>\My\Prefix</replaceable>\Administrator\Dispatcher\Dispatcher</code>
      (backend),
      <code><replaceable>\My\Prefix</replaceable>\Site\Dispatcher\Dispatcher</code>
      (frontend) or
      <code><replaceable>\My\Prefix</replaceable>\Api\Dispatcher\Dispatcher</code>
      (API application) where <code>\My\Prefix</code> is the namespace prefix
      for your component. This class must extend from
      <code>\Joomla\CMS\Dispatcher\ComponentDispatcher</code>.</para>

      <para>Typically, there are two methods you might need to customise. One
      is <code>loadLanguage</code> which loads your component's language
      files. You may have to customise that if, for example, you need to load
      the backend files in the frontend or vice versa, or if you need to load
      some core component's language files on top of yours.</para>

      <para>The other method may be the <code>dispatch()</code> method which
      figures out the view, task and controller from the input and executes
      the component.</para>

      <para>Usually, I override the <code>dispatch()</code> method to add a
      minimum PHP version check and fix up the request variables so I always
      have a view and task. The latter helps when writing Routers for
      components which have record add / edit views in the
      <emphasis>frontend</emphasis>. Such a Dispatcher would look like the
      following code example.</para>

      <programlisting>&lt;?php
namespace Acme\Example\Site\Dispatcher;

defined('_JEXEC') or die;

class Dispatcher extends \Joomla\CMS\Dispatcher\ComponentDispatcher
{
	/**
	 * The default controller (and view), if none is specified in the request.
	 *
	 * @var   string
	 */
	protected $defaultController = 'items';

	/** @inheritdoc */
	public function dispatch()
	{
		$minPHPVersion = '7.4.0';

		if (version_compare(PHP_VERSION, $minPHPVersion, 'lt'))
		{
			throw new \RuntimeException(
				sprintf(
					'This component requires PHP %s or later.',
					$minPHPVersion
				)
			);
		}

		$this-&gt;applyViewAndController();
		
		parent::dispatch();
	}

	/**
	 * Applies the view and controller to the input object communicated to the MVC objects.
	 *
	 * If we have a controller without view or just a task=controllerName.taskName we populate the view to make things
	 * easier and more consistent for us to handle.
	 *
	 * @return  void
	 */
	protected function applyViewAndController(): void
	{
		$controller = $this-&gt;input-&gt;getCmd('controller', null);
		$view       = $this-&gt;input-&gt;getCmd('view', null);
		$task       = $this-&gt;input-&gt;getCmd('task', 'default');

		if (strpos($task, '.') !== false)
		{
			// Explode the controller.task command.
			[$controller, $task] = explode('.', $task);
			$view = null;
		}

		if (empty($controller) &amp;&amp; empty($view))
		{
			$controller = $this-&gt;defaultController;
			$view       = $this-&gt;defaultController;
		}
		elseif (empty($controller) &amp;&amp; !empty($view))
		{
			$controller = $view;
		}
		elseif (!empty($controller) &amp;&amp; empty($view))
		{
			$view = $controller;
		}

		$controller = strtolower($controller);
		$view       = strtolower($view);

		$this-&gt;input-&gt;set('view', $view);
		$this-&gt;input-&gt;set('controller', $controller);
		$this-&gt;input-&gt;set('task', $task);
	}
}</programlisting>
    </section>

    <section xml:id="com-namespaces">
      <title>Namespaces and MVC</title>

      <para>Before we delve into the specifics of how Models, Views,
      Controllers and Tables work in the Joomla 4 MVC we need to talk about
      how they are <emphasis>named</emphasis>.</para>

      <section xml:id="com-namespaces-j3">
        <title>How things worked from Joomla 1.5 to 3.10</title>

        <para>In Joomla 3 the naming convention was
        <code>ComponentTypeName</code> where</para>

        <itemizedlist>
          <listitem>
            <para><code>Component</code> is the name of the component without
            the <code>com_</code> prefix and with the first letter in
            uppercase. For example, if you have <code>com_example</code> the
            first part of an MVC class name was <code>Example</code>.</para>
          </listitem>

          <listitem>
            <para><code>Type</code> is the type of the class you have, i.e.
            one of <code>Component</code>, <code>Model</code>,
            <code>View</code>, or <code>Table</code>. Again, the first letter
            is uppercase.</para>
          </listitem>

          <listitem>
            <para>Name is the name of the specific MVC class with its first
            letter in uppercase, e.g. <code>Item</code>.</para>
          </listitem>
        </itemizedlist>

        <para>This conventions held true in both the front- and backend parts
        of your component. For example, both the frontend and the backend
        would have a class named ExampleControllerItem and they could not
        extend from each other. This led to a <emphasis>lot</emphasis> of code
        duplication. Code duplication is the natural enemy of <link
        xlink:href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</link>
        (Don't Repeat Yourself) code and a source of the most egregious bugs.
        That's why this practice is mockingly called WET: Write Everything
        Twice. When you put it like that it sounds exactly as ridiculous as it
        is practicing it.</para>

        <para>As for file naming, things were pretty clear for Controllers,
        Models and Tables. The name of the file was the <code>Name</code> part
        of your class name, but in all lowercase. For example, the class
        <code>ExampleControllerItem</code> was placed in a file called
        <filename>item.php</filename>.</para>

        <para>Views were... a bit more complicated. A view has a
        <emphasis>view type</emphasis> which corresponds to the
        <parameter>format</parameter> URL parameter, the default (if not
        specified) being <option>html</option>. However, if all view classes
        of the <code>com_example</code> component for the view name
        <code>item</code> are called <code>ExampleViewItem</code> how does
        Joomla figure out which one to load for the <code>html</code>,
        <code>json</code>, <code>raw</code>, <code>feed</code> etc view types?
        The trick was in the <emphasis>file name</emphasis>. Regardless of the
        name of the view class, the file name the class was stored in was
        following the naming convention
        <filename>view.<replaceable>view_type</replaceable>.php</filename>
        where the <replaceable>view_type</replaceable> is the view type in all
        lowercase (corresponds to the URL <parameter>format</parameter>
        parameter). The HTML view class would be stored in a file called
        <filename>view.html.php</filename>. This was maddening because a. the
        file name does not include even a hint to the class name and b. view
        classes cannot extend from each other. Another case of WET.</para>

        <para>With such complicated class and file naming — not to mention one
        not always being related to the other — it was impossible to write
        anything that remotely resembled a working autoloader for component
        classes. This resulted in Joomla using some ugly static calls in its
        base controller, model, view and table classes to get the MVC object
        you wanted. Whether that worked or not depended on whether they were
        called from within the same component or if you had used other badly
        documented static calls to tell these base classes where to look for
        component classes. If you wanted to mix front- and backend classes…
        let's just say the result was not pretty.</para>

        <para>Basically, the Joomla 1.5 to 3.10 MVC class and file naming was
        a rolling Dumpster fire in the sixth ring of Hell. Yet, it was still
        better than nothing, i.e. what WordPress plugin developers have to
        contend with even to this day. It's funny how literally anything is
        better than nothing and how attached people got to what is objectively
        a bad solution which was rushed out of the door.</para>

        <para>A bit of history: The MVC in Joomla 1.5 to 3.10 was never
        considered “finished” by its lead developer, Johan Janssens. He was
        aware of its shortcomings but ran out of time improving it in 2006.
        Janssens left the project shortly after Joomla 1.5 was released. The
        MVC architecture wasn't updated significantly in subsequent versions.
        Features were still added to it, e.g. Forms support in Joomla 1.6, but
        the class and file naming remained untouched until the release of
        Joomla 4 in 2020.</para>
      </section>

      <section xml:id="com-namespaces-j4">
        <title>How things work Joomla 4.0 onwards</title>

        <para>Fixing the hot mess of class and file naming in component's MVC
        was one of the priorities in Joomla 4. Having a CMS in 2020 (when
        Joomla 4 was released) still use a half–finished and proven
        problematic architecture from 2006 would just not cut it.</para>

        <para>The first step was to add <link
        linkend="concepts-namespaces">namespaces</link> and make sure that the
        <link linkend="com-dirs">folder and file names</link> follow the <link
        xlink:href="https://www.php-fig.org/psr/psr-4/">PSR-4</link>
        standard.</para>

        <para>Your component's namespace prefix is declared in the XML
        manifest of the component using a new XML element under the
        <code>&lt;extension&gt;</code> root element:</para>

        <programlisting>&lt;namespace path="src"&gt;My\Namespace\Prefix&lt;/namespace&gt;</programlisting>

        <para>The <code>path</code> attribute tells Joomla which subdirectory
        of your extension holds the PSR-4 of your extension's PHP files. It is
        best practice to name it <filename>src</filename> but <emphasis>you
        don't have to</emphasis>. I always assume you are using
        <filename>src</filename>.</para>

        <para>The text inside the XML element,
        <code>My\Namespace\Prefix</code> in our example, is the namespace
        prefix you will be using. Each component can register its own
        namespace prefix without any restrictions. It is
        <emphasis>recommended</emphasis> to use the convention
        <code>\Company\Something</code> where <code>Company</code> is your
        company name (or a shortened version thereof) and
        <code>Something</code> corresponds to the <code>com_something</code>
        extension name of your component. For example, the component
        <code>com_example</code> by Acme, Inc could have a namespace prefix of
        <code>\Acme\Example</code> set up in its XML manifest.</para>

        <para>Note that this is the common namespace prefix for your entire
        component. Your component has a different part for each of the three
        web applications in Joomla: frontend (site), backend (administrator)
        and api (the brand–new JSON API; this is optional).</para>

        <para>Here is how namespace prefixes work across different types of
        extensions, assuming a common namespace prefix
        <code>Acme\Example</code>:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">Component, frontend</emphasis>. The
            frontend classes MUST be under the namespace
            <code>\Acme\Example\Site</code>. The folder
            <filename>components/com_example/src</filename> is the root of the
            <code>\Acme\Example\Site</code> namespace.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Component, backend</emphasis>. The
            backend classes MUST be under the namespace
            <code>\Acme\Example\Administrator</code>. The folder
            <filename>administrator/components/com_example/src</filename> is
            the root of the <code>\Acme\Example\Administrator</code>
            namespace.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Component, API application</emphasis>.
            The API application classes MUST be under the namespace
            <code>\Acme\Example\Api</code>. The folder
            <filename>api/components/com_example/src</filename> is the root of
            the <code>\Acme\Example\Api</code> namespace.</para>
          </listitem>
        </itemizedlist>

        <para>As for the class naming, it's not a big departure from Joomla 3.
        It's just a more normalised version which takes namespaces into
        account.</para>

        <para>In Joomla 4 and beyond the naming convention for controllers,
        models and tables is
        <code>\<replaceable>NamespacePrefix</replaceable>\<replaceable>ApplicationType</replaceable>\<replaceable>Type</replaceable>\<replaceable>Name</replaceable><replaceable>Type</replaceable></code>
        where:</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>NamespacePrefix</replaceable> is your common
            namespace prefix, e.g. <code>\Acme\Example</code>.</para>
          </listitem>

          <listitem>
            <para><replaceable>ApplicationType</replaceable> is the type of
            the application part of your component i.e. one of
            <code>Site</code> (frontend), <code>Administrator</code>
            (backend), or <code>Api</code> (JSON API application).</para>
          </listitem>

          <listitem>
            <para><replaceable>Name</replaceable> is the name of the specific
            MVC class with its first letter in uppercase, e.g.
            <code>Item</code>.</para>
          </listitem>

          <listitem>
            <para><code><replaceable>Type</replaceable></code> is the type of
            the class you have, i.e. one of <code>Component</code>,
            <code>Model</code>, or <code>Table</code>. Again, the first letter
            is uppercase.</para>
          </listitem>
        </itemizedlist>

        <para>Controllers, models and tables are placed under your
        <filename>src</filename> directory following PSR-4. So, a backend
        class <code>\Acme\Example\Administrator\Model\ItemModel</code> for a
        component <code>com_example</code> whose common namespace prefix is
        <code>\Acme\Example</code> is placed in the file
        <filename>administrator/components/com_example/src/Model/ItemModel.php</filename>.</para>

        <para>Views have a very slightly different convention because we also
        have the <emphasis>view type</emphasis>. Their naming convention is
        <code>\<replaceable>NamespacePrefix</replaceable>\<replaceable>ApplicationType</replaceable>\View\<replaceable>Name</replaceable>\<replaceable>ViewType</replaceable></code>
        where:</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>NamespacePrefix</replaceable> is your common
            namespace prefix, e.g. <code>\Acme\Example</code>.</para>
          </listitem>

          <listitem>
            <para><replaceable>ApplicationType</replaceable> is the type of
            the application part of your component i.e. one of
            <code>Site</code> (frontend), <code>Administrator</code>
            (backend), or <code>Api</code> (JSON API application).</para>
          </listitem>

          <listitem>
            <para>Name is the name of the specific MVC class with its first
            letter in uppercase, e.g. <code>Item</code>.</para>
          </listitem>

          <listitem>
            <para><code>ViewType</code> corresponds to the format URL
            parameter with its first letter in uppercase, e.g.
            <code>Html</code>, <code>Json</code>, <code>Feed</code>,
            <code>Raw</code> and so on.</para>
          </listitem>
        </itemizedlist>

        <para>View classes are placed under your <filename>src</filename>
        directory following PSR-4. So, a backend class
        <code>\Acme\Example\Administrator\View\Item\Html</code> for a
        component <code>com_example</code> whose common namespace prefix is
        <code>\Acme\Example</code> is placed in the file
        <filename>administrator/components/com_example/src/View/Item/Html.php</filename>.</para>

        <para>Right away you can see how namespaces are benefiting us. A
        controller, model, or view in the frontend, backend and api
        application have a different FQN (<link
        xlink:href="https://www.php.net/manual/en/language.namespaces.rules.php">Fully
        Qualified Name</link>). They no longer have the same name. One can
        extend the other if we want to, we <emphasis>can</emphasis> mix
        front-, backend and api MVC objects if we need to and all of these
        classes can be autoloaded without having to use weird static calls.
        Cool!</para>
      </section>
    </section>

    <section xml:id="com-mvcfactory">
      <title>The MVCFactory</title>

      <para>In Joomla 3 you had to make a static call to the base MVC class
      included in Joomla itself to get an instance of an MVC object. For
      example, getting your ExampleModelItem model object you had to do
      something like the following.</para>

      <programlisting>$model = \Joomla\CMS\MVC\Model\BaseDatabaseModel::getInstance('Item', 'ExampleModel');</programlisting>

      <para>If you were to do that in the frontend of the site you'd get the
      frontend <code>ExampleModelItem</code> class stored in
      <filename>components/com_example/models/item.php</filename>. If you were
      to do that in the backend of the site you'd get the backend
      <code>ExampleModelItem</code> class stored in
      <filename>administrator/components/com_example/models/item.php</filename>.
      If you did that from outside the <code>com_example</code> component,
      e.g. in a module or plugin, it would fail unless either the class was
      already loaded beforehand OR you had done something like</para>

      <programlisting>\Joomla\CMS\MVC\Model\BaseDatabaseModel::addIncludePath(
  'components/com_example/models', 'ExampleModel'
);</programlisting>

      <para>Having to call a static method to get an object is bad
      architecture since the superclass where the static method lives in
      becomes a God Object — it knows way too much about how everything works
      in the entire CMS! Moreover, having the ability to auto–load classes
      only under certain circumstances, and having the object returned depend
      on both the application running under and magic configuration supplied
      by static method calls made it impossible to know what will be returned
      every time. The fact that backend and frontend classes had the exact
      same Fully Qualified Name made it impossible to double–check something
      didn't go awry. This loopy behaviour was a constant source of
      bugs.</para>

      <para>Joomla 4 addressed this source of endless frustration by
      introducing the MVCFactory service in the <link
      linkend="concepts-container">component's DI container</link>. The
      MVCFactory object implements the <link
      xlink:href="https://en.wikipedia.org/wiki/Factory_method_pattern">Factory
      method pattern</link> which means it can create instances of our MVC
      objects: controllers, models, views and tables.</para>

      <important>
        <para>Each MVCFactory object instance can only create MVC objects for
        a <emphasis role="bold">specific</emphasis> component! This is in
        stark contrast with the static calls in Joomla 3 which could create an
        MVC object for just about any component.</para>

        <para>This is actually a good thing! It is implementing the
        fundamental computer science principle called <link
        xlink:href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation
        of Concerns</link>. Put another way, if I get the MVCFactory object
        for <code>com_example</code> I know that it can create any MVC object
        I need for <code>com_example</code> and only that components. It won't
        be “polluted” by any other component. Every time I call an MVCFactory
        method <emphasis role="bold">I AM 100% CONFIDENT</emphasis> I am
        getting the object I asked for and expected, not something potentially
        random I have no way of checking. Therefore, the MVCFactory object
        solves the single biggest source of frustration in Joomla component
        development. Hallelujah!</para>
      </important>

      <para>When you are writing code in a Controller or Model class you can
      get your own component's MVCFactory instance using the
      <code>$this-&gt;getMVCFactory()</code> method.</para>

      <para>If you are outside a component — a module, plugin, template or a
      different component — you can <emphasis>still</emphasis> get the
      MVCFactory of any installed and enabled component on the site as we saw
      in <link linkend="com-lifetime">the lifetime of a
      component</link>:</para>

      <programlisting>$comContentMVCFactory = \Joomla\CMS\Factory::getApplication()
  -&gt;bootComponent('com_content')
  -&gt;getMVCFactory();</programlisting>

      <tip>
        <para>Before trying to boot a component you are supposed to check the
        component is installed <emphasis>and</emphasis> enabled. You can do
        that very simply, e.g. for <code>com_content</code>, with this
        code</para>

        <programlisting>\Joomla\CMS\Component\ComponentHelper::isEnabled('com_content')</programlisting>
      </tip>

      <para>The MVCFactory has four public methods corresponding to the MVC
      objects we can create:</para>

      <variablelist>
        <varlistentry>
          <term>createController</term>

          <listitem>
            <para>Loads and creates a controller object.</para>

            <programlisting>$myController = $this-&gt;getMVCFactory()
  -&gt;createController('Item', 'Administrator');</programlisting>

            <para>The first argument is the name of the controller. The second
            argument is the application type (<code>Site</code>,
            <code>Administrator</code>, or <code>Api</code>).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>createModel</term>

          <listitem>
            <para>Loads and creates a model object.</para>

            <programlisting>$myModel = $this-&gt;getMVCFactory()
  -&gt;createModel('Item', 'Administrator');</programlisting>

            <para>The first argument is the name of the controller. The second
            argument is the application type (<code>Site</code>,
            <code>Administrator</code>, or <code>Api</code>).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>createView</term>

          <listitem>
            <para>Loads and creates a view object.</para>

            <programlisting>$myView = $this-&gt;getMVCFactory()
  -&gt;createView('Item', 'Administrator', 'Html');</programlisting>

            <para>The first argument is the name of the controller. The second
            argument is the application type (<code>Site</code>,
            <code>Administrator</code>, or <code>Api</code>). The third
            argument is the view type which corresponds to the
            <parameter>format</parameter> URL parameter.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>createTable</term>

          <listitem>
            <para>Loads and creates a table object.</para>

            <programlisting>$myTable = $this-&gt;getMVCFactory()
  -&gt;createTable('Item', 'Administrator');</programlisting>

            <para>The first argument is the name of the controller. The second
            argument is the application type (<code>Site</code>,
            <code>Administrator</code>, or <code>Api</code>).</para>

            <warning>
              <para>Joomla table classes are only defined in the backend
              (<code>Administrator</code>) of your component. Therefore your
              second argument MUST always be
              <code>'Administrator'</code>.</para>

              <para>While you could conceivably define table classes in the
              site or api parts of your component it's not recommended and you
              should not expect Joomla's core code to be able to find them.
              Think of that second argument as a “forwards compatibility”
              provision, in case Joomla ever fully supports creating tables in
              the site or api parts of your component.</para>
            </warning>
          </listitem>
        </varlistentry>
      </variablelist>

      <bridgehead>MVCFactory and Dependency Injection</bridgehead>

      <para>The MVCFactory also performs a modicum of dependency injection. It
      inspects each created MVC object and checks which interfaces it
      implements. Depending on which interfaces are implemented some basic
      objects (form factory, dispatcher, router, cache controller, database
      object) are taken from the corresponding services in the component's DI
      container and injected into the MVC object.</para>

      <para>If you want to inject additional services you will have to extend
      the MVCFactory service in your component's service provider using a
      custom MVCFactory wrapper. When registering the service extension in
      your component's <link linkend="com-services">service provider</link>
      you can push your custom service to the MVCFactory wrapper and use it in
      the overridden methods of the wrapper. We will see an example of that
      <link linkend="com-models-push-service-joomla">pushing a custom service
      into a Model</link> later in this book.</para>

      <para>While this sounds like a bit of a chore, it is actually a very
      clean architecture. If you decide to make a change in your service's
      initialisation — or swap it out with a completely different
      implementation altogether — you can do that trivially by changing one
      line of code in your service provider. No more hunting down all over
      your codebase for that elusive reference to the service you are using.
      This is just another way Dependency Injection helps you write more
      sustainable code.</para>
    </section>

    <section xml:id="com-models">
      <title>Models</title>

      <para>The bulk of the implementation logic for Joomla 4 MVC models is
      the same as in Joomla 3 MVC.</para>

      <para>The Model classes extend from one of the base Joomla MVC Model
      super–classes:</para>

      <variablelist>
        <varlistentry>
          <term>Joomla\CMS\MVC\Model\BaseModel</term>

          <listitem>
            <para>The most basic model you can get. It does not connect to a
            database and does not support form. This is the kind of model you
            may need to use if you have a static view in your component (e.g.
            a control panel not implemented with a core <link
            linkend="com-dashboard">Dashboard</link>), if your model deals
            with data outside of the database (e.g. processing images, talking
            to a third party API over HTTP, converting files, etc) or if it
            uses an external or third party library (e.g. in Akeeba Backup the
            BackupModel uses our Akeeba Engine backup engine library).</para>

            <para>The basic service it provide is model state management using
            the <code>getState</code>, <code>setState</code> and
            <code>populateState</code> methods.</para>

            <tip>
              <para>In a proper MVC implementation the only way the Controller
              would “talk” to a Model is by setting its state and then reading
              either the return value of the method it called or inspecting
              the Model's state.</para>

              <para>In Joomla MVC the model state is a weird beast. It is
              ‘normally’ set by reading it from the session and overriding it
              from the request parameters using the application's
              <code>getUserStateFromRequest</code> method.</para>

              <para>While this is mostly okay for simple administrator pages
              listing and editing records you may find yourself in situations
              where you need to “talk” to the model from the Controller.
              Instead of passing this information around as HTTP GET/POST
              parameters — which can be inspected and
              <emphasis>overridden</emphasis> by a curious or malicious user —
              I urge you to instead override the <code>display</code> method
              of your Controller and set the Model's state after instantiating
              it. This is something you will not see anywhere in the Joomla
              core code but something you SHOULD be doing in your more complex
              components to avoid embarrassing and easily preventable security
              vulnerabilities.</para>

              <para>Speaking of which, <emphasis>always</emphasis> validate
              the data type and values of your model state in your code.
              Writing secure code requires you to adopt a “trust no–one”
              stance against any data which is not hard–coded into your
              extension's code! Do not assume that the data will be safe
              because (you think that) only a Super User can access a specific
              view. First of all, your assumption may be wrong. Moreover, your
              Model may be used outside the View you have in mind, even by
              third party components, plugins and modules integrating with
              your extension. Trust no–one, not even your own
              assumptions!</para>
            </tip>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\BaseDatabaseModel</term>

          <listitem>
            <para>This is an extension to BaseModel primarily adding database
            support. You can get the applicable database object with
            <code>$this-&gt;getDbo()</code> (Joomla 4.0 or later 4.x version)
            or <code>$this-&gt;getDatabase()</code> (Joomla 4.2 and later
            versions, including 5.0 and later).</para>

            <para>Beyond that, it lets you dispatch events using the global
            Event Dispatcher you get with
            <code>$this-&gt;getDispatcher()</code> (Joomla 4.2 and later), get
            the Joomla user object of the currently logged in user with
            <code>$this-&gt;getCurrentUser()</code> (Joomla 4.2 and later),
            and get the CacheControllerFactory to talk to Joomla's cache with
            <code>$this-&gt;getCacheControllerFactory()</code> (Joomla 4.2 and
            later).</para>

            <para>This is the most used type of model super–class, either
            having your models directly extend it or indirectly extend it by
            using one of its descendant classes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\FormModel</term>

          <listitem>
            <para>This is an extension to the BaseDatabaseModel which
            additionally implements Form handling.</para>

            <important>
              <para>This IS NOT the class you want to extend in pages which
              edit existing or create new records! What you are looking for in
              this case is Joomla\CMS\MVC\Model\AdminModel (yes, even in the
              frontend!).</para>
            </important>

            <para>This is the kind of Model you are going to use on pages
            which render a Form using an XML file for collecting information
            from the user BUT NOT for the purpose of editing or creating a
            record.</para>

            <para>A practical example of this is the Joomla Global
            Configuration page's model
            (<code>Joomla\Component\Config\Administrator\Model\ApplicationModel</code>)
            which does render an XML form with the Global Configuration
            option. Compare this to the article edit page's model
            (<code>Joomla\Component\Content\Administrator\Model\ArticleModel</code>)
            and the difference becomes evident right away!</para>

            <para>In your components you might want to use this type of Model
            in custom configuration pages. For example, you may have a
            component which post new articles automatically on social media.
            You may want to create different configurations for Facebook,
            Twitter, Reddit and whatnot. The page managing each of these
            configurations, each one using its own XML form file, would very
            likely use a Model class extending from <code>FormModel</code>
            instead of <code>AdminModel</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\AdminModel</term>

          <listitem>
            <para>This is an extension to the <code>FormModel</code> which is
            designed specifically for creating new and editing existing
            records.</para>

            <para>What is the difference? Whereas <code>FormModel</code> is
            made to deal with the collection of arbitrary data, the
            <code>AdminModel</code> is made to create and edit records having
            the same data shape, defined in a database table. As a result, it
            works together with a <link linkend="com-tables">Table
            object</link>. Most of its methods will be talking to the Table
            object.</para>

            <para>It also supports automatic integration with content plugins
            and implements the methods you need to save new/existing records,
            reorder records, change record associations, batch process
            records, check–in and check–out records to the database, change
            the publish / trash state, and permanently delete records. Yup,
            this type of Model basically handles nearly everything you need to
            manage records in the backend of a site
            <emphasis>except</emphasis> listing records.</para>

            <note>
              <para>I had personally found it extremely confusing that the
              <code>AdminModel</code> (and the corresponding
              <code>FormController</code>) is responsible for handling all the
              actions you see available in the toolbar of a records list page.
              When you think about architecture it does make sense. When you
              are new to Joomla you might wonder why this is not handled by
              <code>ListModel</code> (and its corresponding
              <code>AdminController</code>). This is unfortunately a case of
              “you do this just because”, not a case of using what you'd
              intuitively think is the right thing to use. I know,
              right?!</para>

              <para>You may also get confused by the fact that an
              AdminController has a ListModel whereas a FormController has an
              AdminModel. It looks like someone had a stroke trying to name
              things.</para>

              <para>Thankfully, no, nobody had a stroke — the weird naming
              comes from the fact that when forms were introduced in Joomla
              1.6 we had to maintain backwards compatibility to Joomla 1.5,
              thereby causing a class naming mayhem. You know what are the two
              hardest things in software development? Handling dates, managing
              backwards compatibility and off–by–one errors!</para>
            </note>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\ItemModel</term>

          <listitem>
            <para>This is an extension of the DatabaseModel, designed to
            <emphasis>display</emphasis> a single record in the
            frontend.</para>

            <para>This is something you will use probably a lot in the
            frontend of your application when you want to show a single record
            which cannot be edited. Unlike the FormModel and the AdminModel,
            this Model class does not have any kind of management code for the
            records. It just displays them and that's it.</para>

            <tip>
              <para>Practically speaking, you might just end up extending your
              frontend Model from your backend Model which in turn extends
              from Joomla's AdminModel if you need to provide any kind of
              frontend administration of your component. There is no point
              creating two models to talk to the same data, one just to show
              it and one just to modify it. It also makes no sense to have
              your frontend Model extend from AdminModel and duplicate your
              code (WET code) when you can simply extend your backend model
              and refrain from repeating yourself (DRY code).</para>
            </tip>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Joomla\CMS\MVC\Model\ListModel</term>

          <listitem>
            <para>This class extends from the DatabaseModel and has the
            ability to manage forms (you need them for Search Tools a.k.a.
            list filters) and, crucially, to provide pagination–aware list of
            records from a database table.</para>

            <para>You know how the main Joomla backend user interface pattern
            is a list of records? Yup, this is the Model which implements
            it.</para>

            <tip>
              <para>In the frontend of your component you will very frequently
              find yourself needing to list a bunch of items in
              pagination–aware lists. The traditional Joomla code pattern was
              to create a frontend Model which extended from BaseDatabaseModel
              and have the same code to list items copied over from the
              backend.</para>

              <para>Don't do that. It's WET code and I've already mentioned
              that it's the source of many a bug.</para>

              <para>What you will practically find yourself doing is extending
              the frontend Model from the backend Model. Unlike Joomla 3, this
              is now possible!</para>

              <para>You need to be acutely aware, though, that you will need
              to override the <code>populateState</code> method in the
              frontend model. By default, this method will accept any kind of
              user input for filtering the list of records which could indeed
              be used by a malicious user to display items they are not
              supposed to access!</para>

              <para>An even better approach is what I hinted to earlier.
              Override the <code>display</code> method of your Controller. In
              there, first do a <code>getState</code> on your model (to run
              the <code>populateState</code> and be done with it), then
              explicitly set the Model state using its <code>setState</code>
              method before passing it to your View object. When you do that,
              the state set by your Controller's code overrides whatever
              <code>populateState</code> did, thereby mitigating any security
              risks.</para>
            </tip>
          </listitem>
        </varlistentry>
      </variablelist>

      <section xml:id="com-models-interfaces-traits">
        <title>Interfaces and Traits</title>

        <para>In Joomla 3 each Model type tried to do everything under the sun
        and even implement features which might have nothing to do with your
        component, like tags and versioning.</para>

        <para>In Joomla 4 and later versions the default Model classes don't
        do any of that. That's a good thing because it promotes the computer
        science principle called Separation of Concerns. If you need
        additional features you will be doing a bit of <emphasis>object
        composition</emphasis>.</para>

        <para>For those with a Computer Science background, you may wonder how
        you can do object composition in a language like PHP which, unlike C
        for example, does not allow classes to inherit (extend) from multiple
        classes. The answer is by using Traits provided by Joomla.</para>

        <variablelist>
          <varlistentry>
            <term>\Joomla\CMS\Versioning\VersionableModelTrait</term>

            <listitem>
              <para>Implements support for Versions (record history).</para>

              <para>Only applicable to models extending from
              <code>AdminModel</code>. This requires the <guilabel>Behaviour -
              Versionable</guilabel> plugin to be published. The corresponding
              Table must implement the
              <code>\Joomla\CMS\Versioning\VersionableTableInterface</code>
              interface and the corresponding Controller must use the
              <code>\Joomla\CMS\Versioning\VersionableControllerTrait</code>
              trait.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>\Joomla\CMS\MVC\Model\WorkflowBehaviorTrait</term>

            <listitem>
              <para>Implements support for Workflows (prescribed steps for
              state changes in records).</para>

              <para>Only applicable to models extending from
              <code>AdminModel</code>. The model must implement the
              <code>\Joomla\CMS\MVC\Model\WorkflowModelInterface</code>
              interface.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section xml:id="com-models-push-service-joomla">
        <title>Pushing services to the Model: the Joomla Way</title>

        <note>
          <para>This way only applies to Joomla 4.3 and later. If you want
          your component to support earlier Joomla versions you will have to
          use the alternative method outlined towards the end of this
          section.</para>
        </note>

        <para>TODO — This section is pending the submission and acceptance of
        a Pull Request to the Joomla Project.</para>
      </section>

      <section xml:id="com-models-push-service-alt">
        <title>Pushing services to the Model: an alternative</title>

        <para>While Joomla 4.3 and later allows you to push services into the
        Model using an MVCFactory wrapper which extends the MVC service,
        necessary parts of this architecture did not exist in previous Joomla
        versions. We will have to use a slightly less “architecturally clean”
        solution.</para>

        <para>We will <emphasis role="bold">pull</emphasis> the custom service
        <emphasis role="bold">from</emphasis> the component's DIC.</para>

        <para>First, you need to make sure that you register a service
        provider in <link linkend="com-services">your component's service
        provider</link> implementation:</para>

        <programlisting>$container-&gt;set(
    \Acme\Example\Administrator\Service\FacebookPublish::class,
    function (Container $container) {
        return new \Acme\Example\Administrator\Service\FacebookPublish();
    }
);</programlisting>

        <para>Then, you need to modify your <link
        linkend="com-extension">component's extension class section</link> as
        we saw on that section's “Getting access to the component's DIC
        anytime, anywhere” to be able to statically return the component's DI
        Container anytime, anywhere:</para>

        <programlisting>	protected static $dic;

	public function boot(ContainerInterface $container)
	{
		self::$dic = $container;
	}
	
	public static function getContainer()
	{
		if (empty(self::$dic))
		{
			Factory::getApplication()
			       -&gt;bootComponent('com_example');
		}
		
		return self::$dic;
	}</programlisting>

        <para>Now your Model can simply pull the service from the Component's
        DIC in its constructor:</para>

        <programlisting>&lt;?php

namespace Acme\Example\Administrator\Model;

use Acme\Example\Administrator\Extension\ExampleComponent;
use Acme\Example\Administrator\Service\FacebookPublish;
use Joomla\CMS\Form\FormFactoryInterface;
use Joomla\CMS\MVC\Factory\MVCFactoryInterface;
use Joomla\CMS\MVC\Model\AdminModel;

class ItemModel extends AdminModel
{
	private $fbPublish;

	public function __construct($config = [], MVCFactoryInterface $factory = null,
								FormFactoryInterface $formFactory = null)
	{
		parent::__construct($config, $factory, $formFactory);

		$exampleDIC      = ExampleComponent::getContainer();
		$this-&gt;fbPublish = $exampleDIC-&gt;get(FacebookPublish::class);
	}

	protected function getFacebookPublish(): FacebookPublish
	{
		return $this-&gt;fbPublish;
	}

	// The rest of your model's code goes here…
}</programlisting>

        <para>For completeness' sake, here are there are two (minor) downsides
        to this approach:</para>

        <itemizedlist>
          <listitem>
            <para>The Model now has a direct hard dependency on the
            component's extension class. For real world use inside Joomla this
            is not a big deal; the only recommended way to create instances of
            a component's Models is through its MVCFactory object which
            necessarily goes through the component's extension object. If you
            are writing Unit Tests, though, you can no longer isolate the
            Model. You will need to inject a dependency injection container
            with your custom service in the component's extension
            class.</para>
          </listitem>

          <listitem>
            <para>The extension class has a static method to fetch the DIC. If
            this is not already set up it will try to go through the global
            application object to boot the component. If you are writing Unit
            Tests this is a problem, hence why I said that you need to inject
            a DIC to your component's extension class.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="com-controllers">
      <title>Controllers</title>

      <para>The bulk of the implementation logic for Joomla 4 MVC Controllers
      is the same as in Joomla 3 MVC.</para>

      <para>The logic is that most views are displayed using the component's
      <code>DisplayController</code> which extends from Joomla's
      <code>Joomla\CMS\MVC\Controller\BaseController</code>. You only write
      custom controllers when there's an action needed or when you need access
      to a Form object.</para>

      <tip>
        <para>The kind of MVC practiced by Joomla and described above is a bit
        “dirty”; all views share a common DisplayController for displaying.
        This is fine with Joomla's one–trick–pony components, only able to
        display one kind of information. </para>

        <para>When you have something more complex this may not be at all
        convenient. For example, a document management system might need
        separate views to display nested categories, available items
        (including the actual <emphasis>downloading</emphasis> part!) and
        uploading items, as well as viewing, adding and managing comments per
        document. In these cases it's typically much more efficient to have a
        separate controller per view. In components like that each view
        consists of a Controller, Model and View class (an MVC triad) which is
        more in line with how the normative MVC coding pattern is meant to
        work. This is perfectly possible in Joomla <emphasis>as long as you
        have a custom Dispatcher</emphasis>. You can see how I am doing that
        <link
        xlink:href="https://github.com/akeeba/release-system/blob/development/component/backend/src/Dispatcher/Dispatcher.php">in
        the Dispatcher of Akeeba Release System</link>, the software downloads
        management software used by Joomla's official Downloads site.</para>
      </tip>

      <para>The Controller classes extend from one of the base Joomla MVC
      Model super–classes:</para>

      <variablelist>
        <varlistentry>
          <term>Joomla\CMS\MVC\Controller\BaseController</term>

          <listitem>
            <para>The most basic controller you can get. It is mainly used to
            power the <code>DisplayController</code> of the component or
            whenever you want to create custom controllers to display stuff
            and perform non–administrative actions (e.g. in the
            frontend).</para>

            <warning>
              <para>Heads up! In Joomla 3 the default display controller was
              in the root of the component as the file
              <filename>controller.php</filename> e.g.
              <filename>administrator/components/com_example/controller.php</filename>.
              This is no longer the case in Joomla 4 and later. All
              controllers are under the <filename>src/Controller</filename>
              folder and the default controller is named
              <code>DisplayController</code> which means that in the above
              example it would be located in
              <filename>administrator/components/com_example/srs/Controller/DisplayController.php</filename>.</para>

              <para>In Joomla 4 and later the <code>DisplayController</code>
              is mostly empty except for a line like this:</para>

              <programlisting>protected $default_view = 'foobar';</programlisting>

              <para>This is the name of the “default view”. That's the view
              which will be displayed if the <parameter>view</parameter> URL
              parameter is not provided in the request.</para>
            </warning>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\Controller\AdminController</term>

          <listitem>
            <para>This is an extension to BaseController. It is meant for
            displaying list views in the backend of your site, e.g. a list of
            articles.</para>

            <tip>
              <para>This is the controller you will be typically using for
              controllers whose name is <emphasis
              role="bold">plural</emphasis> such as
              <code>\Acme\Example\Administrator\Controller\ItemsController</code>.
              Since this is the Items controller and “items” is plural it
              gives us a hint that it will be displaying multiple items which,
              in the Joomla backend, is very likely to be a list.</para>

              <para>A mnemonic way to remember this is PASiFIC (yes, with the
              misspelling and all) "Plural Admin Singular Form Identifies the
              Controller".</para>
            </tip>

            <para>It also handles <emphasis role="bold">some</emphasis> of the
            admin tasks you will have to perform on records in a Joomla list
            view: publish, unpulish, archive, trash, report, orderup,
            orderdown, delete, reorder, saveorder, checkin, checkout,
            saveOrderAjax and runTransition. Everything else has to be handled
            by a singular named Controller which extends FormController. Yes,
            that's confusing and yes, it's the source of many bugs — but
            that's the same as Joomla 3 and earlier so at least it's
            <emphasis>consistently confusing</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\Controller\FormController</term>

          <listitem>
            <para>This is an extension to the BaseController which
            additionally implements Form handling. This is meant to be used in
            views which add or edit a database record. Additionally, it will
            be used in views which handle an XML Form e.g. a configuration
            page.</para>

            <tip>
              <para>This is the controller you will be typically using for
              controllers whose name is <emphasis
              role="bold">singular</emphasis> such as
              <code>\Acme\Example\Administrator\Controller\ItemController</code>.
              Since this is the Item controller and “item” is singular it
              gives us a hint that it will be displaying a single item which,
              in the Joomla backend, is very likely to be an add / edit record
              page.</para>

              <para>In the frontend of the site you may have <emphasis
              role="bold">two</emphasis> controllers for the same data type.
              One DisplayController extending from BaseController to display
              the item and one singular name controller extending from
              FormController to add or edit an item. It
              <emphasis>is</emphasis> possible to have a single controller,
              extending from FormController. You see, FormController itself
              extends from BaseController which has the display method which
              is used to display stuff, i.e. it already contains the
              functionality of the typical DisplayController.</para>
            </tip>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\Joomla\CMS\MVC\Controller\ApiController</term>

          <listitem>
            <para>This is a very special kind of controller which is only used
            in the <link linkend="com-api">JSON API application part of your
            component</link> e.g. the code under
            <filename>api/components/com_example</filename>. </para>

            <para>This type of controller does not have a direct equivalent in
            the other controllers. It can do everything. Produce a list of
            records, return a single record, create a new record and modify or
            delete an existing record.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <section xml:id="com-controllers-basic-services">
        <title>Basic services in your Controller</title>

        <para>A Controller object created by Joomla has a few basic services.
        In the olden days before Joomla 4 we had to use static methods in
        <code>\Joomla\CMS\Factory</code> (formerly <code>JFactory</code>) or
        the base MVC objects themselves to get access to these services. You
        are no longer supposed to do that, you are supposed to use the
        services provided in the Controller object itself.</para>

        <bridgehead>Application</bridgehead>

        <para>In Joomla 3 and earlier we would get the currently active
        application object through
        <code>\Joomla\CMS\Factory::getApplication()</code>. Do NOT do
        that.</para>

        <para>In Joomla 4 and later you can get the currently active
        application object through <code>$this-&gt;app</code>.</para>

        <para>Please remember that the application you are getting is not
        necessarily a <code>SiteApplication</code> or
        <code>AdministratorApplication</code>. It may very well be an
        <code>ApiApplication</code> (JSON API), a
        <code>ConsoleApplication</code> (Joomla CLI app) or even a custom
        application extending from
        <code>\Joomla\CMS\Application\CMSApplication</code>.</para>

        <bridgehead>Dispatcher</bridgehead>

        <para>In Joomla 3 and earlier you'd run plugin events by doing
        something like this:</para>

        <programlisting>$results = \Joomla\CMS\Factory::getApplication()
  -&gt;triggerEvent('onSomething', [$param1, $param2]);</programlisting>

        <para>In Joomla 4 and later there are two ways to call plugin
        events.</para>

        <para>The first method is the legacy method, going through the
        application's <code>triggerEvent</code> method, which is discouraged
        and will eventually go away.</para>

        <programlisting>$results = $this-&gt;app-&gt;triggerEvent('onSomething', [$param1, $param2]);</programlisting>

        <para>The second and recommended method is going through the Joomla
        events dispatcher and using real events.</para>

        <programlisting>$event = \Joomla\CMS\Event\GenericEvent::create('onSomething', [$param1, $param2]);
$this-&gt;getDispatcher()-&gt;dispatch($event-&gt;getName(), $event);
$results = $event-&gt;getArgument('result', []);</programlisting>

        <para>While this looks a bit more complicated it has some
        benefits.</para>

        <para>Using Events to access plugins means that you get access to a
        <link linkend="plg-concrete-events">concrete event object</link>. All
        core Joomla events will correspond to concrete event objects in Joomla
        5.0, meaning that you will be able to add typehinting and have your
        IDE (e.g. phpStorm, Visual Studio Code, NetBeans, Eclipse, ...)
        auto–complete the argument names when manipulating an event.</para>

        <para>The real Events implemented in Joomla 4 and later, unlike plain
        old plugin handlers we had in Joomla 1.0 to 3.10, can prevent some of
        their arguments to be modified, prescribe exactly
        <emphasis>what</emphasis> can be modified and even allow plugins to
        stop the processing of an event when we reach a point that further
        processing is unnecessary. If you slowly move from just using custom
        event names to concrete event classes you can implement far more
        complex features in your code with much less code — believe me, I've
        been there and done that! Event handling is one of those fundamental
        things which you are <emphasis>really</emphasis> upset it's changed
        but once you start getting the idea of how the new system works you
        start wondering how you could have ever written software without
        it.</para>

        <bridgehead>Input</bridgehead>

        <para>Back in the olden days we'd get the user's input by doing one of
        these (the more of these you remember the older you are — some date
        back to the early 00s!):</para>

        <programlisting>// Joomla 1.0
$foo = \JRequest::getCmd('foo');
// Joomla 1.5
$input = new \Joomla\CMS\Input\Input();
$foo = $input-&gt;getCmd('foo');
// Joomla 1.6
$foo = Joomla\CMS\Factory::getApplication()-&gt;input-&gt;getCmd('foo');</programlisting>

        <para>This had always been a bad idea because our Controller had to
        <emphasis>know</emphasis> about the global application object and its
        request variables. This meant, for example, that we could not reuse
        our component to display a view <link linkend="com-hmvc">using
        HMVC</link>.</para>

        <para>Since Joomla 3.0 the Controller object has an <code>input</code>
        property which holds its own <code>\Joomla\CMS\Input\Input</code>
        object. In Joomla 3 this was typically just the application's input
        object unless you were manually constructing a controller (with a lot
        of effort).</para>

        <para>In Joomla 4.0 and later the input property contains its own
        \Joomla\CMS\Input\Input object <emphasis>which comes from the DI
        Container of the component</emphasis>. Remember that when booting a
        component we get access to its <link linkend="com-extension">component
        extension object</link> which has access to the component's <link
        linkend="concepts-container">DI Container</link>. This of course means
        that we can add <link linkend="com-extension-dic-proxy">a method to
        that object to access the DI Container</link> and set a custom input
        object, thereby implementing HMVC very easily — something that Joomla
        core maintainers didn't think was possible with the core architecture
        a few years ago! This means that whenever we want to create a module
        which displays the same information an existing view of our component
        already does, albeit in a slightly different format, all we need to do
        is create a new view template or layout and use HMVC, without having
        to rewrite our business logic in the module. We can write less code to
        do more. That's awesome!</para>

        <para>That is (one of the many reasons) why you should
        <emphasis>always</emphasis> be accessing the input as
        <code>$this-&gt;input</code> in your controllers. Now you know.</para>

        <bridgehead>MVCFactory</bridgehead>

        <para>Back in Joomla 1.0 to 3.10 creating an MVC object such as a
        Model, View, Table, or even another Controller from inside our
        Controller required calling static methods in the base MVC objects or
        proxy methods in the controller, like so:</para>

        <programlisting>$someController = \Joomla\CMS\MVC\Controller\BaseController::getInstance('Some');
$someModel = \Joomla\CMS\MVC\Model\BaseDatabaseModel::getInstance('Some', 'ExampleModel');
// or
$someModel = $this-&gt;createModel('Some', 'ExampleModel');
$someView = $this-&gt;createView('Some', 'ExampleView', 'Html');
$someTable = \Joomla\CMS\Table\Table::getInstance('Some', 'ExampleTable');</programlisting>

        <para>There are two things which strike us as suboptimal:</para>

        <itemizedlist>
          <listitem>
            <para>There is no consistency in how you create MVC objects. Some
            are static calls, some are method calls to proxy functions.</para>
          </listitem>

          <listitem>
            <para>There is no consistency in the arguments you provide.
            Creating a controller only needs its name (and requires the magic
            configuration array key <code>base_path</code> if you want to get
            a controller from a component other than the current one),
            creating anything else requires us to give it the prefix of the
            MVC class name (not just the component name).</para>
          </listitem>
        </itemizedlist>

        <para>This is what we'd call “sanity came here to die”.</para>

        <para>Joomla 3.10 introduced the MVCFactory for creating models, views
        and tables and Joomla 4.0 extended it by also letting it create
        controllers. See how easier and more consistent everything is
        now:</para>

        <programlisting>// Only on Joomla 4.0 and later
$someController = $this-&gt;getMVCFactory()-&gt;createController('Some', 'Administrator');
// Joomla 3.10 and later
$someModel = $this-&gt;getMVCFactory()-&gt;createModel('Some', 'Administrator');
$someView = $this-&gt;getMVCFactory()-&gt;createView('Some', 'Administrator', 'Html');
$someTable = $this-&gt;getMVCFactory()-&gt;createTable('Some', 'Administrator');
// Inside the Controller I can still do this (4.0 and later):
$someModel = $this-&gt;getModel('Some', 'Administrator');
$someView = $this-&gt;getView('Some', 'Administrator', 'Html');</programlisting>

        <para>First of all, we see that creating MVC objects is now very
        consistent and easier. </para>

        <para>Second, we notice that the <code>$prefix</code> argument is no
        longer something component–specific (such as
        <code>ExampleModel</code>) but simply the side of the application
        (Site, Administrator or Api) that we want to get the MVC object
        from.</para>

        <note>
          <para>Tables are only available in the Administrator side of the
          application. While you can theoretically defined different Table
          classes in the frontend (Site) or JSON API (Api) side it's not a
          good idea as you will very likely run into issues where the “wrong”
          table class is being used. As a result, it's advisable to always
          call <code>createTable</code> with two parameters and set the second
          parameter to <option>Administrator</option>).</para>
        </note>

        <para>Legacy Joomla 3 components still work despite the apparent
        backwards compatibility (b/c) break in the <code>getModel</code> and
        <code>getView</code> methods. Why is that? Well, it's because Joomla 4
        uses the <code>\Joomla\CMS\MVC\Factory\LegacyFactory</code> instead of
        <code>\Joomla\CMS\MVC\Factory\MVCFactory</code> for these components.
        The LegacyFactory is aware of the b/c break and acts accordingly so
        you, the extensions developer, do not suffer. This is possible because
        each component has its own DI Container. So that's another way how
        using a DI Container allowed Joomla to create an updated, richer MVC
        API without breaking backwards compatibility with Joomla 3 — at least
        until Joomla 6.0. Neat, huh?</para>

        <para>As a developer, you should remember this when you are inside a
        Controller writing code:</para>

        <itemizedlist>
          <listitem>
            <para>If you want to get a Model or View use the controller's
            <code>getModel</code> and <code>getView</code> methods.</para>
          </listitem>

          <listitem>
            <para>If you want to get another <code>Controller</code> or a
            <code>Table</code> do not instantiate them directly! Always go
            through the MVCFactory.</para>
          </listitem>

          <listitem>
            <para>The second argument to all these methods is the application
            side you are getting an object from. Leave it empty to use the
            <emphasis>current</emphasis> application side or pass an explicit
            value. If you leave it empty keep in mind that, for example, your
            backend controller may be running in the frontend. In this case,
            do you <emphasis>really</emphasis> want to get the frontend
            model?</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="com-views">
      <title>Views</title>

      <para/>
    </section>

    <section xml:id="com-tables">
      <title>Tables</title>

      <para/>
    </section>

    <section xml:id="com-html">
      <title>HTML helper service</title>

      <para/>
    </section>

    <section xml:id="com-categories">
      <title>Categories service</title>

      <para/>
    </section>

    <section xml:id="com-router">
      <title>Router</title>

      <para/>
    </section>

    <section xml:id="com-dashboard">
      <title>Dashboard</title>

      <para/>
    </section>

    <section xml:id="com-events">
      <title>Dispatching events (calling plugins)</title>

      <para/>
    </section>

    <section xml:id="com-data-to-frontend">
      <title>Passing data to the frontend</title>

      <para/>
    </section>

    <section xml:id="com-lang">
      <title>Language files</title>

      <para/>
    </section>

    <section xml:id="com-mailtemplates">
      <title>Mail Templates</title>

      <para/>
    </section>

    <section xml:id="com-layouts">
      <title>Layouts</title>

      <para/>
    </section>

    <section xml:id="com-cli">
      <title>The CLI application</title>

      <para/>
    </section>

    <section xml:id="com-api">
      <title>The API application</title>

      <para/>
    </section>

    <section xml:id="com-scheduled-tasks">
      <title>Integration with Scheduled Tasks</title>

      <para/>
    </section>

    <section xml:id="com-fields">
      <title>Custom fields</title>

      <para/>
    </section>

    <section xml:id="tags">
      <title>Tags</title>

      <para/>
    </section>

    <section xml:id="com-hmvc">
      <title>HMVC (sort of)</title>

      <para/>
    </section>

    <section xml:id="com-rector">
      <title>Using Rector</title>

      <para/>
    </section>

    <section xml:id="com-migration">
      <title>Migration strategy</title>

      <para/>
    </section>
  </chapter>

  <chapter xml:id="plg">
    <title>Plugins</title>

    <para/>

    <section xml:id="plg-forms">
      <title>The many forms of a Joomla plugin</title>

      <para/>

      <section xml:id="plg-forms-legacy">
        <title>Legacy (Joomla 1.x to 3.x)</title>

        <para/>
      </section>

      <section xml:id="plg-forms-j4-classic">
        <title>Joomla 4 classic</title>

        <para/>
      </section>

      <section xml:id="plg-forms-j4-subscriberinterface">
        <title>Joomla 4 with SubscriberInterface</title>

        <para/>
      </section>
    </section>

    <section xml:id="plg-namespaces">
      <title>Namespaces</title>

      <para/>
    </section>

    <section xml:id="plg-services">
      <title>Service Locator</title>

      <para/>
    </section>

    <section xml:id="plg-extension">
      <title>Extension class (plugin)</title>

      <para/>
    </section>

    <section xml:id="plg-lang">
      <title>Language files</title>

      <para/>
    </section>

    <section xml:id="plg-dont-break-joomla">
      <title>How NOT to break Joomla with your plugin</title>

      <para/>
    </section>

    <section xml:id="plg-concrete-events">
      <title>Generic versus Concrete events</title>

      <para/>
    </section>

    <section xml:id="plg-view-templates">
      <title>Using view templates</title>

      <para/>
    </section>

    <section xml:id="plg-interfacing-com">
      <title>Interfacing with your component</title>

      <para/>
    </section>

    <section xml:id="plg-migration">
      <title>Migration strategy</title>

      <para/>
    </section>
  </chapter>

  <chapter xml:id="mod">
    <title>Modules</title>

    <para/>

    <section xml:id="mod-legacy-vs-j4">
      <title>Legacy vs Joomla 4 modules</title>

      <para/>

      <section xml:id="mod-legacy">
        <title>Legacy modules (Joomla 1.x to 3.x)</title>

        <para/>
      </section>

      <section xml:id="mod-j4">
        <title>Joomla 4 modules</title>

        <para/>
      </section>
    </section>

    <section xml:id="mod-services">
      <title>Service Locator</title>

      <para/>
    </section>

    <section xml:id="mod-extension">
      <title>Extension class</title>

      <para/>
    </section>

    <section xml:id="mod-lang">
      <title>Language files</title>

      <para/>
    </section>

    <section xml:id="mod-helper">
      <title>The Helper</title>

      <para/>
    </section>

    <section xml:id="mod-view-templates">
      <title>View templates</title>

      <para/>
    </section>

    <section xml:id="mod-interfacing-com">
      <title>Interfacing with your component</title>

      <para/>
    </section>

    <section xml:id="mod-migration">
      <title>Migration strategy</title>

      <para/>
    </section>
  </chapter>

  <chapter xml:id="tpl">
    <title>Templates</title>

    <para/>

    <section xml:id="tpl-j4-changes">
      <title>Major changes in Joomla 4</title>

      <para/>
    </section>

    <section xml:id="tpl-subtemplates">
      <title>Sub-templates</title>

      <para/>
    </section>

    <section xml:id="tpl-custom-cassiopeia">
      <title>Using Cassiopeia to create a custom template</title>

      <para/>
    </section>

    <section xml:id="tpl-custom-from-scratch">
      <title>Custom template from scratch</title>

      <para/>
    </section>

    <section xml:id="tpl-fields">
      <title>Custom fields in your templates</title>

      <para/>
    </section>

    <section xml:id="tpl-category-content-templates">
      <title>Per-category view templates in com_content</title>

      <para/>
    </section>

    <section xml:id="tpl-migration">
      <title>Migration strategy</title>

      <para/>
    </section>
  </chapter>

  <appendix>
    <title>GNU Free Documentation License</title>

    <simpara>Version 1.3, 3 November 2008</simpara>

    <simpara>Copyright © 2000, 2001, 2002, 2007, 2008 <link
    xlink:href="https://www.fsf.org/">Free Software Foundation,
    Inc.</link></simpara>

    <simpara>Everyone is permitted to copy and distribute verbatim copies of
    this license document, but changing it is not allowed.</simpara>

    <bridgehead renderas="sect2" xml:id="section0">0. PREAMBLE</bridgehead>

    <simpara>The purpose of this License is to make a manual, textbook, or
    other functional and useful document “free” in the sense of freedom: to
    assure everyone the effective freedom to copy and redistribute it, with or
    without modifying it, either commercially or noncommercially. Secondarily,
    this License preserves for the author and publisher a way to get credit
    for their work, while not being considered responsible for modifications
    made by others.</simpara>

    <simpara>This License is a kind of “copyleft”, which means that derivative
    works of the document must themselves be free in the same sense. It
    complements the GNU General Public License, which is a copyleft license
    designed for free software.</simpara>

    <simpara>We have designed this License in order to use it for manuals for
    free software, because free software needs free documentation: a free
    program should come with manuals providing the same freedoms that the
    software does. But this License is not limited to software manuals; it can
    be used for any textual work, regardless of subject matter or whether it
    is published as a printed book. We recommend this License principally for
    works whose purpose is instruction or reference.</simpara>

    <bridgehead renderas="sect2" xml:id="section1">1. APPLICABILITY AND
    DEFINITIONS</bridgehead>

    <simpara>This License applies to any manual or other work, in any medium,
    that contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License. Such a notice grants a
    world-wide, royalty-free license, unlimited in duration, to use that work
    under the conditions stated herein. The “Document”, below, refers to any
    such manual or work. Any member of the public is a licensee, and is
    addressed as “you”. You accept the license if you copy, modify or
    distribute the work in a way requiring permission under copyright
    law.</simpara>

    <simpara>A “Modified Version” of the Document means any work containing
    the Document or a portion of it, either copied verbatim, or with
    modifications and/or translated into another language.</simpara>

    <simpara>A “Secondary Section” is a named appendix or a front-matter
    section of the Document that deals exclusively with the relationship of
    the publishers or authors of the Document to the Document's overall
    subject (or to related matters) and contains nothing that could fall
    directly within that overall subject. (Thus, if the Document is in part a
    textbook of mathematics, a Secondary Section may not explain any
    mathematics.) The relationship could be a matter of historical connection
    with the subject or with related matters, or of legal, commercial,
    philosophical, ethical or political position regarding them.</simpara>

    <simpara>The “Invariant Sections” are certain Secondary Sections whose
    titles are designated, as being those of Invariant Sections, in the notice
    that says that the Document is released under this License. If a section
    does not fit the above definition of Secondary then it is not allowed to
    be designated as Invariant. The Document may contain zero Invariant
    Sections. If the Document does not identify any Invariant Sections then
    there are none.</simpara>

    <simpara>The “Cover Texts” are certain short passages of text that are
    listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says
    that the Document is released under this License. A Front-Cover Text may
    be at most 5 words, and a Back-Cover Text may be at most 25
    words.</simpara>

    <simpara>A “Transparent” copy of the Document means a machine-readable
    copy, represented in a format whose specification is available to the
    general public, that is suitable for revising the document
    straightforwardly with generic text editors or (for images composed of
    pixels) generic paint programs or (for drawings) some widely available
    drawing editor, and that is suitable for input to text formatters or for
    automatic translation to a variety of formats suitable for input to text
    formatters. A copy made in an otherwise Transparent file format whose
    markup, or absence of markup, has been arranged to thwart or discourage
    subsequent modification by readers is not Transparent. An image format is
    not Transparent if used for any substantial amount of text. A copy that is
    not “Transparent” is called “Opaque”.</simpara>

    <simpara>Examples of suitable formats for Transparent copies include plain
    ASCII without markup, Texinfo input format, LaTeX input format, SGML or
    XML using a publicly available DTD, and standard-conforming simple HTML,
    PostScript or PDF designed for human modification. Examples of transparent
    image formats include PNG, XCF and JPG. Opaque formats include proprietary
    formats that can be read and edited only by proprietary word processors,
    SGML or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML, PostScript or PDF produced by
    some word processors for output purposes only.</simpara>

    <simpara>The “Title Page” means, for a printed book, the title page
    itself, plus such following pages as are needed to hold, legibly, the
    material this License requires to appear in the title page. For works in
    formats which do not have any title page as such, “Title Page” means the
    text near the most prominent appearance of the work's title, preceding the
    beginning of the body of the text.</simpara>

    <simpara>The “publisher” means any person or entity that distributes
    copies of the Document to the public.</simpara>

    <simpara>A section “Entitled XYZ” means a named subunit of the Document
    whose title either is precisely XYZ or contains XYZ in parentheses
    following text that translates XYZ in another language. (Here XYZ stands
    for a specific section name mentioned below, such as “Acknowledgements”,
    “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of
    such a section when you modify the Document means that it remains a
    section “Entitled XYZ” according to this definition.</simpara>

    <simpara>The Document may include Warranty Disclaimers next to the notice
    which states that this License applies to the Document. These Warranty
    Disclaimers are considered to be included by reference in this License,
    but only as regards disclaiming warranties: any other implication that
    these Warranty Disclaimers may have is void and has no effect on the
    meaning of this License.</simpara>

    <bridgehead renderas="sect2" xml:id="section2">2. VERBATIM
    COPYING</bridgehead>

    <simpara>You may copy and distribute the Document in any medium, either
    commercially or noncommercially, provided that this License, the copyright
    notices, and the license notice saying this License applies to the
    Document are reproduced in all copies, and that you add no other
    conditions whatsoever to those of this License. You may not use technical
    measures to obstruct or control the reading or further copying of the
    copies you make or distribute. However, you may accept compensation in
    exchange for copies. If you distribute a large enough number of copies you
    must also follow the conditions in section 3.</simpara>

    <simpara>You may also lend copies, under the same conditions stated above,
    and you may publicly display copies.</simpara>

    <bridgehead renderas="sect2" xml:id="section3">3. COPYING IN
    QUANTITY</bridgehead>

    <simpara>If you publish printed copies (or copies in media that commonly
    have printed covers) of the Document, numbering more than 100, and the
    Document's license notice requires Cover Texts, you must enclose the
    copies in covers that carry, clearly and legibly, all these Cover Texts:
    Front-Cover Texts on the front cover, and Back-Cover Texts on the back
    cover. Both covers must also clearly and legibly identify you as the
    publisher of these copies. The front cover must present the full title
    with all words of the title equally prominent and visible. You may add
    other material on the covers in addition. Copying with changes limited to
    the covers, as long as they preserve the title of the Document and satisfy
    these conditions, can be treated as verbatim copying in other
    respects.</simpara>

    <simpara>If the required texts for either cover are too voluminous to fit
    legibly, you should put the first ones listed (as many as fit reasonably)
    on the actual cover, and continue the rest onto adjacent pages.</simpara>

    <simpara>If you publish or distribute Opaque copies of the Document
    numbering more than 100, you must either include a machine-readable
    Transparent copy along with each Opaque copy, or state in or with each
    Opaque copy a computer-network location from which the general
    network-using public has access to download using public-standard network
    protocols a complete Transparent copy of the Document, free of added
    material. If you use the latter option, you must take reasonably prudent
    steps, when you begin distribution of Opaque copies in quantity, to ensure
    that this Transparent copy will remain thus accessible at the stated
    location until at least one year after the last time you distribute an
    Opaque copy (directly or through your agents or retailers) of that edition
    to the public.</simpara>

    <simpara>It is requested, but not required, that you contact the authors
    of the Document well before redistributing any large number of copies, to
    give them a chance to provide you with an updated version of the
    Document.</simpara>

    <bridgehead renderas="sect2" xml:id="section4">4.
    MODIFICATIONS</bridgehead>

    <simpara>You may copy and distribute a Modified Version of the Document
    under the conditions of sections 2 and 3 above, provided that you release
    the Modified Version under precisely this License, with the Modified
    Version filling the role of the Document, thus licensing distribution and
    modification of the Modified Version to whoever possesses a copy of it. In
    addition, you must do these things in the Modified Version:</simpara>

    <orderedlist numeration="upperalpha">
      <listitem>
        <simpara>Use in the Title Page (and on the covers, if any) a title
        distinct from that of the Document, and from those of previous
        versions (which should, if there were any, be listed in the History
        section of the Document). You may use the same title as a previous
        version if the original publisher of that version gives
        permission.</simpara>
      </listitem>

      <listitem>
        <simpara>List on the Title Page, as authors, one or more persons or
        entities responsible for authorship of the modifications in the
        Modified Version, together with at least five of the principal authors
        of the Document (all of its principal authors, if it has fewer than
        five), unless they release you from this requirement.</simpara>
      </listitem>

      <listitem>
        <simpara>State on the Title page the name of the publisher of the
        Modified Version, as the publisher.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve all the copyright notices of the Document.</simpara>
      </listitem>

      <listitem>
        <simpara>Add an appropriate copyright notice for your modifications
        adjacent to the other copyright notices.</simpara>
      </listitem>

      <listitem>
        <simpara>Include, immediately after the copyright notices, a license
        notice giving the public permission to use the Modified Version under
        the terms of this License, in the form shown in the Addendum
        below.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve in that license notice the full lists of Invariant
        Sections and required Cover Texts given in the Document's license
        notice.</simpara>
      </listitem>

      <listitem>
        <simpara>Include an unaltered copy of this License.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve the section Entitled “History”, Preserve its Title,
        and add to it an item stating at least the title, year, new authors,
        and publisher of the Modified Version as given on the Title Page. If
        there is no section Entitled “History” in the Document, create one
        stating the title, year, authors, and publisher of the Document as
        given on its Title Page, then add an item describing the Modified
        Version as stated in the previous sentence.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve the network location, if any, given in the Document
        for public access to a Transparent copy of the Document, and likewise
        the network locations given in the Document for previous versions it
        was based on. These may be placed in the “History” section. You may
        omit a network location for a work that was published at least four
        years before the Document itself, or if the original publisher of the
        version it refers to gives permission.</simpara>
      </listitem>

      <listitem>
        <simpara>For any section Entitled “Acknowledgements” or “Dedications”,
        Preserve the Title of the section, and preserve in the section all the
        substance and tone of each of the contributor acknowledgements and/or
        dedications given therein.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve all the Invariant Sections of the Document,
        unaltered in their text and in their titles. Section numbers or the
        equivalent are not considered part of the section titles.</simpara>
      </listitem>

      <listitem>
        <simpara>Delete any section Entitled “Endorsements”. Such a section
        may not be included in the Modified Version.</simpara>
      </listitem>

      <listitem>
        <simpara>Do not retitle any existing section to be Entitled
        “Endorsements” or to conflict in title with any Invariant
        Section.</simpara>
      </listitem>

      <listitem>
        <simpara>Preserve any Warranty Disclaimers.</simpara>
      </listitem>
    </orderedlist>

    <simpara>If the Modified Version includes new front-matter sections or
    appendices that qualify as Secondary Sections and contain no material
    copied from the Document, you may at your option designate some or all of
    these sections as invariant. To do this, add their titles to the list of
    Invariant Sections in the Modified Version's license notice. These titles
    must be distinct from any other section titles.</simpara>

    <simpara>You may add a section Entitled “Endorsements”, provided it
    contains nothing but endorsements of your Modified Version by various
    parties — for example, statements of peer review or that the text has been
    approved by an organization as the authoritative definition of a
    standard.</simpara>

    <simpara>You may add a passage of up to five words as a Front-Cover Text,
    and a passage of up to 25 words as a Back-Cover Text, to the end of the
    list of Cover Texts in the Modified Version. Only one passage of
    Front-Cover Text and one of Back-Cover Text may be added by (or through
    arrangements made by) any one entity. If the Document already includes a
    cover text for the same cover, previously added by you or by arrangement
    made by the same entity you are acting on behalf of, you may not add
    another; but you may replace the old one, on explicit permission from the
    previous publisher that added the old one.</simpara>

    <simpara>The author(s) and publisher(s) of the Document do not by this
    License give permission to use their names for publicity for or to assert
    or imply endorsement of any Modified Version.</simpara>

    <bridgehead renderas="sect2" xml:id="section5">5. COMBINING
    DOCUMENTS</bridgehead>

    <simpara>You may combine the Document with other documents released under
    this License, under the terms defined in section 4 above for modified
    versions, provided that you include in the combination all of the
    Invariant Sections of all of the original documents, unmodified, and list
    them all as Invariant Sections of your combined work in its license
    notice, and that you preserve all their Warranty Disclaimers.</simpara>

    <simpara>The combined work need only contain one copy of this License, and
    multiple identical Invariant Sections may be replaced with a single copy.
    If there are multiple Invariant Sections with the same name but different
    contents, make the title of each such section unique by adding at the end
    of it, in parentheses, the name of the original author or publisher of
    that section if known, or else a unique number. Make the same adjustment
    to the section titles in the list of Invariant Sections in the license
    notice of the combined work.</simpara>

    <simpara>In the combination, you must combine any sections Entitled
    “History” in the various original documents, forming one section Entitled
    “History”; likewise combine any sections Entitled “Acknowledgements”, and
    any sections Entitled “Dedications”. You must delete all sections Entitled
    “Endorsements”.</simpara>

    <bridgehead renderas="sect2" xml:id="section6">6. COLLECTIONS OF
    DOCUMENTS</bridgehead>

    <simpara>You may make a collection consisting of the Document and other
    documents released under this License, and replace the individual copies
    of this License in the various documents with a single copy that is
    included in the collection, provided that you follow the rules of this
    License for verbatim copying of each of the documents in all other
    respects.</simpara>

    <simpara>You may extract a single document from such a collection, and
    distribute it individually under this License, provided you insert a copy
    of this License into the extracted document, and follow this License in
    all other respects regarding verbatim copying of that document.</simpara>

    <bridgehead renderas="sect2" xml:id="section7">7. AGGREGATION WITH
    INDEPENDENT WORKS</bridgehead>

    <simpara>A compilation of the Document or its derivatives with other
    separate and independent documents or works, in or on a volume of a
    storage or distribution medium, is called an “aggregate” if the copyright
    resulting from the compilation is not used to limit the legal rights of
    the compilation's users beyond what the individual works permit. When the
    Document is included in an aggregate, this License does not apply to the
    other works in the aggregate which are not themselves derivative works of
    the Document.</simpara>

    <simpara>If the Cover Text requirement of section 3 is applicable to these
    copies of the Document, then if the Document is less than one half of the
    entire aggregate, the Document's Cover Texts may be placed on covers that
    bracket the Document within the aggregate, or the electronic equivalent of
    covers if the Document is in electronic form. Otherwise they must appear
    on printed covers that bracket the whole aggregate.</simpara>

    <bridgehead renderas="sect2" xml:id="section8">8. TRANSLATION</bridgehead>

    <simpara>Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section 4.
    Replacing Invariant Sections with translations requires special permission
    from their copyright holders, but you may include translations of some or
    all Invariant Sections in addition to the original versions of these
    Invariant Sections. You may include a translation of this License, and all
    the license notices in the Document, and any Warranty Disclaimers,
    provided that you also include the original English version of this
    License and the original versions of those notices and disclaimers. In
    case of a disagreement between the translation and the original version of
    this License or a notice or disclaimer, the original version will
    prevail.</simpara>

    <simpara>If a section in the Document is Entitled “Acknowledgements”,
    “Dedications”, or “History”, the requirement (section 4) to Preserve its
    Title (section 1) will typically require changing the actual
    title.</simpara>

    <bridgehead renderas="sect2" xml:id="section9">9. TERMINATION</bridgehead>

    <simpara>You may not copy, modify, sublicense, or distribute the Document
    except as expressly provided under this License. Any attempt otherwise to
    copy, modify, sublicense, or distribute it is void, and will automatically
    terminate your rights under this License.</simpara>

    <simpara>However, if you cease all violation of this License, then your
    license from a particular copyright holder is reinstated (a)
    provisionally, unless and until the copyright holder explicitly and
    finally terminates your license, and (b) permanently, if the copyright
    holder fails to notify you of the violation by some reasonable means prior
    to 60 days after the cessation.</simpara>

    <simpara>Moreover, your license from a particular copyright holder is
    reinstated permanently if the copyright holder notifies you of the
    violation by some reasonable means, this is the first time you have
    received notice of violation of this License (for any work) from that
    copyright holder, and you cure the violation prior to 30 days after your
    receipt of the notice.</simpara>

    <simpara>Termination of your rights under this section does not terminate
    the licenses of parties who have received copies or rights from you under
    this License. If your rights have been terminated and not permanently
    reinstated, receipt of a copy of some or all of the same material does not
    give you any rights to use it.</simpara>

    <bridgehead renderas="sect2" xml:id="section10">10. FUTURE REVISIONS OF
    THIS LICENSE</bridgehead>

    <simpara>The Free Software Foundation may publish new, revised versions of
    the GNU Free Documentation License from time to time. Such new versions
    will be similar in spirit to the present version, but may differ in detail
    to address new problems or concerns. See <link
    xlink:href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</link>.</simpara>

    <simpara>Each version of the License is given a distinguishing version
    number. If the Document specifies that a particular numbered version of
    this License “or any later version” applies to it, you have the option of
    following the terms and conditions either of that specified version or of
    any later version that has been published (not as a draft) by the Free
    Software Foundation. If the Document does not specify a version number of
    this License, you may choose any version ever published (not as a draft)
    by the Free Software Foundation. If the Document specifies that a proxy
    can decide which future versions of this License can be used, that proxy's
    public statement of acceptance of a version permanently authorizes you to
    choose that version for the Document.</simpara>

    <bridgehead renderas="sect2" xml:id="section11">11.
    RELICENSING</bridgehead>

    <simpara>“Massive Multiauthor Collaboration Site” (or “MMC Site”) means
    any World Wide Web server that publishes copyrightable works and also
    provides prominent facilities for anybody to edit those works. A public
    wiki that anybody can edit is an example of such a server. A “Massive
    Multiauthor Collaboration” (or “MMC”) contained in the site means any set
    of copyrightable works thus published on the MMC site.</simpara>

    <simpara>“CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
    license published by Creative Commons Corporation, a not-for-profit
    corporation with a principal place of business in San Francisco,
    California, as well as future copyleft versions of that license published
    by that same organization.</simpara>

    <simpara>“Incorporate” means to publish or republish a Document, in whole
    or in part, as part of another Document.</simpara>

    <simpara>An MMC is “eligible for relicensing” if it is licensed under this
    License, and if all works that were first published under this License
    somewhere other than this MMC, and subsequently incorporated in whole or
    in part into the MMC, (1) had no cover texts or invariant sections, and
    (2) were thus incorporated prior to November 1, 2008.</simpara>

    <simpara>The operator of an MMC Site may republish an MMC contained in the
    site under CC-BY-SA on the same site at any time before August 1, 2009,
    provided the MMC is eligible for relicensing.</simpara>

    <bridgehead renderas="sect2" xml:id="addendum">ADDENDUM: How to use this
    License for your documents</bridgehead>

    <simpara>To use this License in a document you have written, include a
    copy of the License in the document and put the following copyright and
    license notices just after the title page:</simpara>

    <screen>Copyright © YEAR YOUR NAME

Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.3 or any later version
published by the Free Software Foundation; with no Invariant Sections, no
Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in
the section entitled “GNU Free Documentation License”.</screen>

    <simpara>If you have Invariant Sections, Front-Cover Texts and Back-Cover
    Texts, replace the “with… Texts.” line with this:</simpara>

    <screen>with the Invariant Sections being LIST THEIR TITLES, with the Front-Cover Texts
being LIST, and with the Back-Cover Texts being LIST.</screen>

    <simpara>If you have Invariant Sections without Cover Texts, or some other
    combination of the three, merge those two alternatives to suit the
    situation.</simpara>

    <simpara>If your document contains nontrivial examples of program code, we
    recommend releasing these examples in parallel under your choice of free
    software license, such as the GNU General Public License, to permit their
    use in free software.</simpara>
  </appendix>
</book>
