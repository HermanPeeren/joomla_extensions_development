<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>10.&nbsp;Models</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Joomla Extensions Development"><link rel="up" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Components"><link rel="prev" href="ch03s09.html" title="9.&nbsp;The MVCFactory"><link rel="next" href="ch03s11.html" title="11.&nbsp;Controllers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">10.&nbsp;Models</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s09.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;3.&nbsp;Components</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch03s11.html"><img src="images/next.svg" alt="Next"></a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="com-models"></a>10.&nbsp;Models</h2></div></div></div><p>The bulk of the implementation logic for Joomla 4 MVC models is the same as in Joomla 3 MVC.</p><p>The Model classes extend from one of the base Joomla MVC Model super-classes:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Joomla\CMS\MVC\Model\BaseModel</span></dt><dd><p>The most basic model you can get. It does not connect to a database and does not support form. This is the kind of model you may need to use if you have a static view in your component (e.g. a control panel not implemented with a core <a class="link" href="ch03s17.html" title="17.&nbsp;Dashboard">Dashboard</a>), if your model deals with data outside of the database (e.g. processing images, talking to a third party API over HTTP, converting files, etc) or if it uses an external or third party library (e.g. in Akeeba Backup the BackupModel uses our Akeeba Engine backup engine library).</p><p>The basic service it provide is model state management using the <code class="code">getState</code>, <code class="code">setState</code> and <code class="code">populateState</code> methods.</p><div class="tip"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.svg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>In a proper MVC implementation the only way the Controller would &#8220;talk&#8221; to a Model is by setting its state and then reading either the return value of the method it called or inspecting the Model's state.</p><p>In Joomla MVC the model state is a weird beast. It is &#8216;normally&#8217; set by reading it from the session and overriding it from the request parameters using the application's <code class="code">getUserStateFromRequest</code> method.</p><p>While this is mostly okay for simple administrator pages listing and editing records you may find yourself in situations where you need to &#8220;talk&#8221; to the model from the Controller. Instead of passing this information around as HTTP GET/POST parameters &#8212; which can be inspected and <span class="emphasis"><em>overridden</em></span> by a curious or malicious user &#8212; I urge you to instead override the <code class="code">display</code> method of your Controller and set the Model's state after instantiating it. This is something you will not see anywhere in the Joomla core code but something you SHOULD be doing in your more complex components to avoid embarrassing and easily preventable security vulnerabilities.</p><p>Speaking of which, <span class="emphasis"><em>always</em></span> validate the data type and values of your model state in your code. Writing secure code requires you to adopt a &#8220;trust no-one&#8221; stance against any data which is not hard-coded into your extension's code! Do not assume that the data will be safe because (you think that) only a Super User can access a specific view. First of all, your assumption may be wrong. Moreover, your Model may be used outside the View you have in mind, even by third party components, plugins and modules integrating with your extension. Trust no-one, not even your own assumptions!</p></td></tr></table></div></dd><dt><span class="term">Joomla\CMS\MVC\Model\BaseDatabaseModel</span></dt><dd><p>This is an extension to BaseModel primarily adding database support. You can get the applicable database object with <code class="code">$this-&gt;getDbo()</code> (Joomla 4.0 or later 4.x version) or <code class="code">$this-&gt;getDatabase()</code> (Joomla 4.2 and later versions, including 5.0 and later).</p><p>Beyond that, it lets you dispatch events using the global Event Dispatcher you get with <code class="code">$this-&gt;getDispatcher()</code> (Joomla 4.2 and later), get the Joomla user object of the currently logged in user with <code class="code">$this-&gt;getCurrentUser()</code> (Joomla 4.2 and later), and get the CacheControllerFactory to talk to Joomla's cache with <code class="code">$this-&gt;getCacheControllerFactory()</code> (Joomla 4.2 and later).</p><p>This is the most used type of model super-class, either having your models directly extend it or indirectly extend it by using one of its descendant classes.</p></dd><dt><span class="term">Joomla\CMS\MVC\Model\FormModel</span></dt><dd><p>This is an extension to the BaseDatabaseModel which additionally implements Form handling.</p><div class="important"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.svg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>This IS NOT the class you want to extend in pages which edit existing or create new records! What you are looking for in this case is Joomla\CMS\MVC\Model\AdminModel (yes, even in the frontend!).</p></td></tr></table></div><p>This is the kind of Model you are going to use on pages which render a Form using an XML file for collecting information from the user BUT NOT for the purpose of editing or creating a record.</p><p>A practical example of this is the Joomla Global Configuration page's model (<code class="code">Joomla\Component\Config\Administrator\Model\ApplicationModel</code>) which does render an XML form with the Global Configuration option. Compare this to the article edit page's model (<code class="code">Joomla\Component\Content\Administrator\Model\ArticleModel</code>) and the difference becomes evident right away!</p><p>In your components you might want to use this type of Model in custom configuration pages. For example, you may have a component which post new articles automatically on social media. You may want to create different configurations for Facebook, Twitter, Reddit and whatnot. The page managing each of these configurations, each one using its own XML form file, would very likely use a Model class extending from <code class="code">FormModel</code> instead of <code class="code">AdminModel</code>.</p></dd><dt><span class="term">Joomla\CMS\MVC\Model\AdminModel</span></dt><dd><p>This is an extension to the <code class="code">FormModel</code> which is designed specifically for creating new and editing existing records.</p><p>What is the difference? Whereas <code class="code">FormModel</code> is made to deal with the collection of arbitrary data, the <code class="code">AdminModel</code> is made to create and edit records having the same data shape, defined in a database table. As a result, it works together with a <a class="link" href="ch03s13.html" title="13.&nbsp;Tables">Table object</a>. Most of its methods will be talking to the Table object.</p><p>It also supports automatic integration with content plugins and implements the methods you need to save new/existing records, reorder records, change record associations, batch process records, check-in and check-out records to the database, change the publish / trash state, and permanently delete records. Yup, this type of Model basically handles nearly everything you need to manage records in the backend of a site <span class="emphasis"><em>except</em></span> listing records.</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.svg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>I had personally found it extremely confusing that the <code class="code">AdminModel</code> (and the corresponding <code class="code">FormController</code>) is responsible for handling all the actions you see available in the toolbar of a records list page. When you think about architecture it does make sense. When you are new to Joomla you might wonder why this is not handled by <code class="code">ListModel</code> (and its corresponding <code class="code">AdminController</code>). This is unfortunately a case of &#8220;you do this just because&#8221;, not a case of using what you'd intuitively think is the right thing to use. I know, right?!</p><p>You may also get confused by the fact that an AdminController has a ListModel whereas a FormController has an AdminModel. It looks like someone had a stroke trying to name things.</p><p>Thankfully, no, nobody had a stroke &#8212; the weird naming comes from the fact that when forms were introduced in Joomla 1.6 we had to maintain backwards compatibility to Joomla 1.5, thereby causing a class naming mayhem. You know what are the two hardest things in software development? Handling dates, managing backwards compatibility and off-by-one errors!</p></td></tr></table></div></dd><dt><span class="term">Joomla\CMS\MVC\Model\ItemModel</span></dt><dd><p>This is an extension of the DatabaseModel, designed to <span class="emphasis"><em>display</em></span> a single record in the frontend.</p><p>This is something you will use probably a lot in the frontend of your application when you want to show a single record which cannot be edited. Unlike the FormModel and the AdminModel, this Model class does not have any kind of management code for the records. It just displays them and that's it.</p><div class="tip"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.svg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Practically speaking, you might just end up extending your frontend Model from your backend Model which in turn extends from Joomla's AdminModel if you need to provide any kind of frontend administration of your component. There is no point creating two models to talk to the same data, one just to show it and one just to modify it. It also makes no sense to have your frontend Model extend from AdminModel and duplicate your code (WET code) when you can simply extend your backend model and refrain from repeating yourself (DRY code).</p></td></tr></table></div></dd><dt><span class="term">Joomla\CMS\MVC\Model\ListModel</span></dt><dd><p>This class extends from the DatabaseModel and has the ability to manage forms (you need them for Search Tools a.k.a. list filters) and, crucially, to provide pagination-aware list of records from a database table.</p><p>You know how the main Joomla backend user interface pattern is a list of records? Yup, this is the Model which implements it.</p><div class="tip"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.svg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>In the frontend of your component you will very frequently find yourself needing to list a bunch of items in pagination-aware lists. The traditional Joomla code pattern was to create a frontend Model which extended from BaseDatabaseModel and have the same code to list items copied over from the backend.</p><p>Don't do that. It's WET code and I've already mentioned that it's the source of many a bug.</p><p>What you will practically find yourself doing is extending the frontend Model from the backend Model. Unlike Joomla 3, this is now possible!</p><p>You need to be acutely aware, though, that you will need to override the <code class="code">populateState</code> method in the frontend model. By default, this method will accept any kind of user input for filtering the list of records which could indeed be used by a malicious user to display items they are not supposed to access!</p><p>An even better approach is what I hinted to earlier. Override the <code class="code">display</code> method of your Controller. In there, first do a <code class="code">getState</code> on your model (to run the <code class="code">populateState</code> and be done with it), then explicitly set the Model state using its <code class="code">setState</code> method before passing it to your View object. When you do that, the state set by your Controller's code overrides whatever <code class="code">populateState</code> did, thereby mitigating any security risks.</p></td></tr></table></div></dd></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-models-interfaces-traits"></a>10.1.&nbsp;Interfaces and Traits</h3></div></div></div><p>In Joomla 3 each Model type tried to do everything under the sun and even implement features which might have nothing to do with your component, like tags and versioning.</p><p>In Joomla 4 and later versions the default Model classes don't do any of that. That's a good thing because it promotes the computer science principle called Separation of Concerns. If you need additional features you will be doing a bit of <span class="emphasis"><em>object composition</em></span>.</p><p>For those with a Computer Science background, you may wonder how you can do object composition in a language like PHP which, unlike C for example, does not allow classes to inherit (extend) from multiple classes. The answer is by using Traits provided by Joomla.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">\Joomla\CMS\Versioning\VersionableModelTrait</span></dt><dd><p>Implements support for Versions (record history).</p><p>Only applicable to models extending from <code class="code">AdminModel</code>. This requires the <span class="guilabel">Behaviour - Versionable</span> plugin to be published. The corresponding Table must implement the <code class="code">\Joomla\CMS\Versioning\VersionableTableInterface</code> interface and the corresponding Controller must use the <code class="code">\Joomla\CMS\Versioning\VersionableControllerTrait</code> trait.</p></dd><dt><span class="term">\Joomla\CMS\MVC\Model\WorkflowBehaviorTrait</span></dt><dd><p>Implements support for Workflows (prescribed steps for state changes in records).</p><p>Only applicable to models extending from <code class="code">AdminModel</code>. The model must implement the <code class="code">\Joomla\CMS\MVC\Model\WorkflowModelInterface</code> interface.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-models-push-service-joomla"></a>10.2.&nbsp;Pushing services to the Model: the Joomla Way</h3></div></div></div><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.svg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>This way only applies to Joomla 4.3 and later. If you want your component to support earlier Joomla versions you will have to use the alternative method outlined towards the end of this section.</p></td></tr></table></div><p>TODO &#8212; This section is pending the submission and acceptance of a Pull Request to the Joomla Project.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-models-push-service-alt"></a>10.3.&nbsp;Pushing services to the Model: an alternative</h3></div></div></div><p>While Joomla 4.3 and later allows you to push services into the Model using an MVCFactory wrapper which extends the MVC service, necessary parts of this architecture did not exist in previous Joomla versions. We will have to use a slightly less &#8220;architecturally clean&#8221; solution.</p><p>We will <span class="bold"><strong>pull</strong></span> the custom service <span class="bold"><strong>from</strong></span> the component's DIC.</p><p>First, you need to make sure that you register a service provider in <a class="link" href="ch03s05.html" title="5.&nbsp;Service provider">your component's service provider</a> implementation:</p><pre class="programlisting">$container-&gt;set(
    \Acme\Example\Administrator\Service\FacebookPublish::class,
    function (Container $container) {
        return new \Acme\Example\Administrator\Service\FacebookPublish();
    }
);</pre><p>Then, you need to modify your <a class="link" href="ch03s06.html" title="6.&nbsp;Extension class">component's extension class section</a> as we saw on that section's &#8220;Getting access to the component's DIC anytime, anywhere&#8221; to be able to statically return the component's DI Container anytime, anywhere:</p><pre class="programlisting">	protected static $dic;

	public function boot(ContainerInterface $container)
	{
		self::$dic = $container;
	}
	
	public static function getContainer()
	{
		if (empty(self::$dic))
		{
			Factory::getApplication()
			       -&gt;bootComponent('com_example');
		}
		
		return self::$dic;
	}</pre><p>Now your Model can simply pull the service from the Component's DIC in its constructor:</p><pre class="programlisting">&lt;?php

namespace Acme\Example\Administrator\Model;

use Acme\Example\Administrator\Extension\ExampleComponent;
use Acme\Example\Administrator\Service\FacebookPublish;
use Joomla\CMS\Form\FormFactoryInterface;
use Joomla\CMS\MVC\Factory\MVCFactoryInterface;
use Joomla\CMS\MVC\Model\AdminModel;

class ItemModel extends AdminModel
{
	private $fbPublish;

	public function __construct($config = [], MVCFactoryInterface $factory = null,
								FormFactoryInterface $formFactory = null)
	{
		parent::__construct($config, $factory, $formFactory);

		$exampleDIC      = ExampleComponent::getContainer();
		$this-&gt;fbPublish = $exampleDIC-&gt;get(FacebookPublish::class);
	}

	protected function getFacebookPublish(): FacebookPublish
	{
		return $this-&gt;fbPublish;
	}

	// The rest of your model's code goes here&#8230;
}</pre><p>For completeness' sake, here are there are two (minor) downsides to this approach:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The Model now has a direct hard dependency on the component's extension class. For real world use inside Joomla this is not a big deal; the only recommended way to create instances of a component's Models is through its MVCFactory object which necessarily goes through the component's extension object. If you are writing Unit Tests, though, you can no longer isolate the Model. You will need to inject a dependency injection container with your custom service in the component's extension class.</p></li><li class="listitem"><p>The extension class has a static method to fetch the DIC. If this is not already set up it will try to go through the global application object to boot the component. If you are writing Unit Tests this is a problem, hence why I said that you need to inject a DIC to your component's extension class.</p></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s09.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch03.html"><img src="images/up.svg" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch03s11.html"><img src="images/next.svg" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">9.&nbsp;The MVCFactory&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.svg" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;11.&nbsp;Controllers</td></tr></table></div></body></html>