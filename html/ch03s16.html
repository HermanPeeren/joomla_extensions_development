<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>16.&nbsp;Router</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Joomla Extensions Development"><link rel="up" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Components"><link rel="prev" href="ch03s15.html" title="15.&nbsp;Categories"><link rel="next" href="ch03s17.html" title="17.&nbsp;Dashboard"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">16.&nbsp;Router</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s15.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;3.&nbsp;Components</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch03s17.html"><img src="images/next.svg" alt="Next"></a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="com-router"></a>16.&nbsp;Router</h2></div></div></div><p>Most components have a backend and a frontend part. The backend part is used by the site administrators to set up the content being managed by the component and the frontend part is used to display said content to the visitors of the site.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-router-routing-overview"></a>16.1.&nbsp;The case for URL routing</h3></div></div></div><p>By default, Joomla's frontend URLs look something like this:</p><p><code class="uri">https://www.example.com/index.php?option=com_example&amp;view=item&amp;id=123&amp;Itemid=456</code></p><p>This is called a regular or non-SEF URL. The SEF URL &#8212; what other CMS may call a &#8220;permalink&#8221; or a &#8220;<span class="emphasis"><em>route</em></span>&#8221; &#8212; could be something like</p><p><code class="uri">https://www.example.com/acme-shop/roadrunner-hunting/explosives/tnt-crate.html</code></p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.svg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><acronym class="acronym">SEF</acronym> is an acronym which stands for Search Engine Friendly and is called like that for historical reasons &#8212; back in 2001 when Joomla's predecessor, Mambo, introduced this feature a human-understandable URL was also helping the primitive search engines of that era to get better context of what the page is about. This stopped being true by the time Joomla emerged as its own software, in 2005.</p><p>Joomla co-founder Brian Teeman coined a better, if not much more British, term: Pub Ear Friendly. The idea being that when you try to give the URL of a page to your mate while downing pints at your local, rather lively, local it's easier to give them a few words they can understand than a long string of alphanumeric characters. For some reason this alternate term never stuck&#8230;</p></td></tr></table></div><p>The transformation of the ugly, incomprehensible (at least to non-developers), non-SEF URL into the SEF URL and of the SEF URL back to the ugly non-SEF version (so Joomla can figure out which component to load and what to tell it to do) is called <span class="bold"><strong>SEF routing</strong></span> in the Joomla vernacular. Most everywhere else you will see it being called <span class="bold"><strong>URL routing</strong></span>. Well, the Joomla vernacular is full of certain historical quirks which makes it harder for newcomers to figure out what is what, but this is neither here nor there.</p><p>URL routing in Joomla is implemented in the core. However, the core code cannot <span class="emphasis"><em>possibly</em></span> know how your component is supposed to logically structure its content so as to convert this into a human and machine understandable URL. Therefore it delegates that responsibility to the component, namely to our component's Router.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-router-abandon-all-hope"></a>16.2.&nbsp;Intermission: abandon all hope ye who enter here</h3></div></div></div><p>Before we go on, let's discuss a little bit how Joomla URL routing works. It's long, it's a bit depressing, but read to the end &#8212; as you'll see, all problems with the URL routing in Joomla are ultimately <span class="bold"><strong>a user education issue</strong></span>, not a coding issue.</p><p>You would expect web software to have have absolutely deterministic, clear routing for URLs. Given a set of URL parameters (the &#8220;non-SEF URL&#8221;) the URL router (&#8220;SEF router&#8221;) will spit out the same route (&#8220;SEF URL&#8221;). In this ideal world we already have nuclear fusion and world peace, we have solved poverty and hunger and&#8230; I digress.</p><p>In the imperfect world we live in, web software has to choose one of two evils. URL routing is either extremely technical and inflexible but robust, or it is is user-friendly and flexible but can result in some very weird situations. Joomla chose the latter. It's what allows modules to work the way they do which is one of the many reasons Joomla is an insanely powerful but still user-friendly CMS. But which part of its soul did it have to sell to you-know-who to do that? Let's see&#8230;</p><p>URL routing in Joomla operates in two axes. On one hand we have the user-defined menu structure which operates as the first pass of URL routing and is defined by users, who are humans and not very good at managing hierarchies (make that <span class="emphasis"><em>doubleplusungood</em></span>, Winston). Then you have the SEF router of our component which, unlike users, works in a perfectly logical, orderly fashion.</p><p>The thing is, they are both working at the same time to do URL routing and this can cause some&#8230; uh&#8230; <span class="emphasis"><em>complications</em></span>.</p><p>Let's say you have the following data hierarchy:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Category A, alias <code class="code">alpha</code>.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Category B, alias <code class="code">bravo</code>.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>Article C, alias <code class="code">charlie</code></p></li></ul></div></li></ul></div></li></ul></div><p>And you have the following menu structure (as to why the user chose this seemingly bonkers menu structure, no, they are not trying to sabotage your code, they have a good reason but we'll get back to that later):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Category item list for Category B, alias <code class="code">bravo</code>. Item ID 123.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Single article view for Article C, alias <code class="code">charlie</code>. Item ID 234.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>Category A, alias <code class="code">alpha</code>. Item ID 345.</p></li></ul></div></li></ul></div></li></ul></div><p>You would expect that the URL for category A is https://www.example.com/alpha, category B's is https://www.example.com/alpha/bravo and article C's is https://www.example.com/alpha/bravo/charlie.</p><p>Nope.</p><p>The URL for category A is <code class="uri">https://www.example.com/bravo/charlie/alpha</code> per the menu structure.</p><p>The URL for category B is <code class="uri">https://www.example.com/bravo</code> per the menu structure.</p><p>The URL for article C is <code class="uri">https://www.example.com/bravo/charlie</code> per BOTH the menu structure AND the SEF router of com_content.</p><p>However, it's perfectly possible to access article C as https://www.example.com/bravo/charlie/alpha/charlie. The first three parts of the route (/bravo/charlie/alpha) are the menu structure to category A. The rest (bravo/charlie) is handled by the SEF router of com_content.</p><p>*record scratch*</p><p>But, wait, wait a second! How does Joomla know when to use each URL?! I am glad you asked, the answer is the <code class="code">Itemid</code> URL parameter, i.e. the menu item ID for which we are going to be generating a URL for our&#8230; something!</p><p>If we are routing the URL to article C using a URL with Itemid=123 Joomla will first figure out that we have a menu item to Article C's parent category (Category B). It will then ask our URL router to route this item in this category which will make our com_content router return <code class="code">charlie</code>. Therefore Joomla will return the relative URL <code class="code">bravo/charlie</code>.</p><p>If we are routing the URL to article C using a URL with Itemid=234 Joomla sees that the Itemid matches exactly what we need to route, therefore it will return the menu structure up to this point, i.e. the relative URL <code class="code">bravo/charlie</code>.</p><p>HOLD ON A SECOND! Both of these methods returned&#8230; THE SAME URL! Ah, keen eyed reader, you are right! I can see you despairing. Oh, please, not yet! It's about to get <span class="emphasis"><em>worse</em></span>. You see, when Joomla parses the URL it prioritises the menu structure over the SEF router of each component. Since <code class="code">bravo/charlie</code> is, indeed, a valid menu structure it will simply return the non-SEF URL index.php?Itemid=234 &#8212; in both cases.</p><p>But, but, but&#8230; Isn't the Itemid how we tell modules when to display? Why, yes, it is! Oh, you had different modules displaying in menu items 123 and 234? Too bad! You don't get to choose. Sorry.</p><p>Back to routing non-SEF to SEF URLs. If you route article C using a URL with Itemid=345 Joomla tells you that you are on category A. So your SEF route has to find a full path to your article which would be bravo/charlie and this is added to Category A, menu item 345's URL of bravo/charlie/alpha to make the entirely confusing URL bravo/charlie/alpha/bravo/charlie which works perfectly.</p><p>What about trying to route article C without an Itemid? Now things get a bit tastier and testier. Joomla will try to find the most relevant route using the segments returned by your SEF router and trying to match them with the menu structure&#8230; Which one it is? Frankly, I don't have the foggiest off the top of my head. I'd have to build that site to figure it out. I would think it's the same as using Itemid=345. If all else fails, Joomla will use the Home item's Itemid and all bets are off.</p><p>Of course, this means that the same article can have three URLs, two of which are identical and one of them does not resolve to what you'd expect. But this is normal! And no, forget about getting a canonical URL for article C because there's none.</p><p>This insanity cannot be addressed because it would require decoupling URL routing from Joomla's menu system. However, this would mean that all published modules appear in all pages as there is no longer a way to know which menu item you're in. Of course it's the solution to this problem which broke module display in our example above but this is what you get when the users are &#8220;crazy&#8221;.</p><p>Or are they?</p><p>While it sounds convoluted and problematic, this method is not the least bit more convoluted and problematic than any other given CMS <span class="emphasis"><em>when you take into account all the possible<a href="#ftn.d0e4452" class="footnote" name="d0e4452"><sup class="footnote">[1]</sup></a>, almost infinite use cases it's called to work with</em></span>. It works great insofar the user can be trusted to not create psychopathic menu structures which work against the data structure, reusing the same aliases for a good measure of insanity.</p><p>But why would any user even create such a menu structure to begin with?!</p><p>As a matter of fact, the menu structure I presented <span class="bold"><strong>is the wrong way to use Joomla</strong></span>. I confess I misdirected you but I did so for a noble reason. What the user most likely wanted was the menu item's <span class="emphasis"><em>visual</em></span> structure to be what we presented for user experience reasons. They most likely don't care or not even <span class="emphasis"><em>want</em></span> the crazy URL structure. They would very likely be spending hundreds of Euros every year in various SEF / SEO tools to try and fix their mistake&#8230; when they could just be told how to use Joomla the way Joomla was intended to be used to begin with.</p><p>The One True Joomla Way&#8482; is to use a &#8220;hidden&#8221; menu (a menu without a module to display it) to generate the URL structure in a way that's mostly following the data structure and a shown menu with Alias menu items for the visual display.</p><p>So, in our example, the hidden menu would be:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Category A, alias <code class="code">alpha</code>. Item ID 345.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Category item list for Category B, alias <code class="code">bravo</code>. Item ID 123.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>Single article view for Article C, alias <code class="code">charlie</code>. Item ID 234.</p></li></ul></div></li></ul></div></li></ul></div><p>And the visible menu:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Category item list for Category B, alias to menu item 123.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Single article view for Article C, alias to menu item 234.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>Category A, alias <code class="code">alpha</code>, alias to menu item 345.</p></li></ul></div></li></ul></div></li></ul></div><p>That's the reason I went through this intentionally provocatively named section. When you are doing end user support you <span class="bold"><strong>WILL</strong></span> come up with the atrocious menu structures like the one I presented above.</p><p>Do NOT try to address this in your router code; you will lose your mind and you will never make it work for all of your users. Remember, there is no routing method which is suitable for every use case and you cannot possibly address infinite use cases. Value your sanity as a developer! Learn when to say &#8220;no&#8221; to users.</p><p>Instead, ask your user what is their <span class="emphasis"><em>use case</em></span> and is <span class="emphasis"><em>their intention</em></span> with their menu structure: are they trying to shape the URL structure or just the way things are presented on their site? In 99 out of 100 cases the user intended to affect only the visual presentation of the menu; they have no idea they are shooting their feet by affecting the URL structure. Patiently explain them the trick about hidden menus. You'll get grateful clients for life.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-router-j3-vs-j4"></a>16.3.&nbsp;Joomla 3 vs Joomla 4</h3></div></div></div><p>In Joomla 3 we would create a router as a <code class="filename">router.php</code> file in the root of our component's frontend, e.g. <code class="filename">components/com_example/router.php</code>. That file had two way to implement a router:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Two separate functions whose names consisted of the name of the component without the <code class="code">com_</code> prefix and the suffixes <code class="code">BuildRoute</code> and <code class="code">ParseRoute</code>, e.g. <code class="function">exampleBuildRoute</code> and <code class="function">exampleParseRoute</code>. This was the very old way which was deprecated since Joomla 3.3 released in 2014.</p></li><li class="listitem"><p>As a class extending <code class="classname">JComponentRouterBase</code> (renamed to <code class="classname">Joomla\CMS\Component\Router\RouterBase</code> in later Joomla versions) or, more usually, <code class="classname">JComponentRouterView</code> (introduced in Joomla 3.5 and renamed to <code class="classname">Joomla\CMS\Component\Router\RouterView</code> in later Joomla versions).</p></li></ul></div><p>If you are using the former method you have a lot of work ahead of you to convert it to a Joomla 4 compatible router. If you are using the latter method you are virtually ready, with minimal changes!</p><p>In Joomla 4 the router is implemented as the class <code class="code">Service\Router</code> in the frontend part of our component. So, with a component <code class="code">com_example</code> that has a namespace prefix <code class="code">Acme\Example</code> that would be the class <code class="classname">Acme\Example\Site\Service\Router</code> in the file <code class="filename">components/com_example/src/Service/Router.php</code>. That class needs to extend from <code class="classname">Joomla\CMS\Component\Router\RouterBase</code> or, more typically <code class="classname">Joomla\CMS\Component\Router\RouterView</code>, just like in Joomla 3.5<a href="#ftn.d0e4597" class="footnote" name="d0e4597"><sup class="footnote">[2]</sup></a> and later versions.</p><p>There is one more difference in Joomla 4 and later versions. By default, the component does not know that it needs to use a router.</p><p>To understand what and why we need to do, let's go backwards. Joomla only knows it needs to use a router factory when the component's extension class implements the <code class="interfacename">\Joomla\CMS\Component\Router\RouterServiceInterface</code>. When this is the case, Joomla knows that it can ask the extension class to return a Router Factory object using the <code class="methodname">createRouter</code> method defined in said interface. The component's extension class does not know how to find the router factory object; it is injected into it by the component service provider (<code class="filename">services/provider.php</code>). In its turn, it asks the component's DI Container for that Router Factory object. The DI Container will only know how to get a Router Factory object is we register a Router Factory service provider in the service provider (<code class="filename">services/provider.php</code>).</p><p>Unraveling these chained dependencies we see that we need to make changes in just two files.</p><p>Your component's extension class must implement the <code class="interfacename">\Joomla\CMS\Component\Router\RouterServiceInterface</code> interface. The easiest way to provide its implementation is having it use the <code class="classname">\Joomla\CMS\Component\Router\RouterServiceTrait</code> trait.</p><p>That trait requires your component service provider (e.g. <code class="filename">administrator/components/com_example/services/provider.php</code>) to do two things. First, it needs to register a Router Factory service provider before trying to create the component object:</p><pre class="programlisting">$container-&gt;registerServiceProvider(
  new \Joomla\CMS\Extension\Service\Provider\RouterFactory
  (
    '\\Acme\\Example'
  )
);</pre><p>The <code class="classname">\Joomla\CMS\Extension\Service\Provider\RouterFactory</code> class is the default Joomla implementation of a component router factory. It needs exactly one configuration parameter in its constructor, the namespace of your component <span class="emphasis"><em>without</em></span> the <code class="code">Site</code> or <code class="code">Administrator</code> suffix.</p><p>Then, after having created our component extension class' object, we need to inject the Router Factory object into it:</p><pre class="programlisting">$container-&gt;set(
  ComponentInterface::class,
  function (Container $container) {
    $component = new ExampleComponent(
      $container-&gt;get(ComponentDispatcherFactoryInterface::class)
    );

    // ... other initialisation goes here ...

    // Inject the router factory object
    <span class="bold"><strong>$component-&gt;setRouterFactory(
      $container-&gt;get(
         \Joomla\CMS\Component\Router\RouterFactoryInterface::class
      )
    );</strong></span>
   }
);</pre><p>While it looks a bit verbose, it accomplishes two things. First, it's not possible to be surprised by Joomla magically implementing a feature in your component you did not expect. Second, in the case of a router, it allows us to <a class="link" href="ch03s16.html#com-router-push-dependencies" title="16.5.&nbsp;Pushing dependencies to the Router">push dependencies (services) into our router object</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-router-routerview"></a>16.4.&nbsp;Using RouterView</h3></div></div></div><p>If you are using a router class extending from <code class="classname">Joomla\CMS\Component\Router\RouterView</code> it is fairly easy to create a router for most components.</p><p>The constructor of your class tells Joomla which views of your component can be routed in the frontend and the relation to each other. For example:</p><pre class="programlisting">public function __construct(SiteApplication $app = null, AbstractMenu $menu = null)
{
  $welcome = new \Joomla\CMS\Component\Router\RouterViewConfiguration('welcome');
  $this-&gt;registerView($welcome);

  $item = (new \Joomla\CMS\Component\Router\RouterViewConfiguration('item'))
    -&gt;setKey('id')
    -&gt;addLayout('default')
    -&gt;addLayout('fancy');
  $this-&gt;registerView($item);

  $detail = (new \Joomla\CMS\Component\Router\RouterViewConfiguration('detail'))
    -&gt;setKey('id')
    -&gt;setParent($item, 'itemid');
  $this-&gt;registerView($detail);

  parent::__construct($app, $menu);

  $this-&gt;attachRule(new \Joomla\CMS\Component\Router\Rules\MenuRules($this));
  $this-&gt;attachRule(new \Joomla\CMS\Component\Router\Rules\StandardRules($this));
  $this-&gt;attachRule(new \Joomla\CMS\Component\Router\Rules\NomenuRules($this));
}</pre><p>This tells Joomla that we have three routable views called <code class="code">welcome</code>, <code class="code">item</code> and <code class="code">detail</code>. The <code class="code">detail</code> view is a child of <code class="code">item</code>.</p><p>How would Joomla know about which detail is under a specific item? We told it that the <code class="code">detail</code>'s <code class="code">itemid</code> property must match the key of the <code class="code">item</code> and the key of the <code class="code">item</code> is called <code class="code">id</code>.</p><p>The last three lines tell Joomla which routing rules to register:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="classname">MenuRules</code>. Tries to detect the correct Itemid for a view if none was provided in the non-SEF URL. You should keep that unless you want to implement the <code class="methodname">preprocess</code> method yourself.</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.svg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The <code class="methodname">preprocess</code> method is called before the SEF URL is built and, crucially, before Joomla tries to figure out the <code class="code">format</code> and <code class="code">Itemid</code> URL parameters to send to your component's Router's build method.</p><p>In Joomla 3 you could get away with trying to figure out and change the <code class="code">format</code> and <code class="code">Itemid</code> parameters in your router's <code class="methodname">build</code> method. While this was necessary for compatibility with legacy <code class="filename">router.php</code> files (those using the two distinct functions), <span class="emphasis"><em>this &#8220;hack&#8221; will no longer work in Joomla 4</em></span>. You must move that code into the <code class="methodname">preprocess</code> method. If you fail to do so, your SEF URLs will not work properly; from your perspective, it will be as if your <code class="code">format</code> and <code class="code">Itemid</code> values overridden in the built method were never taken into account. That's <span class="emphasis"><em>exactly</em></span> what happens.</p><p>This is actually a good change. It makes the core routing code more efficient and keeps us third party developers in the habit of applying separation of concerns in our code.</p></td></tr></table></div></li><li class="listitem"><p><code class="classname">StandardRules</code>. Standard non-SEF to SEF URL (and vice-versa) routing. If you omit this you will not get any SEF URL routing which beats the purpose of having a router.</p></li><li class="listitem"><p><code class="classname">NomenuRules</code>. Process URLs when no Itemid exists for the component. This is necessary to route URLs when no published menu items exist for your component and Joomla needs to create or parse URLs in the format <code class="uri">/component/example/foo/bar.html</code>.</p></li></ul></div><p>At this point Joomla knows the logical hierarchy of our component's views but it does not know how to convert an id in the non-SEF URL to a SEF URL segment when building the SEF URL (e.g. convert an item ID to its alias) or how to convert a SEF URL segment back to a non-SEF URL's numeric ID when it's parsing the SEF URL (e.g. convert an item alias to its ID). This is up to us.</p><p>We need to provide two methods for each <code class="classname">RouterViewConfiguration</code> objects we created: <code class="methodname">get<em class="replaceable"><code>Something</code></em>Segment</code> and <code class="methodname">get<em class="replaceable"><code>Something</code></em>Id</code> where <em class="replaceable"><code>Something</code></em> is the name of the view with its first letter capitalised. Here's what the code for the Item view would look like in our example:</p><pre class="programlisting">public function getItemId(string $segment, array $query): bool|int
{
  $db = \Joomla\CMS\Factory::getContainer()-&gt;get('DatabaseDriver');
  $dbQuery = $db-&gt;getQuery(true)
    -&gt;select($db-&gt;quoteName('id'))
    -&gt;from($db-&gt;quoteName('#__example_items'))
    -&gt;where($db-&gt;quoteName('alias') . ' = :alias')
    -&gt;bind(':alias', $segment);

  return  $db-&gt;setQuery($dbQuery)-&gt;loadResult() ?: false;
}

public function getItemSegment(int $id, array $query): array
{
  $db = \Joomla\CMS\Factory::getContainer()-&gt;get('DatabaseDriver');
  $dbQuery = $db-&gt;getQuery(true)
    -&gt;select($db-&gt;quoteName('alias'))
    -&gt;from($db-&gt;quoteName('#__example_items'))
    -&gt;where($db-&gt;quoteName('id') . ' = :id')
    -&gt;bind(':id', $id);
  
  $segment = $db-&gt;setQuery($dbQuery)-&gt;loadResult() ?: null;

  if ($segment === null) {
    return [];
  }

  return [$segment];
}</pre><p>There is something worth noting here. The <code class="methodname">get<em class="replaceable"><code>Something</code></em>Segment</code> method can return an array with more than one segments. This is useful if you want to somehow return a more complex structure e.g. <code class="uri">item/foo/detail/bar</code> where <code class="code">item</code> and <code class="code">detail</code> are fixed strings. However, if you do that, you will need to override the <code class="methodname">parse</code> method to handle multi-segment views. The default implementation in <code class="classname">StandardRules</code> assumes that you are using exactly one segment per view and that's why <code class="methodname">get<em class="replaceable"><code>Something</code></em>Id</code> accepts a string, not an array, as its first argument.</p><p>You may wonder, what about our <code class="code">welcome</code> view? Don't we need to create methods for it? No, we don't. Views which do not have a key set for them use the name of the view as the (only) segment for SEF URLs. If there is a naming clash between such a view and an alias of a top-level view (or category, as we will see below) the first <code class="classname">RouterViewConfiguration</code> object registered &#8220;wins&#8221; in determining how that segment should be parsed. As a result, you should keep this kind of top-level views to a minimum and either inform users that they cannot use these aliases or actively prevent them with validation rules whenever possible.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-router-push-dependencies"></a>16.5.&nbsp;Pushing dependencies to the Router</h3></div></div></div><p>You may have noticed that in the sample code above I got the database driver object using the <code class="methodname">Factory::getContainer</code> static method. This is not ideal. It's even worse if I'd need to get access to MVC objects such as Models and Tables &#8212; having to boot the entire component just to get its MVCFactory is something to use only if there is no other way, not something to do by default.</p><p>Fortunately, Joomla gives us the option to push any services we need &#8212; such as the database driver object and the component's MVCFactory &#8212; into the router. Unfortunately, it's a bit non-obvious.</p><p>To inject services into the Router service object they need to be injected into the object after it is created by the Router Factory object. The Router Factory object needs to have access to these services to inject them. This means injecting these services to the Router Factory object from the Router Factory Service Provider. The Router Factory Service Provider can get any of the dependencies (services) it needs since it has access to the component's service provider.</p><p>Therefore we need to create the two missing pieces of the puzzle (Router Factory and its service provider) and register the latter with our component's service provider.</p><div class="important"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.svg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The component's service provider (<code class="filename">services/provider.php</code>) lives in the backend portion of your component. Therefore. it makes sense that the Router Factory and the Router Factory Service Provider also live in the backend of your component <span class="emphasis"><em>even though the Router is only used in the frontend of the site</em></span>.</p><p>Yup. It sounds backwards. You can definitely create them in the frontend but, if you do, <span class="emphasis"><em>you</em></span> and everyone else reading your code might get confused. Don't over-think it, just do what I tell you to do. There's method in this madness, I promise.</p></td></tr></table></div><p>First, let's make our router MVCFactory-aware (it's already database-aware).</p><pre class="programlisting">&lt;?php
namespace Acme\Example\Site\Service;

use Joomla\CMS\Component\Router\RouterView;
use Joomla\CMS\MVC\Factory\MVCFactoryAwareTrait;

class Router extends RouterView
{<span class="bold"><strong>
	use MVCFactoryAwareTrait;
</strong></span>	
	// ... the rest of the router implementation goes here ...
}</pre><p>Now, let's create a Router Factory (<code class="classname">\Acme\Example\Administrator\Service\RouterFactory</code>). The default Joomla implementation is already database-aware. I am just extending it to also know about the MVCFactory so we can inject it to our router.</p><pre class="programlisting">&lt;?php
namespace Acme\Example\Administrator\Service;

use Joomla\CMS\Application\CMSApplicationInterface;
use Joomla\CMS\Component\Router\RouterInterface;
use Joomla\CMS\Menu\AbstractMenu;
use Joomla\CMS\MVC\Factory\MVCFactoryAwareTrait;

class RouterFactory extends \Joomla\CMS\Component\Router\RouterFactory
{
	use MVCFactoryAwareTrait;

	public function createRouter(CMSApplicationInterface $application, AbstractMenu $menu): RouterInterface
	{
		$router = parent::createRouter($application, $menu);

		$router-&gt;setMVCFactory($this-&gt;getMVCFactory());

		return $router;
	}
}</pre><p>Now, we need to create a RouterFactory service provider. Unfortunately, Joomla has a bad habit of registering factory objects in the DI container even though they are only going to return exactly one object with no initialisation, like a router. This complicates thing because we cannot extend the DI container definition. We have to do something stupid: copy Joomla's default implementation of the Router Factory Service Provider just so we can change the returned object type and register dependencies on it. Well... I guess it could be worse?</p><p>Anyway. Let's create our router factory service provider <code class="classname">\Acme\Example\Administrator\Service\Provider\RouterFactoryProvider</code>.</p><pre class="programlisting">&lt;?php

namespace \Acme\Example\Administrator\Service\Provider;

<span class="bold"><strong>use Acme\Example\Administrator\Service\RouterFactory;</strong></span>
use Joomla\CMS\Categories\CategoryFactoryInterface;
use Joomla\CMS\Component\Router\RouterFactoryInterface;
use Joomla\CMS\MVC\Factory\MVCFactoryInterface;
use Joomla\Database\DatabaseInterface;
use Joomla\DI\Container;
use Joomla\DI\ServiceProviderInterface;

class RouterFactoryProvider implements ServiceProviderInterface
{
/**
	 * The module namespace
	 *
	 * @since   4.0.0
	 * @var  string
	 *
	 */
	private $namespace;

	/**
	 * DispatcherFactory constructor.
	 *
	 * @param   string  $namespace  The namespace
	 *
	 * @since   4.0.0
	 */
	public function __construct(string $namespace)
	{
		$this-&gt;namespace = $namespace;
	}

	/**
	 * Registers the service provider with a DI container.
	 *
	 * @param   Container  $container  The DI container.
	 *
	 * @return  void
	 *
	 * @since   4.0.0
	 */
	public function register(Container $container)
	{
		$container-&gt;set(
			RouterFactoryInterface::class,
			function (Container $container) {
				$categoryFactory = null;

				if ($container-&gt;has(CategoryFactoryInterface::class))
				{
					$categoryFactory = $container-&gt;get(CategoryFactoryInterface::class);
				}

				$routerFactory = new <span class="bold"><strong>RouterFactory</strong></span>(
					$this-&gt;namespace,
					$categoryFactory,
					$container-&gt;get(DatabaseInterface::class)
				);

				<span class="bold"><strong>$routerFactory-&gt;setMVCFactory($container-&gt;get(MVCFactoryInterface::class));</strong></span>

				return $routerFactory;
			}
		);
	}
}
</pre><p>Our changes to the core code in Joomla are highlighted in bold type.</p><p>Finally, we need to register this router factory service provider in our component's <code class="code">services/provider.php</code> file.</p><pre class="programlisting">$container-&gt;registerServiceProvider(
  new \Acme\Example\Administrator\Service\Provider\RouterFactoryProvider(
    '\\Acme\\Example'
  )
);</pre></div><div class="footnotes"><br><hr class="footnote-hr"><div id="ftn.d0e4452" class="footnote"><p><a href="#d0e4452" class="para"><sup class="para">[1] </sup></a>For any given, singular use case and a set of routing algorithms it is very easy to find the one algorithm which is most suitable, meaning the rest are unsuitable. However, every single use case has a different most suitable algorithm. Given a very large number of use cases, like the near infinite uses cases a CMS is called to address, any given routing algorithm would be just as unsuitable for most use cases as every other. Therefore the task of finding the &#8220;best&#8221; algorithm is reduced to finding an algorithm which fulfils some secondary or tertiary business goals such as making it possible for an end user to easily configure with a GUI or support our vision of having different modules show up in each page. The primary business goal of the &#8220;best&#8221; routing for the generic use case is, by definition, a bust unless we are willing to drastically reduce the use cases we are willing to support.</p></div><div id="ftn.d0e4597" class="footnote"><p><a href="#d0e4597" class="para"><sup class="para">[2] </sup></a>The entire concept of routing using the RouterView has not changed since Joomla 3.5 which was released in 2016. You see, at this point in time development of Joomla 4 had already started and Joomla introduced the new routing to help developers migrate their extensions to the new router before Joomla 4 is released.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s15.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch03.html"><img src="images/up.svg" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch03s17.html"><img src="images/next.svg" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">15.&nbsp;Categories&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.svg" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;17.&nbsp;Dashboard</td></tr></table></div></body></html>