<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>6.&nbsp;Extension class</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Joomla Extensions Development"><link rel="up" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Components"><link rel="prev" href="ch03s05.html" title="5.&nbsp;Service provider"><link rel="next" href="ch03s07.html" title="7.&nbsp;Dispatcher"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">6.&nbsp;Extension class</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s05.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;3.&nbsp;Components</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch03s07.html"><img src="images/next.svg" alt="Next"></a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="com-extension"></a>6.&nbsp;Extension class</h2></div></div></div><p>As we saw earlier in <a class="link" href="ch03s03.html" title="3.&nbsp;The lifetime of a component">the lifetime of a component</a>, the Extension class of a component is <span class="emphasis"><em>sort of</em></span> a service locator for our component. Joomla checks if that objects implements a PHP Interface it knows about and uses the service communicated via the Interface implementation (typically one of the corresponding PHP Traits provided by Joomla) to do something useful, e.g. register an HTMLHelper helper, integrate with Tags, create SEF URLs by using a Router and so on and so forth.</p><p>If your component does not make use of any of these features you do not need to create a custom extension class for your component. Joomla gives you the perfectly serviceable <code class="code">Joomla\CMS\Extension\MVCComponent</code> class which implements a minimal Joomla 4 component: it can run because it returns a Dispatcher and it can create MVC objects using the Joomla 4 MVC because it returns an MVCFactory object. This is enough for a component which only runs in the backend or runs in both the frontend and the backend but has no way of letting Joomla create SEF URLs for it. You may think this is useless but I'd contest you're not thinking simple enough. Case in point, some core Joomla components doing exactly that. For example the <code class="code">com_actionlogs</code> component which only has a backend user interface.</p><p>That said, there wouldn't be much to write if all or even most components didn't need a custom extension class. You see, most components need one or more of the following features. I am documenting the features I discovered that need customisations in the extension class and give you an overview of the required changes in your component's code to make them work.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Use a custom <a class="link" href="ch03s14.html" title="14.&nbsp;HTML helper service">HTML Helper</a>.</p><p>Your extension class must implement the <code class="code">Joomla\CMS\HTML\HTMLRegistryAwareTrait</code> and use the <code class="code">Joomla\CMS\HTML\HTMLRegistryAwareTrait</code>. The extension class must override the <code class="code">boot</code> method and have a line similar to <code class="code">$this-&gt;getRegistry()-&gt;register('something', new MyHTMLHelper())</code>. We'll see what that means in the section covering the HTML helper.</p></li><li class="listitem"><p>Use <a class="link" href="ch03s15.html" title="15.&nbsp;Categories">core categories</a>.</p><p>Your extension class must implement the <code class="code">Joomla\CMS\Categories\CategoryServiceInterface</code> and use the <code class="code">Joomla\CMS\Categories\CategoryServiceTrait</code>. Your service provider (<code class="filename">provider.php</code>) needs to register a <code class="code">Joomla\CMS\Extension\Service\Provider\CategoryFactory</code> service provider and use the extension object's <code class="code">setCategoryFactory</code> method to pass this factory to the extension object. The extension class must override the <code class="code">getTableNameForSection</code> and <code class="code">getStateColumnForSection</code> methods defined in the aforementioned trait and interface.</p></li><li class="listitem"><p>Integrate with Joomla's Tags feature.</p><p>Your extension class must implement the <code class="code">Joomla\CMS\Tag\TagServiceInterface</code> and use the <code class="code">Joomla\CMS\Tag\TagServiceTrait</code>. The extension class must override the <code class="code">getTableNameForSection</code> and <code class="code">getStateColumnForSection</code> methods defined in the aforementioned trait and interface.</p></li><li class="listitem"><p>Integrate with <a class="link" href="ch03s26.html" title="26.&nbsp;Custom fields">Joomla's Custom Fields feature</a>.</p><p>Your extension class must implement the <code class="code">Joomla\CMS\Fields\FieldsServiceInterface</code>. The extension class must implement the <code class="code">validateSection</code> and <code class="code">getContext</code> methods defined in the aforementioned interface.</p></li><li class="listitem"><p>Provide a <a class="link" href="ch03s16.html" title="16.&nbsp;Router">Router</a> for meaningful, human-readable SEF URLs in the frontend.</p><p>Your component must have a class implementing the <code class="code">Joomla\CMS\Component\Router\RouterFactoryInterface</code> (Router factory) and a class implementing the <code class="code">Joomla\DI\ServiceProviderInterface</code> (Router factory provider). Your extension class must implement the <code class="code">Joomla\CMS\Component\Router\RouterServiceInterface</code> and use the <code class="code">Joomla\CMS\Component\Router\RouterServiceTrait</code>. Your service provider (<code class="filename">provider.php</code>) needs to register your Router factory provider and use the extension object's <code class="code">setRouterFactory</code> method to pass the resulting Router factory to the extension object.</p></li><li class="listitem"><p>Let Joomla associate items between languages on multi-language sites.</p><p>Your component must have a class extending the <code class="code">Joomla\CMS\Association\AssociationExtensionHelper</code>. Your service provider (<code class="filename">provider.php</code>) must register this class with the <code class="code">Joomla\CMS\Association\AssociationExtensionInterface::class</code> key and use the extension object's <code class="code">setAssociationExtension</code> method to assign the object resulting from that service to the extension object. Your extension object needs to implement the <code class="code">Joomla\CMS\Association\AssociationServiceInterface</code> and use the <code class="code">Joomla\CMS\Association\AssociationServiceTrait</code>.</p></li><li class="listitem"><p>Integrate with Joomla's Workflows feature.</p><p>Your extension class must implement the <code class="code">Joomla\CMS\Workflow\WorkflowServiceInterface</code> and use the <code class="code">Joomla\CMS\Workflow\WorkflowServiceTrait</code>. The extension class must override the <code class="code">getModelName</code>, <code class="code">filterTransitions</code>, <code class="code">getWorkflowTableBySection</code>, <code class="code">getWorkflowContexts</code> and <code class="code">getCategoryWorkflowContext</code> methods defined in the aforementioned trait and interface.</p></li></ul></div><p>As you can see, trying to do pretty much anything useful does require a custom extension class.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-extension-naming"></a>6.1.&nbsp;Naming your extension class</h3></div></div></div><p>There are no hard rules for naming your component's extension class. That said, to help anyone reading your code &#8212; including yourself six or so months later &#8212; retain a modicum of their sanity it is advisable to use the convention <code class="code"><em class="replaceable"><code>\My\Prefix</code></em>\Administrator\Extension\<em class="replaceable"><code>Name</code></em>Component</code> where \My\Prefix is the namespace prefix of your component and <code class="code">Name</code> is the name of your component without the <code class="code">com_</code> prefix.</p><p>For example, if you have a component named <code class="code">com_example</code> with the namespace prefix <code class="code">\Acme\Example</code> your extension class should be <code class="code">\Acme\Example\Administrator\Extension\ExampleComponent</code> and placed in the file <code class="filename">administrator/components/com_example/src/Extension/ExampleComponent.php</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-extension-provider"></a>6.2.&nbsp;Using your extension class in the service provider</h3></div></div></div><p>As you remember from the service provider section, in Part 2.a you need to instantiate the extension class. These lines would look like this:</p><pre class="programlisting">$component = new \Acme\Example\Administrator\Extension\ExampleComponent(
	$container-&gt;get(ComponentDispatcherFactoryInterface::class)
);</pre><p>Simple, isn't it?</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-extension-outside-com"></a>6.3.&nbsp;Using your extension class from outside the component</h3></div></div></div><p>Now we are finally able to answer the question which you had in mind coming to this section: why in the name of Cthulu do I have to have an extension class and what does it accomplish beyond adding yet another layer of complexity to my extension writing problems?</p><p>For that, let's consider this. Let's say we have a news site and we are building a system plugin which checks every day for newly published articles, auto-generating a daily summary blog post using the intro text of these articles and some preset template (maybe even some judicious use of a GPT-3&#8211;based AI). This plugin would need to publish an article. You could of course just instantiate the <code class="code">ArticleTable</code> class of <code class="code">com_content</code> directly to do that but this would not run any content plugins or create the right entries in the #__assets table, breaking your site. You need to use the com_content Article backend model of <code class="code">com_content</code>.</p><p>Back in the Joomla 3 days you would do that by directly instantiating the <code class="code">ContentModelArticle</code> class. Okay, first problem: Joomla didn't know where to find it so you have to <code class="code">require_once()</code> the file. Second problem: what if that model changes over time and has dependencies to other classes you have failed to require the files of? Believe me, I've been there, done that and it was about as enjoyable as using a rusty fork to pull my eyes out of their sockets.</p><p>In Joomla 4 you don't have to care about the class autoloading, but the <code class="code">ArticleModel</code> will actually need access to other services provided by the <code class="code">com_content</code> component for things like tagging, custom fields and workflows. If you try to instantiate the model class directly you will get a lot of errors as well. So, who are you gonna call? No, not Ghostbusters; they are Hollywood fiction. You're gonna call the very real and very useful <code class="code">bootComponent</code> method of the application!</p><pre class="programlisting">$contentExtension = \Joomla\CMS\Factory::getApplication()
  -&gt;bootComponent('com_content');
$articleModel = $contentExtension
  -&gt;getMVCFactory()
  -&gt;createModel('Article', 'Administrator');</pre><p>The first two lines told Joomla to &#8220;boot&#8221; the <code class="code">com_content</code> component, returning its <span class="emphasis"><em>extension object</em></span>. Now we have have access to all services known to this object through its various getters (method whose name start with <code class="code">get</code>).</p><p>This works for any component, anywhere, anytime. You can be in the frontend, backend, API application or CLI application or in an execution context you don't care to know about in a Scheduled Tasks plugin. No problem! You can boot any components &#8212; yours, core, or third party &#8212; to get its extension object and Bob's your uncle.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="com-extension-dic-proxy"></a>6.4.&nbsp;Getting access to the component's DIC anytime, anywhere</h3></div></div></div><p>I see that some of you are <span class="emphasis"><em>still</em></span> not convinced that the extension object is a cool concept.</p><p>Remember when I told you that the Joomla DIC &#8212; therefore the component's DIC which is a customised copy of it &#8212; is not a real Dependency Injection Container but a Service Locator and lamented the fact that you cannot get a reference to it from anywhere in your component, unlike modern PHP frameworks like Laravel?</p><p>Well, it turns out that you can get access to your component's DIC anywhere, anytime. You just need to add the following handy code to your extension's class:</p><pre class="programlisting">	protected static $dic;

	public function boot(ContainerInterface $container)
	{
		self::$dic = $container;
	}
	
	public static function getContainer()
	{
		if (empty(self::$dic))
		{
			Factory::getApplication()
			       -&gt;bootComponent('com_example');
		}
		
		return self::$dic;
	}
</pre><p>This code is very simple. We declare a protected static variable holding our component's DIC. This is initialised by the boot method which is called whenever the component is booted. The static method getContainer returns the component's DIC; if the DIC was undefined at this point it boots the component first.</p><p>So now you can simply do:</p><pre class="programlisting">$exampleDIC = \Acme\Example\Administrator\Extension\ExampleComponent::getContainer();</pre><p>The component's DIC gives you access to all of the application's services and your component's service. Using the MVCFactory to get an MVC object you can be sure that it will work as intended.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s05.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch03.html"><img src="images/up.svg" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch03s07.html"><img src="images/next.svg" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">5.&nbsp;Service provider&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.svg" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;7.&nbsp;Dispatcher</td></tr></table></div></body></html>